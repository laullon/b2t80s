ca65 V2.18 - N/A
Main file   : 6502_functional_test.a65
Current file: 6502_functional_test.a65

000000r 1               ;
000000r 1               ; 6 5 0 2   F U N C T I O N A L   T E S T
000000r 1               ;
000000r 1               ; Copyright (C) 2012-2015  Klaus Dormann
000000r 1               ;
000000r 1               ; This program is free software: you can redistribute it and/or modify
000000r 1               ; it under the terms of the GNU General Public License as published by
000000r 1               ; the Free Software Foundation, either version 3 of the License, or
000000r 1               ; (at your option) any later version.
000000r 1               ;
000000r 1               ; This program is distributed in the hope that it will be useful,
000000r 1               ; but WITHOUT ANY WARRANTY; without even the implied warranty of
000000r 1               ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
000000r 1               ; GNU General Public License for more details.
000000r 1               ;
000000r 1               ; You should have received a copy of the GNU General Public License
000000r 1               ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
000000r 1               
000000r 1               
000000r 1               ; This program is designed to test all opcodes of a 6502 emulator using all
000000r 1               ; addressing modes with focus on propper setting of the processor status
000000r 1               ; register bits.
000000r 1               ;
000000r 1               ; version 01-aug-2019
000000r 1               ; contact info at http://2m5.de or email K@2m5.de
000000r 1               ;
000000r 1               ; assembled with CA65, linked with LD65 (cc65.github.io):
000000r 1               ;  ca65 -l 6502_functional_test.lst 6502_functional_test.ca65
000000r 1               ;  ld65 6502_functional_test.o -o 6502_functional_test.bin \
000000r 1               ;   -m 6502_functional_test.map -C example.cfg
000000r 1               ; example linker config (example.cfg):
000000r 1               ;  MEMORY {
000000r 1               ;  RAM: start = $0000, size=$8000, type = rw, fill = yes, \
000000r 1               ;   fillval = $FF, file = %O;
000000r 1               ;  ROM: start = $8000, size=$7FFA, type = ro, fill = yes, \
000000r 1               ;   fillval = $FF, file = %O;
000000r 1               ;  ROM_VECTORS: start = $FFFA, size=6, type = ro, fill = yes, \
000000r 1               ;   fillval = $FF, file = %O;
000000r 1               ;  }
000000r 1               ;  SEGMENTS {
000000r 1               ;  ZEROPAGE: load=RAM, type=rw;
000000r 1               ;  DATA: load=RAM, type=rw, offset=$0200;
000000r 1               ;  CODE: load=RAM, type=rw, offset=$0400;
000000r 1               ;  VECTORS: load=ROM_VECTORS, type=ro;
000000r 1               ;  }
000000r 1               ;
000000r 1               ; No IO - should be run from a monitor with access to registers.
000000r 1               ; To run load intel hex image with a load command, than alter PC to 400 hex
000000r 1               ; (code_segment) and enter a go command.
000000r 1               ; Loop on program counter determines error or successful completion of test.
000000r 1               ; Check listing for relevant traps (jump/branch *).
000000r 1               ; Please note that in early tests some instructions will have to be used before
000000r 1               ; they are actually tested!
000000r 1               ;
000000r 1               ; RESET, NMI or IRQ should not occur and will be trapped if vectors are enabled.
000000r 1               ; Tests documented behavior of the original NMOS 6502 only! No unofficial
000000r 1               ; opcodes. Additional opcodes of newer versions of the CPU (65C02, 65816) will
000000r 1               ; not be tested. Decimal ops will only be tested with valid BCD operands and
000000r 1               ; N V Z flags will be ignored.
000000r 1               ;
000000r 1               ; Debugging hints:
000000r 1               ;     Most of the code is written sequentially. if you hit a trap, check the
000000r 1               ;   immediately preceeding code for the instruction to be tested. Results are
000000r 1               ;   tested first, flags are checked second by pushing them onto the stack and
000000r 1               ;   pulling them to the accumulator after the result was checked. The "real"
000000r 1               ;   flags are no longer valid for the tested instruction at this time!
000000r 1               ;     If the tested instruction was indexed, the relevant index (X or Y) must
000000r 1               ;   also be checked. Opposed to the flags, X and Y registers are still valid.
000000r 1               ;
000000r 1               ; versions:
000000r 1               ;   28-jul-2012  1st version distributed for testing
000000r 1               ;   29-jul-2012  fixed references to location 0, now #0
000000r 1               ;                added license - GPLv3
000000r 1               ;   30-jul-2012  added configuration options
000000r 1               ;   01-aug-2012  added trap macro to allow user to change error handling
000000r 1               ;   01-dec-2012  fixed trap in branch field must be a branch
000000r 1               ;   02-mar-2013  fixed PLA flags not tested
000000r 1               ;   19-jul-2013  allowed ROM vectors to be loaded when load_data_direct = 0
000000r 1               ;                added test sequence check to detect if tests jump their fence
000000r 1               ;   23-jul-2013  added RAM integrity check option
000000r 1               ;   16-aug-2013  added error report to standard output option
000000r 1               ;   13-dec-2014  added binary/decimal opcode table switch test
000000r 1               ;   14-dec-2014  improved relative address test
000000r 1               ;   23-aug-2015  added option to disable self modifying tests
000000r 1               ;   24-aug-2015  all self modifying immediate opcodes now execute in data RAM
000000r 1               ;                added small branch offset pretest
000000r 1               ;   21-oct-2015  added option to disable decimal mode ADC & SBC tests
000000r 1               ;   04-dec-2017  fixed BRK only tested with interrupts enabled
000000r 1               ;                added option to skip the remainder of a failing test
000000r 1               ;                in report.i65
000000r 1               
000000r 1               
000000r 1               ; C O N F I G U R A T I O N
000000r 1               
000000r 1               ;ROM_vectors writable (0=no, 1=yes)
000000r 1               ;if ROM vectors can not be used interrupts will not be trapped
000000r 1               ;as a consequence BRK can not be tested but will be emulated to test RTI
000000r 1               ROM_vectors = 1
000000r 1               
000000r 1               ;load_data_direct (0=move from code segment, 1=load directly)
000000r 1               ;loading directly is preferred but may not be supported by your platform
000000r 1               ;0 produces only consecutive object code, 1 is not suitable for a binary image
000000r 1               load_data_direct = 1
000000r 1               
000000r 1               ;I_flag behavior (0=force enabled, 1=force disabled, 2=prohibit change, 3=allow
000000r 1               ;change) 2 requires extra code and is not recommended. SEI & CLI can only be
000000r 1               ;tested if you allow changing the interrupt status (I_flag = 3)
000000r 1               I_flag = 3
000000r 1               
000000r 1               ;configure memory - try to stay away from memory used by the system
000000r 1               ;zero_page memory start address, $50 (80) consecutive Bytes required
000000r 1               ;                                add 2 if I_flag = 2
000000r 1               zero_page = $a
000000r 1               
000000r 1               ;data_segment memory start address, $6A (106) consecutive Bytes required
000000r 1               ; check that this matches the linker configuration file
000000r 1               data_segment = $200
000000r 1                   .if (data_segment & $ff) <> 0
000000r 1                       .error "low byte of data_segment MUST be $00 !!"
000000r 1                   .endif
000000r 1               
000000r 1               ;code_segment memory start address, 13kB of consecutive space required
000000r 1               ;                                   add 2.5 kB if I_flag = 2
000000r 1               ; check that this matches the linker configuration file
000000r 1               code_segment = $400
000000r 1               
000000r 1               ;self modifying code may be disabled to allow running in ROM
000000r 1               ;0=part of the code is self modifying and must reside in RAM
000000r 1               ;1=tests disabled: branch range
000000r 1               disable_selfmod = 1
000000r 1               
000000r 1               ;report errors through I/O channel (0=use standard self trap loops, 1=include
000000r 1               ;report.i65 as I/O channel, add 3.5 kB)
000000r 1               report = 0
000000r 1               
000000r 1               ;RAM integrity test option. Checks for undesired RAM writes.
000000r 1               ;set lowest non RAM or RAM mirror address page (-1=disable, 0=64k, $40=16k)
000000r 1               ;leave disabled if a monitor, OS or background interrupt is allowed to alter RAM
000000r 1               ram_top = -1
000000r 1               
000000r 1               ;disable test decimal mode ADC & SBC, 0=enable, 1=disable,
000000r 1               ;2=disable including decimal flag in processor status
000000r 1               disable_decimal = 0
000000r 1               
000000r 1               ;macros for error & success traps to allow user modification
000000r 1               ;example:
000000r 1               ;        .macro  trap
000000r 1               ;        jsr my_error_handler
000000r 1               ;        .endmacro
000000r 1               ;        .macro  trap_eq
000000r 1               ;        bne :+
000000r 1               ;        trap           ;failed equal (zero)
000000r 1               ;:
000000r 1               ;        .endmacro
000000r 1               ;
000000r 1               ; my_error_handler should pop the calling address from the stack and report it.
000000r 1               ; putting larger portions of code (more than 3 bytes) inside the trap macro
000000r 1               ; may lead to branch range problems for some tests.
000000r 1                   .if report = 0
000000r 1                       .macro  trap
000000r 1                       jmp *           ;failed anyway
000000r 1                       .endmacro
000000r 1                       .macro  trap_eq
000000r 1                       beq *           ;failed equal (zero)
000000r 1                       .endmacro
000000r 1                       .macro  trap_ne
000000r 1                       bne *           ;failed not equal (non zero)
000000r 1                       .endmacro
000000r 1                       .macro  trap_cs
000000r 1                       bcs *           ;failed carry set
000000r 1                       .endmacro
000000r 1                       .macro  trap_cc
000000r 1                       bcc *           ;failed carry clear
000000r 1                       .endmacro
000000r 1                       .macro  trap_mi
000000r 1                       bmi *           ;failed minus (bit 7 set)
000000r 1                       .endmacro
000000r 1                       .macro  trap_pl
000000r 1                       bpl *           ;failed plus (bit 7 clear)
000000r 1                       .endmacro
000000r 1                       .macro  trap_vs
000000r 1                       bvs *           ;failed overflow set
000000r 1                       .endmacro
000000r 1                       .macro  trap_vc
000000r 1                       bvc *           ;failed overflow clear
000000r 1                       .endmacro
000000r 1               ; please observe that during the test the stack gets invalidated
000000r 1               ; therefore a RTS inside the success macro is not possible
000000r 1                       .macro  success
000000r 1                       jmp *           ;test passed, no errors
000000r 1                       .endmacro
000000r 1                   .endif
000000r 1                   .if report = 1
000000r 1                       .macro  trap
000000r 1                       jsr report_error
000000r 1                       .endmacro
000000r 1                       .macro  trap_eq
000000r 1                       bne :+
000000r 1                       trap           ;failed equal (zero)
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_ne
000000r 1                       beq :+
000000r 1                       trap            ;failed not equal (non zero)
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_cs
000000r 1                       bcc :+
000000r 1                       trap            ;failed carry set
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_cc
000000r 1                       bcs :+
000000r 1                       trap            ;failed carry clear
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_mi
000000r 1                       bpl :+
000000r 1                       trap            ;failed minus (bit 7 set)
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_pl
000000r 1                       bmi :+
000000r 1                       trap            ;failed plus (bit 7 clear)
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_vs
000000r 1                       bvc :+
000000r 1                       trap            ;failed overflow set
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_vc
000000r 1                       bvs :+
000000r 1                       trap            ;failed overflow clear
000000r 1               :
000000r 1                       .endmacro
000000r 1               ; please observe that during the test the stack gets invalidated
000000r 1               ; therefore a RTS inside the success macro is not possible
000000r 1                       .macro  success
000000r 1                       jsr report_success
000000r 1                       .endmacro
000000r 1                   .endif
000000r 1               
000000r 1                   .define equ =
000000r 1               
000000r 1               carry   equ %00000001   ;flag bits in status
000000r 1               zero    equ %00000010
000000r 1               intdis  equ %00000100
000000r 1               decmode equ %00001000
000000r 1               break   equ %00010000
000000r 1               reserv  equ %00100000
000000r 1               overfl  equ %01000000
000000r 1               minus   equ %10000000
000000r 1               
000000r 1               fc      equ carry
000000r 1               fz      equ zero
000000r 1               fzc     equ carry+zero
000000r 1               fv      equ overfl
000000r 1               fvz     equ overfl+zero
000000r 1               fn      equ minus
000000r 1               fnc     equ minus+carry
000000r 1               fnz     equ minus+zero
000000r 1               fnzc    equ minus+zero+carry
000000r 1               fnv     equ minus+overfl
000000r 1               
000000r 1               fao     equ break+reserv    ;bits always on after PHP, BRK
000000r 1               fai     equ fao+intdis      ;+ forced interrupt disable
000000r 1               faod    equ fao+decmode     ;+ ignore decimal
000000r 1               faid    equ fai+decmode     ;+ ignore decimal
000000r 1               m8      equ $ff             ;8 bit mask
000000r 1               m8i     equ $ff&~intdis     ;8 bit mask - interrupt disable
000000r 1               
000000r 1               ;macros to allow masking of status bits.
000000r 1               ;masking test of decimal bit
000000r 1               ;masking of interrupt enable/disable on load and compare
000000r 1               ;masking of always on bits after PHP or BRK (unused & break) on compare
000000r 1                   .if disable_decimal < 2
000000r 1                       .if I_flag = 0
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1&m8i          ;force enable interrupts (mask I)
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           cmp #(p1|fao)&m8i   ;I_flag is always enabled + always on bits
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           eor #(p1&m8i|fao)   ;mask I, invert expected flags + always on bits
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                       .if I_flag = 1
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1|intdis      ;force disable interrupts
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           cmp #(p1|fai)&m8    ;I_flag is always disabled + always on bits
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           eor #(p1|fai)       ;invert expected flags + always on bits + I
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                       .if I_flag = 2
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1
000000r 1                           ora flag_I_on       ;restore I-flag
000000r 1                           and flag_I_off
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           eor flag_I_on       ;I_flag is never changed
000000r 1                           cmp #(p1|fao)&m8i   ;expected flags + always on bits, mask I
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           eor flag_I_on       ;I_flag is never changed
000000r 1                           eor #(p1&m8i|fao)   ;mask I, invert expected flags + always on bits
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                       .if I_flag = 3
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1             ;allow test to change I-flag (no mask)
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           cmp #(p1|fao)&m8    ;expected flags + always on bits
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           eor #p1|fao         ;invert expected flags + always on bits
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                   .else
000000r 1                       .if I_flag = 0
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1&m8i         ;force enable interrupts (mask I)
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           cmp #(p1|faod)&m8i  ;I_flag is always enabled + always on bits
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           eor #(p1&m8i|faod)  ;mask I, invert expected flags + always on bits
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                       .if I_flag = 1
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1|intdis      ;force disable interrupts
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           cmp #(p1|faid)&m8   ;I_flag is always disabled + always on bits
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           eor #(p1|faid)      ;invert expected flags + always on bits + I
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                       .if I_flag = 2
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1
000000r 1                           ora flag_I_on       ;restore I-flag
000000r 1                           and flag_I_off
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           eor flag_I_on       ;I_flag is never changed
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           cmp #(p1|faod)&m8i  ;expected flags + always on bits, mask I
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           eor flag_I_on       ;I_flag is never changed
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           eor #(p1&m8i|faod)  ;mask I, invert expected flags + always on bits
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                       .if I_flag = 3
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1             ;allow test to change I-flag (no mask)
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           cmp #(p1|faod)&m8   ;expected flags + always on bits
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           eor #p1|faod        ;invert expected flags + always on bits
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                   .endif
000000r 1               
000000r 1               ;macros to set (register|memory|zeropage) & status
000000r 1                           .macro      set_stat    p1          ;setting flags in the processor status register
000000r 1                           load_flag p1
000000r 1                           pha         ;use stack to load status
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_a       p1,p2       ;precharging accu & status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda #p1     ;precharge accu
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_x       p1,p2       ;precharging index & status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           ldx #p1     ;precharge index x
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_y       p1,p2       ;precharging index & status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           ldy #p1     ;precharge index y
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_ax      p1,p2       ;precharging indexed accu & immediate status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda p1,x    ;precharge accu
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_ay      p1,p2       ;precharging indexed accu & immediate status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda p1,y    ;precharge accu
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_z       p1,p2       ;precharging indexed zp & immediate status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda p1,x    ;load to zeropage
000000r 1                           sta zpt
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_zx      p1,p2       ;precharging zp,x & immediate status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda p1,x    ;load to indexed zeropage
000000r 1                           sta zpt,x
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_abs     p1,p2       ;precharging indexed memory & immediate status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda p1,x    ;load to memory
000000r 1                           sta abst
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_absx    p1,p2       ;precharging abs,x & immediate status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda p1,x    ;load to indexed memory
000000r 1                           sta abst,x
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1               ;macros to test (register|memory|zeropage) & status & (mask)
000000r 1                           .macro      tst_stat    p1          ;testing flags in the processor status register
000000r 1                           php         ;save status
000000r 1                           pla         ;use stack to retrieve status
000000r 1                           pha
000000r 1                           cmp_flag p1
000000r 1                           trap_ne
000000r 1                           plp         ;restore status
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_a       p1,p2        ;testing result in accu & flags
000000r 1                           php         ;save flags
000000r 1                           cmp #p1     ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           pha
000000r 1                           cmp_flag p2
000000r 1                           trap_ne
000000r 1                           plp         ;restore status
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_x       p1,p2       ;testing result in x index & flags
000000r 1                           php         ;save flags
000000r 1                           cpx #p1     ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           pha
000000r 1                           cmp_flag p2
000000r 1                           trap_ne
000000r 1                           plp         ;restore status
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_y       p1,p2       ;testing result in y index & flags
000000r 1                           php         ;save flags
000000r 1                           cpy #p1     ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           pha
000000r 1                           cmp_flag p2
000000r 1                           trap_ne
000000r 1                           plp         ;restore status
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_ax      p1,p2,p3    ;indexed testing result in accu & flags
000000r 1                           php         ;save flags
000000r 1                           cmp p1,x    ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           eor_flag p3
000000r 1                           cmp p2,x    ;test flags
000000r 1                           trap_ne     ;
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_ay      p1,p2,p3    ;indexed testing result in accu & flags
000000r 1                           php         ;save flags
000000r 1                           cmp p1,y    ;test result
000000r 1                           trap_ne     ;
000000r 1                           pla         ;load status
000000r 1                           eor_flag p3
000000r 1                           cmp p2,y    ;test flags
000000r 1                           trap_ne
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_z       p1,p2,p3    ;indexed testing result in zp & flags
000000r 1                           php         ;save flags
000000r 1                           lda zpt
000000r 1                           cmp p1,x    ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           eor_flag p3
000000r 1                           cmp p2,x    ;test flags
000000r 1                           trap_ne
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_zx      p1,p2,p3    ;testing result in zp,x & flags
000000r 1                           php         ;save flags
000000r 1                           lda zpt,x
000000r 1                           cmp p1,x    ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           eor_flag p3
000000r 1                           cmp p2,x    ;test flags
000000r 1                           trap_ne
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_abs     p1,p2,p3    ;indexed testing result in memory & flags
000000r 1                           php         ;save flags
000000r 1                           lda abst
000000r 1                           cmp p1,x    ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           eor_flag p3
000000r 1                           cmp p2,x    ;test flags
000000r 1                           trap_ne
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_absx    p1,p2,p3    ;testing result in abs,x & flags
000000r 1                           php         ;save flags
000000r 1                           lda abst,x
000000r 1                           cmp p1,x    ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           eor_flag p3
000000r 1                           cmp p2,x    ;test flags
000000r 1                           trap_ne
000000r 1                           .endmacro
000000r 1               
000000r 1               ; RAM integrity test
000000r 1               ;   verifies that none of the previous tests has altered RAM outside of the
000000r 1               ;   designated write areas.
000000r 1               ;   uses zpt word as indirect pointer, zpt+2 word as checksum
000000r 1                       .if ram_top > -1
000000r 1               check_ram   macro
000000r 1                           cld
000000r 1                           lda #0
000000r 1                           sta zpt         ;set low byte of indirect pointer
000000r 1                           sta zpt+3       ;checksum high byte
000000r 1                         .if disable_selfmod = 0
000000r 1                           sta range_adr   ;reset self modifying code
000000r 1                         .endif
000000r 1                           clc
000000r 1                           ldx #zp_bss-zero_page ;zeropage - write test area
000000r 1               ccs3:       adc zero_page,x
000000r 1                           bcc ccs2
000000r 1                           inc zpt+3       ;carry to high byte
000000r 1                           clc
000000r 1               ccs2:       inx
000000r 1                           bne ccs3
000000r 1                           ldx #hi(abs1)   ;set high byte of indirect pointer
000000r 1                           stx zpt+1
000000r 1                           ldy #lo(abs1)   ;data after write & execute test area
000000r 1               ccs5:       adc (zpt),y
000000r 1                           bcc ccs4
000000r 1                           inc zpt+3       ;carry to high byte
000000r 1                           clc
000000r 1               ccs4:       iny
000000r 1                           bne ccs5
000000r 1                           inx             ;advance RAM high address
000000r 1                           stx zpt+1
000000r 1                           cpx #ram_top
000000r 1                           bne ccs5
000000r 1                           sta zpt+2       ;checksum low is
000000r 1                           cmp ram_chksm   ;checksum low expected
000000r 1                           trap_ne         ;checksum mismatch
000000r 1                           lda zpt+3       ;checksum high is
000000r 1                           cmp ram_chksm+1 ;checksum high expected
000000r 1                           trap_ne         ;checksum mismatch
000000r 1                           .endmacro
000000r 1                       .else
000000r 1                           .macro  check_ram
000000r 1                           ;RAM check disabled - RAM size not set
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1               
000000r 1                           .macro  next_test   ;make sure, tests don't jump the fence
000000r 1                           lda test_case   ;previous test
000000r 1                           cmp #test_num
000000r 1                           trap_ne         ;test is out of sequence
000000r 1               test_num .set test_num + 1
000000r 1                           lda #test_num   ;*** next tests' number
000000r 1                           sta test_case
000000r 1                           ;check_ram       ;uncomment to find altered RAM after each test
000000r 1                           .endmacro
000000r 1               
000000r 1                       .ZEROPAGE
000000r 1  00 00 00 00  		.res zero_page, 0
000004r 1  00 00 00 00  
000008r 1  00 00        
00000Ar 1                       .org zero_page
00000A  1               
00000A  1               ;break test interrupt save
00000A  1  00           irq_a:  .res    1,0             ;a register
00000B  1  00           irq_x:  .res    1,0             ;x register
00000C  1                   .if I_flag = 2
00000C  1               ;masking for I bit in status
00000C  1               flag_I_on:  .res    1,0         ;or mask to load flags
00000C  1               flag_I_off: .res    1,0         ;and mask to load flags
00000C  1                   .endif
00000C  1               zpt:                        ;5 bytes store/modify test area
00000C  1               ;add/subtract operand generation and result/flag prediction
00000C  1  00           adfc:   .res    1,0             ;carry flag before op
00000D  1  00           ad1:    .res    1,0             ;operand 1 - accumulator
00000E  1  00           ad2:    .res    1,0             ;operand 2 - memory / immediate
00000F  1  00           adrl:   .res    1,0             ;expected result bits 0-7
000010  1  00           adrh:   .res    1,0             ;expected result bit 8 (carry)
000011  1  00           adrf:   .res    1,0             ;expected flags NV0000ZC (only binary mode)
000012  1  00           sb2:    .res    1,0             ;operand 2 complemented for subtract
000013  1               zp_bss:
000013  1  C3 82 41 00  zp1:    .byte   $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
000017  1  7F           zp7f:   .byte   $7f             ;test pattern for compare
000018  1               ;logical zeropage operands
000018  1  00 1F 71 80  zpOR:   .byte   0,$1f,$71,$80   ;test pattern for OR
00001C  1  0F FF 7F 80  zpAN:   .byte   $0f,$ff,$7f,$80 ;test pattern for AND
000020  1  FF 0F 8F 8F  zpEO:   .byte   $ff,$0f,$8f,$8f ;test pattern for EOR
000024  1               ;indirect addressing pointers
000024  1  17 02        ind1:   .word   abs1            ;indirect pointer to pattern in absolute memory
000026  1  18 02                .word   abs1+1
000028  1  19 02                .word   abs1+2
00002A  1  1A 02                .word   abs1+3
00002C  1  1B 02                .word   abs7f
00002E  1  1F 01        inw1:   .word   abs1-$f8        ;indirect pointer for wrap-test pattern
000030  1  03 02        indt:   .word   abst            ;indirect pointer to store area in absolute memory
000032  1  04 02                .word   abst+1
000034  1  05 02                .word   abst+2
000036  1  06 02                .word   abst+3
000038  1  0B 01        inwt:   .word   abst-$f8        ;indirect pointer for wrap-test store
00003A  1  4E 02        indAN:  .word   absAN           ;indirect pointer to AND pattern in absolute memory
00003C  1  4F 02                .word   absAN+1
00003E  1  50 02                .word   absAN+2
000040  1  51 02                .word   absAN+3
000042  1  52 02        indEO:  .word   absEO           ;indirect pointer to EOR pattern in absolute memory
000044  1  53 02                .word   absEO+1
000046  1  54 02                .word   absEO+2
000048  1  55 02                .word   absEO+3
00004A  1  4A 02        indOR:  .word   absOR           ;indirect pointer to OR pattern in absolute memory
00004C  1  4B 02                .word   absOR+1
00004E  1  4C 02                .word   absOR+2
000050  1  4D 02                .word   absOR+3
000052  1               ;add/subtract indirect pointers
000052  1  03 02        adi2:   .word   ada2            ;indirect pointer to operand 2 in absolute memory
000054  1  04 02        sbi2:   .word   sba2            ;indirect pointer to complemented operand 2 (SBC)
000056  1  04 01        adiy2:  .word   ada2-$ff        ;with offset for indirect indexed
000058  1  05 01        sbiy2:  .word   sba2-$ff
00005A  1               zp_bss_end:
00005A  1               
00005A  1                       .DATA
00005A  1                       .org data_segment
000200  1               
000200  1  00           test_case:  .res    1,0         ;current test number
000201  1  00 00        ram_chksm:  .res    2,0         ;checksum for RAM integrity test
000203  1               ;add/subtract operand copy - abs tests write area
000203  1               abst:                       ;5 bytes store/modify test area
000203  1  00           ada2:   .res    1,0             ;operand 2
000204  1  00           sba2:   .res    1,0             ;operand 2 complemented for subtract
000205  1  00 00 00             .res    3,0             ;fill remaining bytes
000208  1               data_bss:
000208  1                   .if load_data_direct = 1
000208  1  29 00        ex_andi:and #0              ;execute immediate opcodes
00020A  1  60                   rts
00020B  1  49 00        ex_eori:eor #0              ;execute immediate opcodes
00020D  1  60                   rts
00020E  1  09 00        ex_orai:ora #0              ;execute immediate opcodes
000210  1  60                   rts
000211  1  69 00        ex_adci:adc #0              ;execute immediate opcodes
000213  1  60                   rts
000214  1  E9 00        ex_sbci:sbc #0              ;execute immediate opcodes
000216  1  60                   rts
000217  1                   .else
000217  1               ex_andi:.res    3
000217  1               ex_eori:.res    3
000217  1               ex_orai:.res    3
000217  1               ex_adci:.res    3
000217  1               ex_sbci:.res    3
000217  1                   .endif
000217  1  C3 82 41 00  abs1:   .byte   $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
00021B  1  7F           abs7f:  .byte   $7f             ;test pattern for compare
00021C  1               ;loads
00021C  1  80 80 00 02  fLDx:   .byte   fn,fn,0,fz      ;expected flags for load
000220  1               ;shifts
000220  1               rASL:                       ;expected result ASL & ROL -carry
000220  1  86 04 82 00  rROL:   .byte   $86,$04,$82,0   ; "
000224  1  87 05 83 01  rROLc:  .byte   $87,$05,$83,1   ;expected result ROL +carry
000228  1               rLSR:                       ;expected result LSR & ROR -carry
000228  1  61 41 20 00  rROR:   .byte   $61,$41,$20,0   ; "
00022C  1  E1 C1 A0 80  rRORc:  .byte   $e1,$c1,$a0,$80 ;expected result ROR +carry
000230  1               fASL:                       ;expected flags for shifts
000230  1  81 01 80 02  fROL:   .byte   fnc,fc,fn,fz    ;no carry in
000234  1  81 01 80 00  fROLc:  .byte   fnc,fc,fn,0     ;carry in
000238  1               fLSR:
000238  1  01 00 01 02  fROR:   .byte   fc,0,fc,fz      ;no carry in
00023C  1  81 80 81 80  fRORc:  .byte   fnc,fn,fnc,fn   ;carry in
000240  1               ;increments (decrements)
000240  1  7F 80 FF 00  rINC:   .byte   $7f,$80,$ff,0,1 ;expected result for INC/DEC
000244  1  01           
000245  1  00 80 80 02  fINC:   .byte   0,fn,fn,fz,0    ;expected flags for INC/DEC
000249  1  00           
00024A  1               ;logical memory operand
00024A  1  00 1F 71 80  absOR:  .byte   0,$1f,$71,$80   ;test pattern for OR
00024E  1  0F FF 7F 80  absAN:  .byte   $0f,$ff,$7f,$80 ;test pattern for AND
000252  1  FF 0F 8F 8F  absEO:  .byte   $ff,$0f,$8f,$8f ;test pattern for EOR
000256  1               ;logical accu operand
000256  1  00 F1 1F 00  absORa: .byte   0,$f1,$1f,0     ;test pattern for OR
00025A  1  F0 FF FF FF  absANa: .byte   $f0,$ff,$ff,$ff ;test pattern for AND
00025E  1  FF F0 F0 0F  absEOa: .byte   $ff,$f0,$f0,$0f ;test pattern for EOR
000262  1               ;logical results
000262  1  00 FF 7F 80  absrlo: .byte   0,$ff,$7f,$80
000266  1  02 80 00 80  absflo: .byte   fz,fn,0,fn
00026A  1               data_bss_end:
00026A  1               
00026A  1               
00026A  1                       .CODE
00026A  1                       .org code_segment
000400  1                       .P02            ; disable 65SC02, 65C02 and 65816 instructions
000400  1  D8           start:  cld
000401  1  A2 FF                ldx #$ff
000403  1  9A                   txs
000404  1  A9 00                lda #0          ;*** test 0 = initialize
000406  1  8D 00 02             sta test_case
000409  1               test_num .set 0
000409  1               
000409  1               ;stop interrupts before initializing BSS
000409  1                   .if I_flag = 1
000409  1                       sei
000409  1                   .endif
000409  1               
000409  1               ;initialize I/O for report channel
000409  1                   .if report = 1
000409  1                       jsr report_init
000409  1                   .endif
000409  1               
000409  1               ;pretest small branch offset
000409  1  A2 05                ldx #5
00040B  1  4C 33 04             jmp psb_test
00040E  1               psb_bwok:
00040E  1  A0 05                ldy #5
000410  1  D0 08                bne psb_forw
000412  1  4C 12 04             trap        ;branch should be taken
000415  1  88                   dey         ;forward landing zone
000416  1  88                   dey
000417  1  88                   dey
000418  1  88                   dey
000419  1  88                   dey
00041A  1               psb_forw:
00041A  1  88                   dey
00041B  1  88                   dey
00041C  1  88                   dey
00041D  1  88                   dey
00041E  1  88                   dey
00041F  1  F0 17                beq psb_fwok
000421  1  4C 21 04             trap        ;forward offset
000424  1               
000424  1  CA                   dex         ;backward landing zone
000425  1  CA                   dex
000426  1  CA                   dex
000427  1  CA                   dex
000428  1  CA                   dex
000429  1               psb_back:
000429  1  CA                   dex
00042A  1  CA                   dex
00042B  1  CA                   dex
00042C  1  CA                   dex
00042D  1  CA                   dex
00042E  1  F0 DE                beq psb_bwok
000430  1  4C 30 04             trap        ;backward offset
000433  1               psb_test:
000433  1  D0 F4                bne psb_back
000435  1  4C 35 04             trap        ;branch should be taken
000438  1               psb_fwok:
000438  1               
000438  1               ;initialize BSS segment
000438  1                   .if load_data_direct <> 1
000438  1                       ldx #zp_end-zp_init-1
000438  1               ld_zp:  lda zp_init,x
000438  1                       sta zp_bss,x
000438  1                       dex
000438  1                       bpl ld_zp
000438  1                       ldx #data_end-data_init-1
000438  1               ld_data:lda data_init,x
000438  1                       sta data_bss,x
000438  1                       dex
000438  1                       bpl ld_data
000438  1                     .if ROM_vectors = 1
000438  1                       ldx #5
000438  1               ld_vect:lda vec_init,x
000438  1                       sta vec_bss,x
000438  1                       dex
000438  1                       bpl ld_vect
000438  1                     .endif
000438  1                   .endif
000438  1               
000438  1               ;retain status of interrupt flag
000438  1                   .if I_flag = 2
000438  1                       php
000438  1                       pla
000438  1                       and #4          ;isolate flag
000438  1                       sta flag_I_on   ;or mask
000438  1                       eor #lo(~4)     ;reverse
000438  1                       sta flag_I_off  ;and mask
000438  1                   .endif
000438  1               
000438  1               ;generate checksum for RAM integrity test
000438  1                   .if ram_top > -1
000438  1                       lda #0
000438  1                       sta zpt         ;set low byte of indirect pointer
000438  1                       sta ram_chksm+1 ;checksum high byte
000438  1                     .if disable_selfmod = 0
000438  1                       sta range_adr   ;reset self modifying code
000438  1                     .endif
000438  1                       clc
000438  1                       ldx #zp_bss-zero_page ;zeropage - write test area
000438  1               gcs3:   adc zero_page,x
000438  1                       bcc gcs2
000438  1                       inc ram_chksm+1 ;carry to high byte
000438  1                       clc
000438  1               gcs2:   inx
000438  1                       bne gcs3
000438  1                       ldx #hi(abs1)   ;set high byte of indirect pointer
000438  1                       stx zpt+1
000438  1                       ldy #lo(abs1)   ;data after write & execute test area
000438  1               gcs5:   adc (zpt),y
000438  1                       bcc gcs4
000438  1                       inc ram_chksm+1 ;carry to high byte
000438  1                       clc
000438  1               gcs4:   iny
000438  1                       bne gcs5
000438  1                       inx             ;advance RAM high address
000438  1                       stx zpt+1
000438  1                       cpx #ram_top
000438  1                       bne gcs5
000438  1                       sta ram_chksm   ;checksum complete
000438  1                   .endif
000438  1  AD 00 02 C9          next_test
00043C  1  00 D0 FE A9  
000440  1  01 8D 00 02  
000444  1               
000444  1                   .if disable_selfmod = 0
000444  1               ;testing relative addressing with BEQ
000444  1                       ldy #$fe        ;testing maximum range, not -1/-2 (invalid/self adr)
000444  1               range_loop:
000444  1                       dey             ;next relative address
000444  1                       tya
000444  1                       tax             ;precharge count to end of loop
000444  1                       bpl range_fw    ;calculate relative address
000444  1                       clc             ;avoid branch self or to relative address of branch
000444  1                       adc #2
000444  1                       nop             ;offset landing zone - tolerate +/-5 offset to branch
000444  1                       nop
000444  1                       nop
000444  1                       nop
000444  1                       nop
000444  1               range_fw:
000444  1                       nop
000444  1                       nop
000444  1                       nop
000444  1                       nop
000444  1                       nop
000444  1                       eor #$7f        ;complement except sign
000444  1                       sta range_adr   ;load into test target
000444  1                       lda #0          ;should set zero flag in status register
000444  1                       jmp range_op
000444  1               
000444  1                       dex             ; offset landing zone - backward branch too far
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       ;relative address target field with branch under test in the middle
000444  1                       dex             ;-128 - max backward
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex             ;-120
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex             ;-110
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex             ;-100
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex             ;-90
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex             ;-80
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex             ;-70
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex             ;-60
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex             ;-50
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex             ;-40
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex             ;-30
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex             ;-20
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex             ;-10
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex             ;-3
000444  1               range_op:               ;test target with zero flag=0, z=1 if previous dex
000444  1               range_adr   = *+1       ;modifiable relative address
000444  1                       beq *+64        ;+64 if called without modification
000444  1                       dex             ;+0
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex             ;+10
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex             ;+20
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex             ;+30
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex             ;+40
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex             ;+50
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex             ;+60
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex             ;+70
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex             ;+80
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex             ;+90
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex             ;+100
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex             ;+110
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex             ;+120
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       dex
000444  1                       nop             ;offset landing zone - forward branch too far
000444  1                       nop
000444  1                       nop
000444  1                       nop
000444  1                       nop
000444  1                       beq range_ok    ;+127 - max forward
000444  1                       trap            ; bad range
000444  1                       nop             ;offset landing zone - tolerate +/-5 offset to branch
000444  1                       nop
000444  1                       nop
000444  1                       nop
000444  1                       nop
000444  1               range_ok:
000444  1                       nop
000444  1                       nop
000444  1                       nop
000444  1                       nop
000444  1                       nop
000444  1                       cpy #0
000444  1                       beq range_end
000444  1                       jmp range_loop
000444  1               range_end:              ;range test successful
000444  1                   .endif
000444  1  AD 00 02 C9          next_test
000448  1  01 D0 FE A9  
00044C  1  02 8D 00 02  
000450  1               
000450  1               ;partial test BNE & CMP, CPX, CPY immediate
000450  1  C0 01                cpy #1          ;testing BNE true
000452  1  D0 03                bne test_bne
000454  1  4C 54 04             trap
000457  1               test_bne:
000457  1  A9 00                lda #0
000459  1  C9 00                cmp #0          ;test compare immediate
00045B  1  D0 FE                trap_ne
00045D  1  90 FE                trap_cc
00045F  1  30 FE                trap_mi
000461  1  C9 01                cmp #1
000463  1  F0 FE                trap_eq
000465  1  B0 FE                trap_cs
000467  1  10 FE                trap_pl
000469  1  AA                   tax
00046A  1  E0 00                cpx #0          ;test compare x immediate
00046C  1  D0 FE                trap_ne
00046E  1  90 FE                trap_cc
000470  1  30 FE                trap_mi
000472  1  E0 01                cpx #1
000474  1  F0 FE                trap_eq
000476  1  B0 FE                trap_cs
000478  1  10 FE                trap_pl
00047A  1  A8                   tay
00047B  1  C0 00                cpy #0          ;test compare y immediate
00047D  1  D0 FE                trap_ne
00047F  1  90 FE                trap_cc
000481  1  30 FE                trap_mi
000483  1  C0 01                cpy #1
000485  1  F0 FE                trap_eq
000487  1  B0 FE                trap_cs
000489  1  10 FE                trap_pl
00048B  1  AD 00 02 C9          next_test
00048F  1  02 D0 FE A9  
000493  1  03 8D 00 02  
000497  1               ;testing stack operations PHA PHP PLA PLP
000497  1               
000497  1  A2 FF                ldx #$ff        ;initialize stack
000499  1  9A                   txs
00049A  1  A9 55                lda #$55
00049C  1  48                   pha
00049D  1  A9 AA                lda #$aa
00049F  1  48                   pha
0004A0  1  CD FE 01             cmp $1fe        ;on stack ?
0004A3  1  D0 FE                trap_ne
0004A5  1  BA                   tsx
0004A6  1  8A                   txa             ;overwrite accu
0004A7  1  C9 FD                cmp #$fd        ;sp decremented?
0004A9  1  D0 FE                trap_ne
0004AB  1  68                   pla
0004AC  1  C9 AA                cmp #$aa        ;successful retreived from stack?
0004AE  1  D0 FE                trap_ne
0004B0  1  68                   pla
0004B1  1  C9 55                cmp #$55
0004B3  1  D0 FE                trap_ne
0004B5  1  CD FF 01             cmp $1ff        ;remains on stack?
0004B8  1  D0 FE                trap_ne
0004BA  1  BA                   tsx
0004BB  1  E0 FF                cpx #$ff        ;sp incremented?
0004BD  1  D0 FE                trap_ne
0004BF  1  AD 00 02 C9          next_test
0004C3  1  03 D0 FE A9  
0004C7  1  04 8D 00 02  
0004CB  1               
0004CB  1               ;testing branch decisions BPL BMI BVC BVS BCC BCS BNE BEQ
0004CB  1  A9 FF 48 28          set_stat $ff    ;all on
0004CF  1  10 1A                bpl nbr1        ;branches should not be taken
0004D1  1  50 1B                bvc nbr2
0004D3  1  90 1C                bcc nbr3
0004D5  1  D0 1D                bne nbr4
0004D7  1  30 03                bmi br1         ;branches should be taken
0004D9  1  4C D9 04             trap
0004DC  1  70 03        br1:    bvs br2
0004DE  1  4C DE 04             trap
0004E1  1  B0 03        br2:    bcs br3
0004E3  1  4C E3 04             trap
0004E6  1  F0 0F        br3:    beq br4
0004E8  1  4C E8 04             trap
0004EB  1               nbr1:
0004EB  1  4C EB 04             trap            ;previous bpl taken
0004EE  1               nbr2:
0004EE  1  4C EE 04             trap            ;previous bvc taken
0004F1  1               nbr3:
0004F1  1  4C F1 04             trap            ;previous bcc taken
0004F4  1               nbr4:
0004F4  1  4C F4 04             trap            ;previous bne taken
0004F7  1  08           br4:    php
0004F8  1  BA                   tsx
0004F9  1  E0 FE                cpx #$fe        ;sp after php?
0004FB  1  D0 FE                trap_ne
0004FD  1  68                   pla
0004FE  1  C9 FF                cmp_flag $ff    ;returned all flags on?
000500  1  D0 FE                trap_ne
000502  1  BA                   tsx
000503  1  E0 FF                cpx #$ff        ;sp after php?
000505  1  D0 FE                trap_ne
000507  1  A9 00 48 28          set_stat 0      ;all off
00050B  1  30 1A                bmi nbr11       ;branches should not be taken
00050D  1  70 1B                bvs nbr12
00050F  1  B0 1C                bcs nbr13
000511  1  F0 1D                beq nbr14
000513  1  10 03                bpl br11        ;branches should be taken
000515  1  4C 15 05             trap
000518  1  50 03        br11:   bvc br12
00051A  1  4C 1A 05             trap
00051D  1  90 03        br12:   bcc br13
00051F  1  4C 1F 05             trap
000522  1  D0 0F        br13:   bne br14
000524  1  4C 24 05             trap
000527  1               nbr11:
000527  1  4C 27 05             trap            ;previous bmi taken
00052A  1               nbr12:
00052A  1  4C 2A 05             trap            ;previous bvs taken
00052D  1               nbr13:
00052D  1  4C 2D 05             trap            ;previous bcs taken
000530  1               nbr14:
000530  1  4C 30 05             trap            ;previous beq taken
000533  1  08           br14:   php
000534  1  68                   pla
000535  1  C9 30                cmp_flag 0      ;flags off except break (pushed by sw) + reserved?
000537  1  D0 FE                trap_ne
000539  1                       ;crosscheck flags
000539  1  A9 02 48 28          set_stat zero
00053D  1  D0 02                bne brzs1
00053F  1  F0 03                beq brzs2
000541  1               brzs1:
000541  1  4C 41 05             trap            ;branch zero/non zero
000544  1  B0 02        brzs2:  bcs brzs3
000546  1  90 03                bcc brzs4
000548  1               brzs3:
000548  1  4C 48 05             trap            ;branch carry/no carry
00054B  1  30 02        brzs4:  bmi brzs5
00054D  1  10 03                bpl brzs6
00054F  1               brzs5:
00054F  1  4C 4F 05             trap            ;branch minus/plus
000552  1  70 02        brzs6:  bvs brzs7
000554  1  50 03                bvc brzs8
000556  1               brzs7:
000556  1  4C 56 05             trap            ;branch overflow/no overflow
000559  1               brzs8:
000559  1  A9 01 48 28          set_stat carry
00055D  1  F0 02                beq brcs1
00055F  1  D0 03                bne brcs2
000561  1               brcs1:
000561  1  4C 61 05             trap            ;branch zero/non zero
000564  1  90 02        brcs2:  bcc brcs3
000566  1  B0 03                bcs brcs4
000568  1               brcs3:
000568  1  4C 68 05             trap            ;branch carry/no carry
00056B  1  30 02        brcs4:  bmi brcs5
00056D  1  10 03                bpl brcs6
00056F  1               brcs5:
00056F  1  4C 6F 05             trap            ;branch minus/plus
000572  1  70 02        brcs6:  bvs brcs7
000574  1  50 03                bvc brcs8
000576  1               brcs7:
000576  1  4C 76 05             trap            ;branch overflow/no overflow
000579  1               
000579  1               brcs8:
000579  1  A9 80 48 28          set_stat minus
00057D  1  F0 02                beq brmi1
00057F  1  D0 03                bne brmi2
000581  1               brmi1:
000581  1  4C 81 05             trap            ;branch zero/non zero
000584  1  B0 02        brmi2:  bcs brmi3
000586  1  90 03                bcc brmi4
000588  1               brmi3:
000588  1  4C 88 05             trap            ;branch carry/no carry
00058B  1  10 02        brmi4:  bpl brmi5
00058D  1  30 03                bmi brmi6
00058F  1               brmi5:
00058F  1  4C 8F 05             trap            ;branch minus/plus
000592  1  70 02        brmi6:  bvs brmi7
000594  1  50 03                bvc brmi8
000596  1               brmi7:
000596  1  4C 96 05             trap            ;branch overflow/no overflow
000599  1               brmi8:
000599  1  A9 40 48 28          set_stat overfl
00059D  1  F0 02                beq brvs1
00059F  1  D0 03                bne brvs2
0005A1  1               brvs1:
0005A1  1  4C A1 05             trap            ;branch zero/non zero
0005A4  1  B0 02        brvs2:  bcs brvs3
0005A6  1  90 03                bcc brvs4
0005A8  1               brvs3:
0005A8  1  4C A8 05             trap            ;branch carry/no carry
0005AB  1  30 02        brvs4:  bmi brvs5
0005AD  1  10 03                bpl brvs6
0005AF  1               brvs5:
0005AF  1  4C AF 05             trap            ;branch minus/plus
0005B2  1  50 02        brvs6:  bvc brvs7
0005B4  1  70 03                bvs brvs8
0005B6  1               brvs7:
0005B6  1  4C B6 05             trap            ;branch overflow/no overflow
0005B9  1               brvs8:
0005B9  1  A9 FD 48 28          set_stat $ff-zero
0005BD  1  F0 02                beq brzc1
0005BF  1  D0 03                bne brzc2
0005C1  1               brzc1:
0005C1  1  4C C1 05             trap            ;branch zero/non zero
0005C4  1  90 02        brzc2:  bcc brzc3
0005C6  1  B0 03                bcs brzc4
0005C8  1               brzc3:
0005C8  1  4C C8 05             trap            ;branch carry/no carry
0005CB  1  10 02        brzc4:  bpl brzc5
0005CD  1  30 03                bmi brzc6
0005CF  1               brzc5:
0005CF  1  4C CF 05             trap            ;branch minus/plus
0005D2  1  50 02        brzc6:  bvc brzc7
0005D4  1  70 03                bvs brzc8
0005D6  1               brzc7:
0005D6  1  4C D6 05             trap            ;branch overflow/no overflow
0005D9  1               brzc8:
0005D9  1  A9 FE 48 28          set_stat $ff-carry
0005DD  1  D0 02                bne brcc1
0005DF  1  F0 03                beq brcc2
0005E1  1               brcc1:
0005E1  1  4C E1 05             trap            ;branch zero/non zero
0005E4  1  B0 02        brcc2:  bcs brcc3
0005E6  1  90 03                bcc brcc4
0005E8  1               brcc3:
0005E8  1  4C E8 05             trap            ;branch carry/no carry
0005EB  1  10 02        brcc4:  bpl brcc5
0005ED  1  30 03                bmi brcc6
0005EF  1               brcc5:
0005EF  1  4C EF 05             trap            ;branch minus/plus
0005F2  1  50 02        brcc6:  bvc brcc7
0005F4  1  70 03                bvs brcc8
0005F6  1               brcc7:
0005F6  1  4C F6 05             trap            ;branch overflow/no overflow
0005F9  1               brcc8:
0005F9  1  A9 7F 48 28          set_stat $ff-minus
0005FD  1  D0 02                bne brpl1
0005FF  1  F0 03                beq brpl2
000601  1               brpl1:
000601  1  4C 01 06             trap            ;branch zero/non zero
000604  1  90 02        brpl2:  bcc brpl3
000606  1  B0 03                bcs brpl4
000608  1               brpl3:
000608  1  4C 08 06             trap            ;branch carry/no carry
00060B  1  30 02        brpl4:  bmi brpl5
00060D  1  10 03                bpl brpl6
00060F  1               brpl5:
00060F  1  4C 0F 06             trap            ;branch minus/plus
000612  1  50 02        brpl6:  bvc brpl7
000614  1  70 03                bvs brpl8
000616  1               brpl7:
000616  1  4C 16 06             trap            ;branch overflow/no overflow
000619  1               brpl8:
000619  1  A9 BF 48 28          set_stat $ff-overfl
00061D  1  D0 02                bne brvc1
00061F  1  F0 03                beq brvc2
000621  1               brvc1:
000621  1  4C 21 06             trap            ;branch zero/non zero
000624  1  90 02        brvc2:  bcc brvc3
000626  1  B0 03                bcs brvc4
000628  1               brvc3:
000628  1  4C 28 06             trap            ;branch carry/no carry
00062B  1  10 02        brvc4:  bpl brvc5
00062D  1  30 03                bmi brvc6
00062F  1               brvc5:
00062F  1  4C 2F 06             trap            ;branch minus/plus
000632  1  70 02        brvc6:  bvs brvc7
000634  1  50 03                bvc brvc8
000636  1               brvc7:
000636  1  4C 36 06             trap            ;branch overflow/no overflow
000639  1               brvc8:
000639  1  AD 00 02 C9          next_test
00063D  1  04 D0 FE A9  
000641  1  05 8D 00 02  
000645  1               
000645  1               ; test PHA does not alter flags or accumulator but PLA does
000645  1  A2 55                ldx #$55        ;x & y protected
000647  1  A0 AA                ldy #$aa
000649  1  A9 FF 48 A9          set_a 1,$ff     ;push
00064D  1  01 28        
00064F  1  48                   pha
000650  1  08 C9 01 D0          tst_a 1,$ff
000654  1  FE 68 48 C9  
000658  1  FF D0 FE 28  
00065C  1  A9 00 48 A9          set_a 0,0
000660  1  00 28        
000662  1  48                   pha
000663  1  08 C9 00 D0          tst_a 0,0
000667  1  FE 68 48 C9  
00066B  1  30 D0 FE 28  
00066F  1  A9 FF 48 A9          set_a $ff,$ff
000673  1  FF 28        
000675  1  48                   pha
000676  1  08 C9 FF D0          tst_a $ff,$ff
00067A  1  FE 68 48 C9  
00067E  1  FF D0 FE 28  
000682  1  A9 00 48 A9          set_a 1,0
000686  1  01 28        
000688  1  48                   pha
000689  1  08 C9 01 D0          tst_a 1,0
00068D  1  FE 68 48 C9  
000691  1  30 D0 FE 28  
000695  1  A9 FF 48 A9          set_a 0,$ff
000699  1  00 28        
00069B  1  48                   pha
00069C  1  08 C9 00 D0          tst_a 0,$ff
0006A0  1  FE 68 48 C9  
0006A4  1  FF D0 FE 28  
0006A8  1  A9 00 48 A9          set_a $ff,0
0006AC  1  FF 28        
0006AE  1  48                   pha
0006AF  1  08 C9 FF D0          tst_a $ff,0
0006B3  1  FE 68 48 C9  
0006B7  1  30 D0 FE 28  
0006BB  1  A9 FF 48 A9          set_a 0,$ff     ;pull
0006BF  1  00 28        
0006C1  1  68                   pla
0006C2  1  08 C9 FF D0          tst_a $ff,$ff-zero
0006C6  1  FE 68 48 C9  
0006CA  1  FD D0 FE 28  
0006CE  1  A9 00 48 A9          set_a $ff,0
0006D2  1  FF 28        
0006D4  1  68                   pla
0006D5  1  08 C9 00 D0          tst_a 0,zero
0006D9  1  FE 68 48 C9  
0006DD  1  32 D0 FE 28  
0006E1  1  A9 FF 48 A9          set_a $fe,$ff
0006E5  1  FE 28        
0006E7  1  68                   pla
0006E8  1  08 C9 01 D0          tst_a 1,$ff-zero-minus
0006EC  1  FE 68 48 C9  
0006F0  1  7D D0 FE 28  
0006F4  1  A9 00 48 A9          set_a 0,0
0006F8  1  00 28        
0006FA  1  68                   pla
0006FB  1  08 C9 FF D0          tst_a $ff,minus
0006FF  1  FE 68 48 C9  
000703  1  B0 D0 FE 28  
000707  1  A9 FF 48 A9          set_a $ff,$ff
00070B  1  FF 28        
00070D  1  68                   pla
00070E  1  08 C9 00 D0          tst_a 0,$ff-minus
000712  1  FE 68 48 C9  
000716  1  7F D0 FE 28  
00071A  1  A9 00 48 A9          set_a $fe,0
00071E  1  FE 28        
000720  1  68                   pla
000721  1  08 C9 01 D0          tst_a 1,0
000725  1  FE 68 48 C9  
000729  1  30 D0 FE 28  
00072D  1  E0 55                cpx #$55        ;x & y unchanged?
00072F  1  D0 FE                trap_ne
000731  1  C0 AA                cpy #$aa
000733  1  D0 FE                trap_ne
000735  1  AD 00 02 C9          next_test
000739  1  05 D0 FE A9  
00073D  1  06 8D 00 02  
000741  1               
000741  1               ; partial pretest EOR #
000741  1  A9 00 48 A9          set_a $3c,0
000745  1  3C 28        
000747  1  49 C3                eor #$c3
000749  1  08 C9 FF D0          tst_a $ff,fn
00074D  1  FE 68 48 C9  
000751  1  B0 D0 FE 28  
000755  1  A9 00 48 A9          set_a $c3,0
000759  1  C3 28        
00075B  1  49 C3                eor #$c3
00075D  1  08 C9 00 D0          tst_a 0,fz
000761  1  FE 68 48 C9  
000765  1  32 D0 FE 28  
000769  1  AD 00 02 C9          next_test
00076D  1  06 D0 FE A9  
000771  1  07 8D 00 02  
000775  1               
000775  1               ; PC modifying instructions except branches (NOP, JMP, JSR, RTS, BRK, RTI)
000775  1               ; testing NOP
000775  1  A2 24                ldx #$24
000777  1  A0 42                ldy #$42
000779  1  A9 00 48 A9          set_a $18,0
00077D  1  18 28        
00077F  1  EA                   nop
000780  1  08 C9 18 D0          tst_a $18,0
000784  1  FE 68 48 C9  
000788  1  30 D0 FE 28  
00078C  1  E0 24                cpx #$24
00078E  1  D0 FE                trap_ne
000790  1  C0 42                cpy #$42
000792  1  D0 FE                trap_ne
000794  1  A2 DB                ldx #$db
000796  1  A0 BD                ldy #$bd
000798  1  A9 FF 48 A9          set_a $e7,$ff
00079C  1  E7 28        
00079E  1  EA                   nop
00079F  1  08 C9 E7 D0          tst_a $e7,$ff
0007A3  1  FE 68 48 C9  
0007A7  1  FF D0 FE 28  
0007AB  1  E0 DB                cpx #$db
0007AD  1  D0 FE                trap_ne
0007AF  1  C0 BD                cpy #$bd
0007B1  1  D0 FE                trap_ne
0007B3  1  AD 00 02 C9          next_test
0007B7  1  07 D0 FE A9  
0007BB  1  08 8D 00 02  
0007BF  1               
0007BF  1               ; jump absolute
0007BF  1  A9 00 48 28          set_stat $0
0007C3  1  A9 46                lda #'F'
0007C5  1  A2 41                ldx #'A'
0007C7  1  A0 52                ldy #'R'        ;N=0, V=0, Z=0, C=0
0007C9  1  4C B2 35             jmp test_far
0007CC  1  EA                   nop
0007CD  1  EA                   nop
0007CE  1  D0 FE                trap_ne         ;runover protection
0007D0  1  E8                   inx
0007D1  1  E8                   inx
0007D2  1               far_ret:
0007D2  1  F0 FE                trap_eq         ;returned flags OK?
0007D4  1  10 FE                trap_pl
0007D6  1  90 FE                trap_cc
0007D8  1  50 FE                trap_vc
0007DA  1  C9 EC                cmp #('F'^$aa)  ;returned registers OK?
0007DC  1  D0 FE                trap_ne
0007DE  1  E0 42                cpx #('A'+1)
0007E0  1  D0 FE                trap_ne
0007E2  1  C0 4F                cpy #('R'-3)
0007E4  1  D0 FE                trap_ne
0007E6  1  CA                   dex
0007E7  1  C8                   iny
0007E8  1  C8                   iny
0007E9  1  C8                   iny
0007EA  1  49 AA                eor #$aa        ;N=0, V=1, Z=0, C=1
0007EC  1  4C F5 07             jmp test_near
0007EF  1  EA                   nop
0007F0  1  EA                   nop
0007F1  1  D0 FE                trap_ne         ;runover protection
0007F3  1  E8                   inx
0007F4  1  E8                   inx
0007F5  1               test_near:
0007F5  1  F0 FE                trap_eq         ;passed flags OK?
0007F7  1  30 FE                trap_mi
0007F9  1  90 FE                trap_cc
0007FB  1  50 FE                trap_vc
0007FD  1  C9 46                cmp #'F'        ;passed registers OK?
0007FF  1  D0 FE                trap_ne
000801  1  E0 41                cpx #'A'
000803  1  D0 FE                trap_ne
000805  1  C0 52                cpy #'R'
000807  1  D0 FE                trap_ne
000809  1  AD 00 02 C9          next_test
00080D  1  08 D0 FE A9  
000811  1  09 8D 00 02  
000815  1               
000815  1               ; jump indirect
000815  1  A9 00 48 28          set_stat 0
000819  1  A9 49                lda #'I'
00081B  1  A2 4E                ldx #'N'
00081D  1  A0 44                ldy #'D'        ;N=0, V=0, Z=0, C=0
00081F  1  6C E0 35             jmp (ptr_tst_ind)
000822  1  EA                   nop
000823  1  D0 FE                trap_ne         ;runover protection
000825  1  88                   dey
000826  1  88                   dey
000827  1               ind_ret:
000827  1  08                   php             ;either SP or Y count will fail, if we do not hit
000828  1  88                   dey
000829  1  88                   dey
00082A  1  88                   dey
00082B  1  28                   plp
00082C  1  F0 FE                trap_eq         ;returned flags OK?
00082E  1  10 FE                trap_pl
000830  1  90 FE                trap_cc
000832  1  50 FE                trap_vc
000834  1  C9 E3                cmp #('I'^$aa)  ;returned registers OK?
000836  1  D0 FE                trap_ne
000838  1  E0 4F                cpx #('N'+1)
00083A  1  D0 FE                trap_ne
00083C  1  C0 3E                cpy #('D'-6)
00083E  1  D0 FE                trap_ne
000840  1  BA                   tsx             ;SP check
000841  1  E0 FF                cpx #$ff
000843  1  D0 FE                trap_ne
000845  1  AD 00 02 C9          next_test
000849  1  09 D0 FE A9  
00084D  1  0A 8D 00 02  
000851  1               
000851  1               ; jump subroutine & return from subroutine
000851  1  A9 00 48 28          set_stat 0
000855  1  A9 4A                lda #'J'
000857  1  A2 53                ldx #'S'
000859  1  A0 52                ldy #'R'        ;N=0, V=0, Z=0, C=0
00085B  1  20 1F 36             jsr test_jsr
00085E  1               jsr_ret = *-1           ;last address of jsr = return address
00085E  1  08                   php             ;either SP or Y count will fail, if we do not hit
00085F  1  88                   dey
000860  1  88                   dey
000861  1  88                   dey
000862  1  28                   plp
000863  1  F0 FE                trap_eq         ;returned flags OK?
000865  1  10 FE                trap_pl
000867  1  90 FE                trap_cc
000869  1  50 FE                trap_vc
00086B  1  C9 E0                cmp #('J'^$aa)  ;returned registers OK?
00086D  1  D0 FE                trap_ne
00086F  1  E0 54                cpx #('S'+1)
000871  1  D0 FE                trap_ne
000873  1  C0 4C                cpy #('R'-6)
000875  1  D0 FE                trap_ne
000877  1  BA                   tsx             ;sp?
000878  1  E0 FF                cpx #$ff
00087A  1  D0 FE                trap_ne
00087C  1  AD 00 02 C9          next_test
000880  1  0A D0 FE A9  
000884  1  0B 8D 00 02  
000888  1               
000888  1               ; break & return from interrupt
000888  1                   .if ROM_vectors = 1
000888  1  A9 00                load_flag 0     ;with interrupts enabled if allowed!
00088A  1  48                   pha
00088B  1  A9 42                lda #'B'
00088D  1  A2 52                ldx #'R'
00088F  1  A0 4B                ldy #'K'
000891  1  28                   plp             ;N=0, V=0, Z=0, C=0
000892  1  00                   brk
000893  1                   .else
000893  1                       lda #>brk_ret0 ;emulated break
000893  1                       pha
000893  1                       lda #<brk_ret0
000893  1                       pha
000893  1                       load_flag fao    ;set break & unused on stack
000893  1                       pha
000893  1                       load_flag intdis ;during interrupt
000893  1                       pha
000893  1                       lda #'B'
000893  1                       ldx #'R'
000893  1                       ldy #'K'
000893  1                       plp             ;N=0, V=0, Z=0, C=0
000893  1                       jmp irq_trap
000893  1                   .endif
000893  1  88                   dey             ;should not be executed
000894  1               brk_ret0:               ;address of break return
000894  1  08                   php             ;either SP or Y count will fail, if we do not hit
000895  1  88                   dey
000896  1  88                   dey
000897  1  88                   dey
000898  1  C9 E8                cmp #'B'^$aa    ;returned registers OK?
00089A  1                       ;the IRQ vector was never executed if A & X stay unmodified
00089A  1  D0 FE                trap_ne
00089C  1  E0 53                cpx #'R'+1
00089E  1  D0 FE                trap_ne
0008A0  1  C0 45                cpy #'K'-6
0008A2  1  D0 FE                trap_ne
0008A4  1  68                   pla             ;returned flags OK (unchanged)?
0008A5  1  C9 30                cmp_flag 0
0008A7  1  D0 FE                trap_ne
0008A9  1  BA                   tsx             ;sp?
0008AA  1  E0 FF                cpx #$ff
0008AC  1  D0 FE                trap_ne
0008AE  1                   .if ROM_vectors = 1
0008AE  1  A9 FF                load_flag $ff   ;with interrupts disabled if allowed!
0008B0  1  48                   pha
0008B1  1  A9 BD                lda #$ff-'B'
0008B3  1  A2 AD                ldx #$ff-'R'
0008B5  1  A0 B4                ldy #$ff-'K'
0008B7  1  28                   plp             ;N=1, V=1, Z=1, C=1
0008B8  1  00                   brk
0008B9  1                   .else
0008B9  1                       lda #>brk_ret1 ;emulated break
0008B9  1                       pha
0008B9  1                       lda #<brk_ret1
0008B9  1                       pha
0008B9  1                       load_flag $ff
0008B9  1                       pha             ;set break & unused on stack
0008B9  1                       pha             ;actual flags
0008B9  1                       lda #$ff-'B'
0008B9  1                       ldx #$ff-'R'
0008B9  1                       ldy #$ff-'K'
0008B9  1                       plp             ;N=1, V=1, Z=1, C=1
0008B9  1                       jmp irq_trap
0008B9  1                   .endif
0008B9  1  88                   dey             ;should not be executed
0008BA  1               brk_ret1:               ;address of break return
0008BA  1  08                   php             ;either SP or Y count will fail, if we do not hit
0008BB  1  88                   dey
0008BC  1  88                   dey
0008BD  1  88                   dey
0008BE  1  C9 17                cmp #($ff-'B')^$aa  ;returned registers OK?
0008C0  1                       ;the IRQ vector was never executed if A & X stay unmodified
0008C0  1  D0 FE                trap_ne
0008C2  1  E0 AE                cpx #$ff-'R'+1
0008C4  1  D0 FE                trap_ne
0008C6  1  C0 AE                cpy #$ff-'K'-6
0008C8  1  D0 FE                trap_ne
0008CA  1  68                   pla             ;returned flags OK (unchanged)?
0008CB  1  C9 FF                cmp_flag $ff
0008CD  1  D0 FE                trap_ne
0008CF  1  BA                   tsx             ;sp?
0008D0  1  E0 FF                cpx #$ff
0008D2  1  D0 FE                trap_ne
0008D4  1  AD 00 02 C9          next_test
0008D8  1  0B D0 FE A9  
0008DC  1  0C 8D 00 02  
0008E0  1               
0008E0  1               ; test set and clear flags CLC CLI CLD CLV SEC SEI SED
0008E0  1  A9 FF 48 28          set_stat $ff
0008E4  1  18                   clc
0008E5  1  08 68 48 C9          tst_stat $ff-carry
0008E9  1  FE D0 FE 28  
0008ED  1  38                   sec
0008EE  1  08 68 48 C9          tst_stat $ff
0008F2  1  FF D0 FE 28  
0008F6  1                   .if I_flag = 3
0008F6  1  58                   cli
0008F7  1  08 68 48 C9          tst_stat $ff-intdis
0008FB  1  FB D0 FE 28  
0008FF  1  78                   sei
000900  1  08 68 48 C9          tst_stat $ff
000904  1  FF D0 FE 28  
000908  1                   .endif
000908  1  D8                   cld
000909  1  08 68 48 C9          tst_stat $ff-decmode
00090D  1  F7 D0 FE 28  
000911  1  F8                   sed
000912  1  08 68 48 C9          tst_stat $ff
000916  1  FF D0 FE 28  
00091A  1  B8                   clv
00091B  1  08 68 48 C9          tst_stat $ff-overfl
00091F  1  BF D0 FE 28  
000923  1  A9 00 48 28          set_stat 0
000927  1  08 68 48 C9          tst_stat 0
00092B  1  30 D0 FE 28  
00092F  1  38                   sec
000930  1  08 68 48 C9          tst_stat carry
000934  1  31 D0 FE 28  
000938  1  18                   clc
000939  1  08 68 48 C9          tst_stat 0
00093D  1  30 D0 FE 28  
000941  1                   .if I_flag = 3
000941  1  78                   sei
000942  1  08 68 48 C9          tst_stat intdis
000946  1  34 D0 FE 28  
00094A  1  58                   cli
00094B  1  08 68 48 C9          tst_stat 0
00094F  1  30 D0 FE 28  
000953  1                   .endif
000953  1  F8                   sed
000954  1  08 68 48 C9          tst_stat decmode
000958  1  38 D0 FE 28  
00095C  1  D8                   cld
00095D  1  08 68 48 C9          tst_stat 0
000961  1  30 D0 FE 28  
000965  1  A9 40 48 28          set_stat overfl
000969  1  08 68 48 C9          tst_stat overfl
00096D  1  70 D0 FE 28  
000971  1  B8                   clv
000972  1  08 68 48 C9          tst_stat 0
000976  1  30 D0 FE 28  
00097A  1  AD 00 02 C9          next_test
00097E  1  0C D0 FE A9  
000982  1  0D 8D 00 02  
000986  1               ; testing index register increment/decrement and transfer
000986  1               ; INX INY DEX DEY TAX TXA TAY TYA
000986  1  A2 FE                ldx #$fe
000988  1  A9 FF 48 28          set_stat $ff
00098C  1  E8                   inx             ;ff
00098D  1  08 E0 FF D0          tst_x $ff,$ff-zero
000991  1  FE 68 48 C9  
000995  1  FD D0 FE 28  
000999  1  E8                   inx             ;00
00099A  1  08 E0 00 D0          tst_x 0,$ff-minus
00099E  1  FE 68 48 C9  
0009A2  1  7F D0 FE 28  
0009A6  1  E8                   inx             ;01
0009A7  1  08 E0 01 D0          tst_x 1,$ff-minus-zero
0009AB  1  FE 68 48 C9  
0009AF  1  7D D0 FE 28  
0009B3  1  CA                   dex             ;00
0009B4  1  08 E0 00 D0          tst_x 0,$ff-minus
0009B8  1  FE 68 48 C9  
0009BC  1  7F D0 FE 28  
0009C0  1  CA                   dex             ;ff
0009C1  1  08 E0 FF D0          tst_x $ff,$ff-zero
0009C5  1  FE 68 48 C9  
0009C9  1  FD D0 FE 28  
0009CD  1  CA                   dex             ;fe
0009CE  1  A9 00 48 28          set_stat 0
0009D2  1  E8                   inx             ;ff
0009D3  1  08 E0 FF D0          tst_x $ff,minus
0009D7  1  FE 68 48 C9  
0009DB  1  B0 D0 FE 28  
0009DF  1  E8                   inx             ;00
0009E0  1  08 E0 00 D0          tst_x 0,zero
0009E4  1  FE 68 48 C9  
0009E8  1  32 D0 FE 28  
0009EC  1  E8                   inx             ;01
0009ED  1  08 E0 01 D0          tst_x 1,0
0009F1  1  FE 68 48 C9  
0009F5  1  30 D0 FE 28  
0009F9  1  CA                   dex             ;00
0009FA  1  08 E0 00 D0          tst_x 0,zero
0009FE  1  FE 68 48 C9  
000A02  1  32 D0 FE 28  
000A06  1  CA                   dex             ;ff
000A07  1  08 E0 FF D0          tst_x $ff,minus
000A0B  1  FE 68 48 C9  
000A0F  1  B0 D0 FE 28  
000A13  1               
000A13  1  A0 FE                ldy #$fe
000A15  1  A9 FF 48 28          set_stat $ff
000A19  1  C8                   iny             ;ff
000A1A  1  08 C0 FF D0          tst_y $ff,$ff-zero
000A1E  1  FE 68 48 C9  
000A22  1  FD D0 FE 28  
000A26  1  C8                   iny             ;00
000A27  1  08 C0 00 D0          tst_y 0,$ff-minus
000A2B  1  FE 68 48 C9  
000A2F  1  7F D0 FE 28  
000A33  1  C8                   iny             ;01
000A34  1  08 C0 01 D0          tst_y 1,$ff-minus-zero
000A38  1  FE 68 48 C9  
000A3C  1  7D D0 FE 28  
000A40  1  88                   dey             ;00
000A41  1  08 C0 00 D0          tst_y 0,$ff-minus
000A45  1  FE 68 48 C9  
000A49  1  7F D0 FE 28  
000A4D  1  88                   dey             ;ff
000A4E  1  08 C0 FF D0          tst_y $ff,$ff-zero
000A52  1  FE 68 48 C9  
000A56  1  FD D0 FE 28  
000A5A  1  88                   dey             ;fe
000A5B  1  A9 00 48 28          set_stat 0
000A5F  1  C8                   iny             ;ff
000A60  1  08 C0 FF D0          tst_y $ff,0+minus
000A64  1  FE 68 48 C9  
000A68  1  B0 D0 FE 28  
000A6C  1  C8                   iny             ;00
000A6D  1  08 C0 00 D0          tst_y 0,zero
000A71  1  FE 68 48 C9  
000A75  1  32 D0 FE 28  
000A79  1  C8                   iny             ;01
000A7A  1  08 C0 01 D0          tst_y 1,0
000A7E  1  FE 68 48 C9  
000A82  1  30 D0 FE 28  
000A86  1  88                   dey             ;00
000A87  1  08 C0 00 D0          tst_y 0,zero
000A8B  1  FE 68 48 C9  
000A8F  1  32 D0 FE 28  
000A93  1  88                   dey             ;ff
000A94  1  08 C0 FF D0          tst_y $ff,minus
000A98  1  FE 68 48 C9  
000A9C  1  B0 D0 FE 28  
000AA0  1               
000AA0  1  A2 FF                ldx #$ff
000AA2  1  A9 FF 48 28          set_stat $ff
000AA6  1  8A                   txa
000AA7  1  08 C9 FF D0          tst_a $ff,$ff-zero
000AAB  1  FE 68 48 C9  
000AAF  1  FD D0 FE 28  
000AB3  1  08                   php
000AB4  1  E8                   inx             ;00
000AB5  1  28                   plp
000AB6  1  8A                   txa
000AB7  1  08 C9 00 D0          tst_a 0,$ff-minus
000ABB  1  FE 68 48 C9  
000ABF  1  7F D0 FE 28  
000AC3  1  08                   php
000AC4  1  E8                   inx             ;01
000AC5  1  28                   plp
000AC6  1  8A                   txa
000AC7  1  08 C9 01 D0          tst_a 1,$ff-minus-zero
000ACB  1  FE 68 48 C9  
000ACF  1  7D D0 FE 28  
000AD3  1  A9 00 48 28          set_stat 0
000AD7  1  8A                   txa
000AD8  1  08 C9 01 D0          tst_a 1,0
000ADC  1  FE 68 48 C9  
000AE0  1  30 D0 FE 28  
000AE4  1  08                   php
000AE5  1  CA                   dex             ;00
000AE6  1  28                   plp
000AE7  1  8A                   txa
000AE8  1  08 C9 00 D0          tst_a 0,zero
000AEC  1  FE 68 48 C9  
000AF0  1  32 D0 FE 28  
000AF4  1  08                   php
000AF5  1  CA                   dex             ;ff
000AF6  1  28                   plp
000AF7  1  8A                   txa
000AF8  1  08 C9 FF D0          tst_a $ff,minus
000AFC  1  FE 68 48 C9  
000B00  1  B0 D0 FE 28  
000B04  1               
000B04  1  A0 FF                ldy #$ff
000B06  1  A9 FF 48 28          set_stat $ff
000B0A  1  98                   tya
000B0B  1  08 C9 FF D0          tst_a $ff,$ff-zero
000B0F  1  FE 68 48 C9  
000B13  1  FD D0 FE 28  
000B17  1  08                   php
000B18  1  C8                   iny             ;00
000B19  1  28                   plp
000B1A  1  98                   tya
000B1B  1  08 C9 00 D0          tst_a 0,$ff-minus
000B1F  1  FE 68 48 C9  
000B23  1  7F D0 FE 28  
000B27  1  08                   php
000B28  1  C8                   iny             ;01
000B29  1  28                   plp
000B2A  1  98                   tya
000B2B  1  08 C9 01 D0          tst_a 1,$ff-minus-zero
000B2F  1  FE 68 48 C9  
000B33  1  7D D0 FE 28  
000B37  1  A9 00 48 28          set_stat 0
000B3B  1  98                   tya
000B3C  1  08 C9 01 D0          tst_a 1,0
000B40  1  FE 68 48 C9  
000B44  1  30 D0 FE 28  
000B48  1  08                   php
000B49  1  88                   dey             ;00
000B4A  1  28                   plp
000B4B  1  98                   tya
000B4C  1  08 C9 00 D0          tst_a 0,zero
000B50  1  FE 68 48 C9  
000B54  1  32 D0 FE 28  
000B58  1  08                   php
000B59  1  88                   dey             ;ff
000B5A  1  28                   plp
000B5B  1  98                   tya
000B5C  1  08 C9 FF D0          tst_a $ff,minus
000B60  1  FE 68 48 C9  
000B64  1  B0 D0 FE 28  
000B68  1               
000B68  1  A9 FF                load_flag $ff
000B6A  1  48                   pha
000B6B  1  A2 FF                ldx #$ff        ;ff
000B6D  1  8A                   txa
000B6E  1  28                   plp
000B6F  1  A8                   tay
000B70  1  08 C0 FF D0          tst_y $ff,$ff-zero
000B74  1  FE 68 48 C9  
000B78  1  FD D0 FE 28  
000B7C  1  08                   php
000B7D  1  E8                   inx             ;00
000B7E  1  8A                   txa
000B7F  1  28                   plp
000B80  1  A8                   tay
000B81  1  08 C0 00 D0          tst_y 0,$ff-minus
000B85  1  FE 68 48 C9  
000B89  1  7F D0 FE 28  
000B8D  1  08                   php
000B8E  1  E8                   inx             ;01
000B8F  1  8A                   txa
000B90  1  28                   plp
000B91  1  A8                   tay
000B92  1  08 C0 01 D0          tst_y 1,$ff-minus-zero
000B96  1  FE 68 48 C9  
000B9A  1  7D D0 FE 28  
000B9E  1  A9 00                load_flag 0
000BA0  1  48                   pha
000BA1  1  A9 00                lda #0
000BA3  1  8A                   txa
000BA4  1  28                   plp
000BA5  1  A8                   tay
000BA6  1  08 C0 01 D0          tst_y 1,0
000BAA  1  FE 68 48 C9  
000BAE  1  30 D0 FE 28  
000BB2  1  08                   php
000BB3  1  CA                   dex             ;00
000BB4  1  8A                   txa
000BB5  1  28                   plp
000BB6  1  A8                   tay
000BB7  1  08 C0 00 D0          tst_y 0,zero
000BBB  1  FE 68 48 C9  
000BBF  1  32 D0 FE 28  
000BC3  1  08                   php
000BC4  1  CA                   dex             ;ff
000BC5  1  8A                   txa
000BC6  1  28                   plp
000BC7  1  A8                   tay
000BC8  1  08 C0 FF D0          tst_y $ff,minus
000BCC  1  FE 68 48 C9  
000BD0  1  B0 D0 FE 28  
000BD4  1               
000BD4  1               
000BD4  1  A9 FF                load_flag $ff
000BD6  1  48                   pha
000BD7  1  A0 FF                ldy #$ff        ;ff
000BD9  1  98                   tya
000BDA  1  28                   plp
000BDB  1  AA                   tax
000BDC  1  08 E0 FF D0          tst_x $ff,$ff-zero
000BE0  1  FE 68 48 C9  
000BE4  1  FD D0 FE 28  
000BE8  1  08                   php
000BE9  1  C8                   iny             ;00
000BEA  1  98                   tya
000BEB  1  28                   plp
000BEC  1  AA                   tax
000BED  1  08 E0 00 D0          tst_x 0,$ff-minus
000BF1  1  FE 68 48 C9  
000BF5  1  7F D0 FE 28  
000BF9  1  08                   php
000BFA  1  C8                   iny             ;01
000BFB  1  98                   tya
000BFC  1  28                   plp
000BFD  1  AA                   tax
000BFE  1  08 E0 01 D0          tst_x 1,$ff-minus-zero
000C02  1  FE 68 48 C9  
000C06  1  7D D0 FE 28  
000C0A  1  A9 00                load_flag 0
000C0C  1  48                   pha
000C0D  1  A9 00                lda #0          ;preset status
000C0F  1  98                   tya
000C10  1  28                   plp
000C11  1  AA                   tax
000C12  1  08 E0 01 D0          tst_x 1,0
000C16  1  FE 68 48 C9  
000C1A  1  30 D0 FE 28  
000C1E  1  08                   php
000C1F  1  88                   dey             ;00
000C20  1  98                   tya
000C21  1  28                   plp
000C22  1  AA                   tax
000C23  1  08 E0 00 D0          tst_x 0,zero
000C27  1  FE 68 48 C9  
000C2B  1  32 D0 FE 28  
000C2F  1  08                   php
000C30  1  88                   dey             ;ff
000C31  1  98                   tya
000C32  1  28                   plp
000C33  1  AA                   tax
000C34  1  08 E0 FF D0          tst_x $ff,minus
000C38  1  FE 68 48 C9  
000C3C  1  B0 D0 FE 28  
000C40  1  AD 00 02 C9          next_test
000C44  1  0D D0 FE A9  
000C48  1  0E 8D 00 02  
000C4C  1               
000C4C  1               ;TSX sets NZ - TXS does not
000C4C  1               ;  This section also tests for proper stack wrap around.
000C4C  1  A2 01                ldx #1          ;01
000C4E  1  A9 FF 48 28          set_stat $ff
000C52  1  9A                   txs
000C53  1  08                   php
000C54  1  AD 01 01             lda $101
000C57  1  C9 FF                cmp_flag $ff
000C59  1  D0 FE                trap_ne
000C5B  1  A9 00 48 28          set_stat 0
000C5F  1  9A                   txs
000C60  1  08                   php
000C61  1  AD 01 01             lda $101
000C64  1  C9 30                cmp_flag 0
000C66  1  D0 FE                trap_ne
000C68  1  CA                   dex             ;00
000C69  1  A9 FF 48 28          set_stat $ff
000C6D  1  9A                   txs
000C6E  1  08                   php
000C6F  1  AD 00 01             lda $100
000C72  1  C9 FF                cmp_flag $ff
000C74  1  D0 FE                trap_ne
000C76  1  A9 00 48 28          set_stat 0
000C7A  1  9A                   txs
000C7B  1  08                   php
000C7C  1  AD 00 01             lda $100
000C7F  1  C9 30                cmp_flag 0
000C81  1  D0 FE                trap_ne
000C83  1  CA                   dex             ;ff
000C84  1  A9 FF 48 28          set_stat $ff
000C88  1  9A                   txs
000C89  1  08                   php
000C8A  1  AD FF 01             lda $1ff
000C8D  1  C9 FF                cmp_flag $ff
000C8F  1  D0 FE                trap_ne
000C91  1  A9 00 48 28          set_stat 0
000C95  1  9A                   txs
000C96  1  08                   php
000C97  1  AD FF 01             lda $1ff
000C9A  1  C9 30                cmp_flag 0
000C9C  1               
000C9C  1  A2 01                ldx #1
000C9E  1  9A                   txs             ;sp=01
000C9F  1  A9 FF 48 28          set_stat $ff
000CA3  1  BA                   tsx             ;clears Z, N
000CA4  1  08                   php             ;sp=00
000CA5  1  E0 01                cpx #1
000CA7  1  D0 FE                trap_ne
000CA9  1  AD 01 01             lda $101
000CAC  1  C9 7D                cmp_flag $ff-minus-zero
000CAE  1  D0 FE                trap_ne
000CB0  1  A9 FF 48 28          set_stat $ff
000CB4  1  BA                   tsx             ;clears N, sets Z
000CB5  1  08                   php             ;sp=ff
000CB6  1  E0 00                cpx #0
000CB8  1  D0 FE                trap_ne
000CBA  1  AD 00 01             lda $100
000CBD  1  C9 7F                cmp_flag $ff-minus
000CBF  1  D0 FE                trap_ne
000CC1  1  A9 FF 48 28          set_stat $ff
000CC5  1  BA                   tsx             ;clears N, sets Z
000CC6  1  08                   php             ;sp=fe
000CC7  1  E0 FF                cpx #$ff
000CC9  1  D0 FE                trap_ne
000CCB  1  AD FF 01             lda $1ff
000CCE  1  C9 FD                cmp_flag $ff-zero
000CD0  1  D0 FE                trap_ne
000CD2  1               
000CD2  1  A2 01                ldx #1
000CD4  1  9A                   txs             ;sp=01
000CD5  1  A9 00 48 28          set_stat 0
000CD9  1  BA                   tsx             ;clears Z, N
000CDA  1  08                   php             ;sp=00
000CDB  1  E0 01                cpx #1
000CDD  1  D0 FE                trap_ne
000CDF  1  AD 01 01             lda $101
000CE2  1  C9 30                cmp_flag 0
000CE4  1  D0 FE                trap_ne
000CE6  1  A9 00 48 28          set_stat 0
000CEA  1  BA                   tsx             ;clears N, sets Z
000CEB  1  08                   php             ;sp=ff
000CEC  1  E0 00                cpx #0
000CEE  1  D0 FE                trap_ne
000CF0  1  AD 00 01             lda $100
000CF3  1  C9 32                cmp_flag zero
000CF5  1  D0 FE                trap_ne
000CF7  1  A9 00 48 28          set_stat 0
000CFB  1  BA                   tsx             ;clears N, sets Z
000CFC  1  08                   php             ;sp=fe
000CFD  1  E0 FF                cpx #$ff
000CFF  1  D0 FE                trap_ne
000D01  1  AD FF 01             lda $1ff
000D04  1  C9 B0                cmp_flag minus
000D06  1  D0 FE                trap_ne
000D08  1  68                   pla             ;sp=ff
000D09  1  AD 00 02 C9          next_test
000D0D  1  0E D0 FE A9  
000D11  1  0F 8D 00 02  
000D15  1               
000D15  1               ; testing index register load & store LDY LDX STY STX all addressing modes
000D15  1               ; LDX / STX - zp,y / abs,y
000D15  1  A0 03                ldy #3
000D17  1               tldx:
000D17  1  A9 00 48 28          set_stat 0
000D1B  1  B6 13                ldx zp1,y
000D1D  1  08                   php         ;test stores do not alter flags
000D1E  1  8A                   txa
000D1F  1  49 C3                eor #$c3
000D21  1  28                   plp
000D22  1  99 03 02             sta abst,y
000D25  1  08                   php         ;flags after load/store sequence
000D26  1  49 C3                eor #$c3
000D28  1  D9 17 02             cmp abs1,y  ;test result
000D2B  1  D0 FE                trap_ne
000D2D  1  68                   pla         ;load status
000D2E  1  49 30                eor_flag 0
000D30  1  D9 1C 02             cmp fLDx,y  ;test flags
000D33  1  D0 FE                trap_ne
000D35  1  88                   dey
000D36  1  10 DF                bpl tldx
000D38  1               
000D38  1  A0 03                ldy #3
000D3A  1               tldx1:
000D3A  1  A9 FF 48 28          set_stat $ff
000D3E  1  B6 13                ldx zp1,y
000D40  1  08                   php         ;test stores do not alter flags
000D41  1  8A                   txa
000D42  1  49 C3                eor #$c3
000D44  1  28                   plp
000D45  1  99 03 02             sta abst,y
000D48  1  08                   php         ;flags after load/store sequence
000D49  1  49 C3                eor #$c3
000D4B  1  D9 17 02             cmp abs1,y  ;test result
000D4E  1  D0 FE                trap_ne
000D50  1  68                   pla         ;load status
000D51  1  49 7D                eor_flag <~fnz ;mask bits not altered
000D53  1  D9 1C 02             cmp fLDx,y  ;test flags
000D56  1  D0 FE                trap_ne
000D58  1  88                   dey
000D59  1  10 DF                bpl tldx1
000D5B  1               
000D5B  1  A0 03                ldy #3
000D5D  1               tldx2:
000D5D  1  A9 00 48 28          set_stat 0
000D61  1  BE 17 02             ldx abs1,y
000D64  1  08                   php         ;test stores do not alter flags
000D65  1  8A                   txa
000D66  1  49 C3                eor #$c3
000D68  1  AA                   tax
000D69  1  28                   plp
000D6A  1  96 0C                stx zpt,y
000D6C  1  08                   php         ;flags after load/store sequence
000D6D  1  49 C3                eor #$c3
000D6F  1  D9 13 00             cmp zp1,y   ;test result
000D72  1  D0 FE                trap_ne
000D74  1  68                   pla         ;load status
000D75  1  49 30                eor_flag 0
000D77  1  D9 1C 02             cmp fLDx,y  ;test flags
000D7A  1  D0 FE                trap_ne
000D7C  1  88                   dey
000D7D  1  10 DE                bpl tldx2
000D7F  1               
000D7F  1  A0 03                ldy #3
000D81  1               tldx3:
000D81  1  A9 FF 48 28          set_stat $ff
000D85  1  BE 17 02             ldx abs1,y
000D88  1  08                   php         ;test stores do not alter flags
000D89  1  8A                   txa
000D8A  1  49 C3                eor #$c3
000D8C  1  AA                   tax
000D8D  1  28                   plp
000D8E  1  96 0C                stx zpt,y
000D90  1  08                   php         ;flags after load/store sequence
000D91  1  49 C3                eor #$c3
000D93  1  D9 13 00             cmp zp1,y   ;test result
000D96  1  D0 FE                trap_ne
000D98  1  68                   pla         ;load status
000D99  1  49 7D                eor_flag <~fnz ;mask bits not altered
000D9B  1  D9 1C 02             cmp fLDx,y  ;test flags
000D9E  1  D0 FE                trap_ne
000DA0  1  88                   dey
000DA1  1  10 DE                bpl tldx3
000DA3  1               
000DA3  1  A0 03                ldy #3      ;testing store result
000DA5  1  A2 00                ldx #0
000DA7  1  B9 0C 00     tstx:   lda zpt,y
000DAA  1  49 C3                eor #$c3
000DAC  1  D9 13 00             cmp zp1,y
000DAF  1  D0 FE                trap_ne     ;store to zp data
000DB1  1  96 0C                stx zpt,y   ;clear
000DB3  1  B9 03 02             lda abst,y
000DB6  1  49 C3                eor #$c3
000DB8  1  D9 17 02             cmp abs1,y
000DBB  1  D0 FE                trap_ne     ;store to abs data
000DBD  1  8A                   txa
000DBE  1  99 03 02             sta abst,y  ;clear
000DC1  1  88                   dey
000DC2  1  10 E3                bpl tstx
000DC4  1  AD 00 02 C9          next_test
000DC8  1  0F D0 FE A9  
000DCC  1  10 8D 00 02  
000DD0  1               
000DD0  1               ; indexed wraparound test (only zp should wrap)
000DD0  1  A0 FD                ldy #3+$fa
000DD2  1  B6 19        tldx4:  ldx <(zp1-$fa),y   ;wrap on indexed zp
000DD4  1  8A                   txa
000DD5  1  99 09 01             sta abst-$fa,y      ;no STX abs,y!
000DD8  1  88                   dey
000DD9  1  C0 FA                cpy #$fa
000DDB  1  B0 F5                bcs tldx4
000DDD  1  A0 FD                ldy #3+$fa
000DDF  1  BE 1D 01     tldx5:  ldx abs1-$fa,y      ;no wrap on indexed abs
000DE2  1  96 12                stx <(zpt-$fa),y
000DE4  1  88                   dey
000DE5  1  C0 FA                cpy #$fa
000DE7  1  B0 F6                bcs tldx5
000DE9  1  A0 03                ldy #3      ;testing wraparound result
000DEB  1  A2 00                ldx #0
000DED  1  B9 0C 00     tstx1:  lda zpt,y
000DF0  1  D9 13 00             cmp zp1,y
000DF3  1  D0 FE                trap_ne     ;store to zp data
000DF5  1  96 0C                stx zpt,y   ;clear
000DF7  1  B9 03 02             lda abst,y
000DFA  1  D9 17 02             cmp abs1,y
000DFD  1  D0 FE                trap_ne     ;store to abs data
000DFF  1  8A                   txa
000E00  1  99 03 02             sta abst,y  ;clear
000E03  1  88                   dey
000E04  1  10 E7                bpl tstx1
000E06  1  AD 00 02 C9          next_test
000E0A  1  10 D0 FE A9  
000E0E  1  11 8D 00 02  
000E12  1               
000E12  1               ; LDY / STY - zp,x / abs,x
000E12  1  A2 03                ldx #3
000E14  1               tldy:
000E14  1  A9 00 48 28          set_stat 0
000E18  1  B4 13                ldy zp1,x
000E1A  1  08                   php         ;test stores do not alter flags
000E1B  1  98                   tya
000E1C  1  49 C3                eor #$c3
000E1E  1  28                   plp
000E1F  1  9D 03 02             sta abst,x
000E22  1  08                   php         ;flags after load/store sequence
000E23  1  49 C3                eor #$c3
000E25  1  DD 17 02             cmp abs1,x  ;test result
000E28  1  D0 FE                trap_ne
000E2A  1  68                   pla         ;load status
000E2B  1  49 30                eor_flag 0
000E2D  1  DD 1C 02             cmp fLDx,x  ;test flags
000E30  1  D0 FE                trap_ne
000E32  1  CA                   dex
000E33  1  10 DF                bpl tldy
000E35  1               
000E35  1  A2 03                ldx #3
000E37  1               tldy1:
000E37  1  A9 FF 48 28          set_stat $ff
000E3B  1  B4 13                ldy zp1,x
000E3D  1  08                   php         ;test stores do not alter flags
000E3E  1  98                   tya
000E3F  1  49 C3                eor #$c3
000E41  1  28                   plp
000E42  1  9D 03 02             sta abst,x
000E45  1  08                   php         ;flags after load/store sequence
000E46  1  49 C3                eor #$c3
000E48  1  DD 17 02             cmp abs1,x  ;test result
000E4B  1  D0 FE                trap_ne
000E4D  1  68                   pla         ;load status
000E4E  1  49 7D                eor_flag <~fnz ;mask bits not altered
000E50  1  DD 1C 02             cmp fLDx,x  ;test flags
000E53  1  D0 FE                trap_ne
000E55  1  CA                   dex
000E56  1  10 DF                bpl tldy1
000E58  1               
000E58  1  A2 03                ldx #3
000E5A  1               tldy2:
000E5A  1  A9 00 48 28          set_stat 0
000E5E  1  BC 17 02             ldy abs1,x
000E61  1  08                   php         ;test stores do not alter flags
000E62  1  98                   tya
000E63  1  49 C3                eor #$c3
000E65  1  A8                   tay
000E66  1  28                   plp
000E67  1  94 0C                sty zpt,x
000E69  1  08                   php         ;flags after load/store sequence
000E6A  1  49 C3                eor #$c3
000E6C  1  D5 13                cmp zp1,x   ;test result
000E6E  1  D0 FE                trap_ne
000E70  1  68                   pla         ;load status
000E71  1  49 30                eor_flag 0
000E73  1  DD 1C 02             cmp fLDx,x  ;test flags
000E76  1  D0 FE                trap_ne
000E78  1  CA                   dex
000E79  1  10 DF                bpl tldy2
000E7B  1               
000E7B  1  A2 03                ldx #3
000E7D  1               tldy3:
000E7D  1  A9 FF 48 28          set_stat $ff
000E81  1  BC 17 02             ldy abs1,x
000E84  1  08                   php         ;test stores do not alter flags
000E85  1  98                   tya
000E86  1  49 C3                eor #$c3
000E88  1  A8                   tay
000E89  1  28                   plp
000E8A  1  94 0C                sty zpt,x
000E8C  1  08                   php         ;flags after load/store sequence
000E8D  1  49 C3                eor #$c3
000E8F  1  D5 13                cmp zp1,x   ;test result
000E91  1  D0 FE                trap_ne
000E93  1  68                   pla         ;load status
000E94  1  49 7D                eor_flag <~fnz ;mask bits not altered
000E96  1  DD 1C 02             cmp fLDx,x  ;test flags
000E99  1  D0 FE                trap_ne
000E9B  1  CA                   dex
000E9C  1  10 DF                bpl tldy3
000E9E  1               
000E9E  1  A2 03                ldx #3      ;testing store result
000EA0  1  A0 00                ldy #0
000EA2  1  B5 0C        tsty:   lda zpt,x
000EA4  1  49 C3                eor #$c3
000EA6  1  D5 13                cmp zp1,x
000EA8  1  D0 FE                trap_ne     ;store to zp,x data
000EAA  1  94 0C                sty zpt,x   ;clear
000EAC  1  BD 03 02             lda abst,x
000EAF  1  49 C3                eor #$c3
000EB1  1  DD 17 02             cmp abs1,x
000EB4  1  D0 FE                trap_ne     ;store to abs,x data
000EB6  1  8A                   txa
000EB7  1  9D 03 02             sta abst,x  ;clear
000EBA  1  CA                   dex
000EBB  1  10 E5                bpl tsty
000EBD  1  AD 00 02 C9          next_test
000EC1  1  11 D0 FE A9  
000EC5  1  12 8D 00 02  
000EC9  1               
000EC9  1               ; indexed wraparound test (only zp should wrap)
000EC9  1  A2 FD                ldx #3+$fa
000ECB  1  B4 19        tldy4:  ldy <(zp1-$fa),x   ;wrap on indexed zp
000ECD  1  98                   tya
000ECE  1  9D 09 01             sta abst-$fa,x      ;no STX abs,x!
000ED1  1  CA                   dex
000ED2  1  E0 FA                cpx #$fa
000ED4  1  B0 F5                bcs tldy4
000ED6  1  A2 FD                ldx #3+$fa
000ED8  1  BC 1D 01     tldy5:  ldy abs1-$fa,x      ;no wrap on indexed abs
000EDB  1  94 12                sty <(zpt-$fa),x
000EDD  1  CA                   dex
000EDE  1  E0 FA                cpx #$fa
000EE0  1  B0 F6                bcs tldy5
000EE2  1  A2 03                ldx #3      ;testing wraparound result
000EE4  1  A0 00                ldy #0
000EE6  1  B5 0C        tsty1:  lda zpt,x
000EE8  1  D5 13                cmp zp1,x
000EEA  1  D0 FE                trap_ne     ;store to zp,x data
000EEC  1  94 0C                sty zpt,x   ;clear
000EEE  1  BD 03 02             lda abst,x
000EF1  1  DD 17 02             cmp abs1,x
000EF4  1  D0 FE                trap_ne     ;store to abs,x data
000EF6  1  8A                   txa
000EF7  1  9D 03 02             sta abst,x  ;clear
000EFA  1  CA                   dex
000EFB  1  10 E9                bpl tsty1
000EFD  1  AD 00 02 C9          next_test
000F01  1  12 D0 FE A9  
000F05  1  13 8D 00 02  
000F09  1               
000F09  1               ; LDX / STX - zp / abs / #
000F09  1  A9 00 48 28          set_stat 0
000F0D  1  A6 13                ldx zp1
000F0F  1  08                   php         ;test stores do not alter flags
000F10  1  8A                   txa
000F11  1  49 C3                eor #$c3
000F13  1  AA                   tax
000F14  1  28                   plp
000F15  1  8E 03 02             stx abst
000F18  1  08                   php         ;flags after load/store sequence
000F19  1  49 C3                eor #$c3
000F1B  1  AA                   tax
000F1C  1  E0 C3                cpx #$c3    ;test result
000F1E  1  D0 FE                trap_ne
000F20  1  68                   pla         ;load status
000F21  1  49 30                eor_flag 0
000F23  1  CD 1C 02             cmp fLDx    ;test flags
000F26  1  D0 FE                trap_ne
000F28  1  A9 00 48 28          set_stat 0
000F2C  1  A6 14                ldx zp1+1
000F2E  1  08                   php         ;test stores do not alter flags
000F2F  1  8A                   txa
000F30  1  49 C3                eor #$c3
000F32  1  AA                   tax
000F33  1  28                   plp
000F34  1  8E 04 02             stx abst+1
000F37  1  08                   php         ;flags after load/store sequence
000F38  1  49 C3                eor #$c3
000F3A  1  AA                   tax
000F3B  1  E0 82                cpx #$82    ;test result
000F3D  1  D0 FE                trap_ne
000F3F  1  68                   pla         ;load status
000F40  1  49 30                eor_flag 0
000F42  1  CD 1D 02             cmp fLDx+1  ;test flags
000F45  1  D0 FE                trap_ne
000F47  1  A9 00 48 28          set_stat 0
000F4B  1  A6 15                ldx zp1+2
000F4D  1  08                   php         ;test stores do not alter flags
000F4E  1  8A                   txa
000F4F  1  49 C3                eor #$c3
000F51  1  AA                   tax
000F52  1  28                   plp
000F53  1  8E 05 02             stx abst+2
000F56  1  08                   php         ;flags after load/store sequence
000F57  1  49 C3                eor #$c3
000F59  1  AA                   tax
000F5A  1  E0 41                cpx #$41    ;test result
000F5C  1  D0 FE                trap_ne
000F5E  1  68                   pla         ;load status
000F5F  1  49 30                eor_flag 0
000F61  1  CD 1E 02             cmp fLDx+2  ;test flags
000F64  1  D0 FE                trap_ne
000F66  1  A9 00 48 28          set_stat 0
000F6A  1  A6 16                ldx zp1+3
000F6C  1  08                   php         ;test stores do not alter flags
000F6D  1  8A                   txa
000F6E  1  49 C3                eor #$c3
000F70  1  AA                   tax
000F71  1  28                   plp
000F72  1  8E 06 02             stx abst+3
000F75  1  08                   php         ;flags after load/store sequence
000F76  1  49 C3                eor #$c3
000F78  1  AA                   tax
000F79  1  E0 00                cpx #0      ;test result
000F7B  1  D0 FE                trap_ne
000F7D  1  68                   pla         ;load status
000F7E  1  49 30                eor_flag 0
000F80  1  CD 1F 02             cmp fLDx+3  ;test flags
000F83  1  D0 FE                trap_ne
000F85  1               
000F85  1  A9 FF 48 28          set_stat $ff
000F89  1  A6 13                ldx zp1
000F8B  1  08                   php         ;test stores do not alter flags
000F8C  1  8A                   txa
000F8D  1  49 C3                eor #$c3
000F8F  1  AA                   tax
000F90  1  28                   plp
000F91  1  8E 03 02             stx abst
000F94  1  08                   php         ;flags after load/store sequence
000F95  1  49 C3                eor #$c3
000F97  1  AA                   tax
000F98  1  E0 C3                cpx #$c3    ;test result
000F9A  1  D0 FE                trap_ne     ;
000F9C  1  68                   pla         ;load status
000F9D  1  49 7D                eor_flag <~fnz ;mask bits not altered
000F9F  1  CD 1C 02             cmp fLDx    ;test flags
000FA2  1  D0 FE                trap_ne
000FA4  1  A9 FF 48 28          set_stat $ff
000FA8  1  A6 14                ldx zp1+1
000FAA  1  08                   php         ;test stores do not alter flags
000FAB  1  8A                   txa
000FAC  1  49 C3                eor #$c3
000FAE  1  AA                   tax
000FAF  1  28                   plp
000FB0  1  8E 04 02             stx abst+1
000FB3  1  08                   php         ;flags after load/store sequence
000FB4  1  49 C3                eor #$c3
000FB6  1  AA                   tax
000FB7  1  E0 82                cpx #$82    ;test result
000FB9  1  D0 FE                trap_ne
000FBB  1  68                   pla         ;load status
000FBC  1  49 7D                eor_flag <~fnz ;mask bits not altered
000FBE  1  CD 1D 02             cmp fLDx+1  ;test flags
000FC1  1  D0 FE                trap_ne
000FC3  1  A9 FF 48 28          set_stat $ff
000FC7  1  A6 15                ldx zp1+2
000FC9  1  08                   php         ;test stores do not alter flags
000FCA  1  8A                   txa
000FCB  1  49 C3                eor #$c3
000FCD  1  AA                   tax
000FCE  1  28                   plp
000FCF  1  8E 05 02             stx abst+2
000FD2  1  08                   php         ;flags after load/store sequence
000FD3  1  49 C3                eor #$c3
000FD5  1  AA                   tax
000FD6  1  E0 41                cpx #$41    ;test result
000FD8  1  D0 FE                trap_ne     ;
000FDA  1  68                   pla         ;load status
000FDB  1  49 7D                eor_flag <~fnz ;mask bits not altered
000FDD  1  CD 1E 02             cmp fLDx+2  ;test flags
000FE0  1  D0 FE                trap_ne
000FE2  1  A9 FF 48 28          set_stat $ff
000FE6  1  A6 16                ldx zp1+3
000FE8  1  08                   php         ;test stores do not alter flags
000FE9  1  8A                   txa
000FEA  1  49 C3                eor #$c3
000FEC  1  AA                   tax
000FED  1  28                   plp
000FEE  1  8E 06 02             stx abst+3
000FF1  1  08                   php         ;flags after load/store sequence
000FF2  1  49 C3                eor #$c3
000FF4  1  AA                   tax
000FF5  1  E0 00                cpx #0      ;test result
000FF7  1  D0 FE                trap_ne
000FF9  1  68                   pla         ;load status
000FFA  1  49 7D                eor_flag <~fnz ;mask bits not altered
000FFC  1  CD 1F 02             cmp fLDx+3  ;test flags
000FFF  1  D0 FE                trap_ne
001001  1               
001001  1  A9 00 48 28          set_stat 0
001005  1  AE 17 02             ldx abs1
001008  1  08                   php         ;test stores do not alter flags
001009  1  8A                   txa
00100A  1  49 C3                eor #$c3
00100C  1  AA                   tax
00100D  1  28                   plp
00100E  1  86 0C                stx zpt
001010  1  08                   php         ;flags after load/store sequence
001011  1  49 C3                eor #$c3
001013  1  C5 13                cmp zp1     ;test result
001015  1  D0 FE                trap_ne
001017  1  68                   pla         ;load status
001018  1  49 30                eor_flag 0
00101A  1  CD 1C 02             cmp fLDx    ;test flags
00101D  1  D0 FE                trap_ne
00101F  1  A9 00 48 28          set_stat 0
001023  1  AE 18 02             ldx abs1+1
001026  1  08                   php         ;test stores do not alter flags
001027  1  8A                   txa
001028  1  49 C3                eor #$c3
00102A  1  AA                   tax
00102B  1  28                   plp
00102C  1  86 0D                stx zpt+1
00102E  1  08                   php         ;flags after load/store sequence
00102F  1  49 C3                eor #$c3
001031  1  C5 14                cmp zp1+1   ;test result
001033  1  D0 FE                trap_ne
001035  1  68                   pla         ;load status
001036  1  49 30                eor_flag 0
001038  1  CD 1D 02             cmp fLDx+1  ;test flags
00103B  1  D0 FE                trap_ne
00103D  1  A9 00 48 28          set_stat 0
001041  1  AE 19 02             ldx abs1+2
001044  1  08                   php         ;test stores do not alter flags
001045  1  8A                   txa
001046  1  49 C3                eor #$c3
001048  1  AA                   tax
001049  1  28                   plp
00104A  1  86 0E                stx zpt+2
00104C  1  08                   php         ;flags after load/store sequence
00104D  1  49 C3                eor #$c3
00104F  1  C5 15                cmp zp1+2   ;test result
001051  1  D0 FE                trap_ne
001053  1  68                   pla         ;load status
001054  1  49 30                eor_flag 0
001056  1  CD 1E 02             cmp fLDx+2  ;test flags
001059  1  D0 FE                trap_ne
00105B  1  A9 00 48 28          set_stat 0
00105F  1  AE 1A 02             ldx abs1+3
001062  1  08                   php         ;test stores do not alter flags
001063  1  8A                   txa
001064  1  49 C3                eor #$c3
001066  1  AA                   tax
001067  1  28                   plp
001068  1  86 0F                stx zpt+3
00106A  1  08                   php         ;flags after load/store sequence
00106B  1  49 C3                eor #$c3
00106D  1  C5 16                cmp zp1+3   ;test result
00106F  1  D0 FE                trap_ne
001071  1  68                   pla         ;load status
001072  1  49 30                eor_flag 0
001074  1  CD 1F 02             cmp fLDx+3  ;test flags
001077  1  D0 FE                trap_ne
001079  1               
001079  1  A9 FF 48 28          set_stat $ff
00107D  1  AE 17 02             ldx abs1
001080  1  08                   php         ;test stores do not alter flags
001081  1  8A                   txa
001082  1  49 C3                eor #$c3
001084  1  AA                   tax
001085  1  28                   plp
001086  1  86 0C                stx zpt
001088  1  08                   php         ;flags after load/store sequence
001089  1  49 C3                eor #$c3
00108B  1  AA                   tax
00108C  1  E4 13                cpx zp1     ;test result
00108E  1  D0 FE                trap_ne
001090  1  68                   pla         ;load status
001091  1  49 7D                eor_flag <~fnz ;mask bits not altered
001093  1  CD 1C 02             cmp fLDx    ;test flags
001096  1  D0 FE                trap_ne
001098  1  A9 FF 48 28          set_stat $ff
00109C  1  AE 18 02             ldx abs1+1
00109F  1  08                   php         ;test stores do not alter flags
0010A0  1  8A                   txa
0010A1  1  49 C3                eor #$c3
0010A3  1  AA                   tax
0010A4  1  28                   plp
0010A5  1  86 0D                stx zpt+1
0010A7  1  08                   php         ;flags after load/store sequence
0010A8  1  49 C3                eor #$c3
0010AA  1  AA                   tax
0010AB  1  E4 14                cpx zp1+1   ;test result
0010AD  1  D0 FE                trap_ne
0010AF  1  68                   pla         ;load status
0010B0  1  49 7D                eor_flag <~fnz ;mask bits not altered
0010B2  1  CD 1D 02             cmp fLDx+1  ;test flags
0010B5  1  D0 FE                trap_ne
0010B7  1  A9 FF 48 28          set_stat $ff
0010BB  1  AE 19 02             ldx abs1+2
0010BE  1  08                   php         ;test stores do not alter flags
0010BF  1  8A                   txa
0010C0  1  49 C3                eor #$c3
0010C2  1  AA                   tax
0010C3  1  28                   plp
0010C4  1  86 0E                stx zpt+2
0010C6  1  08                   php         ;flags after load/store sequence
0010C7  1  49 C3                eor #$c3
0010C9  1  AA                   tax
0010CA  1  E4 15                cpx zp1+2   ;test result
0010CC  1  D0 FE                trap_ne
0010CE  1  68                   pla         ;load status
0010CF  1  49 7D                eor_flag <~fnz ;mask bits not altered
0010D1  1  CD 1E 02             cmp fLDx+2  ;test flags
0010D4  1  D0 FE                trap_ne
0010D6  1  A9 FF 48 28          set_stat $ff
0010DA  1  AE 1A 02             ldx abs1+3
0010DD  1  08                   php         ;test stores do not alter flags
0010DE  1  8A                   txa
0010DF  1  49 C3                eor #$c3
0010E1  1  AA                   tax
0010E2  1  28                   plp
0010E3  1  86 0F                stx zpt+3
0010E5  1  08                   php         ;flags after load/store sequence
0010E6  1  49 C3                eor #$c3
0010E8  1  AA                   tax
0010E9  1  E4 16                cpx zp1+3   ;test result
0010EB  1  D0 FE                trap_ne
0010ED  1  68                   pla         ;load status
0010EE  1  49 7D                eor_flag <~fnz ;mask bits not altered
0010F0  1  CD 1F 02             cmp fLDx+3  ;test flags
0010F3  1  D0 FE                trap_ne
0010F5  1               
0010F5  1  A9 00 48 28          set_stat 0
0010F9  1  A2 C3                ldx #$c3
0010FB  1  08                   php
0010FC  1  EC 17 02             cpx abs1    ;test result
0010FF  1  D0 FE                trap_ne
001101  1  68                   pla         ;load status
001102  1  49 30                eor_flag 0
001104  1  CD 1C 02             cmp fLDx    ;test flags
001107  1  D0 FE                trap_ne
001109  1  A9 00 48 28          set_stat 0
00110D  1  A2 82                ldx #$82
00110F  1  08                   php
001110  1  EC 18 02             cpx abs1+1  ;test result
001113  1  D0 FE                trap_ne
001115  1  68                   pla         ;load status
001116  1  49 30                eor_flag 0
001118  1  CD 1D 02             cmp fLDx+1  ;test flags
00111B  1  D0 FE                trap_ne
00111D  1  A9 00 48 28          set_stat 0
001121  1  A2 41                ldx #$41
001123  1  08                   php
001124  1  EC 19 02             cpx abs1+2  ;test result
001127  1  D0 FE                trap_ne
001129  1  68                   pla         ;load status
00112A  1  49 30                eor_flag 0
00112C  1  CD 1E 02             cmp fLDx+2  ;test flags
00112F  1  D0 FE                trap_ne
001131  1  A9 00 48 28          set_stat 0
001135  1  A2 00                ldx #0
001137  1  08                   php
001138  1  EC 1A 02             cpx abs1+3  ;test result
00113B  1  D0 FE                trap_ne
00113D  1  68                   pla         ;load status
00113E  1  49 30                eor_flag 0
001140  1  CD 1F 02             cmp fLDx+3  ;test flags
001143  1  D0 FE                trap_ne
001145  1               
001145  1  A9 FF 48 28          set_stat $ff
001149  1  A2 C3                ldx #$c3
00114B  1  08                   php
00114C  1  EC 17 02             cpx abs1    ;test result
00114F  1  D0 FE                trap_ne
001151  1  68                   pla         ;load status
001152  1  49 7D                eor_flag <~fnz ;mask bits not altered
001154  1  CD 1C 02             cmp fLDx    ;test flags
001157  1  D0 FE                trap_ne
001159  1  A9 FF 48 28          set_stat $ff
00115D  1  A2 82                ldx #$82
00115F  1  08                   php
001160  1  EC 18 02             cpx abs1+1  ;test result
001163  1  D0 FE                trap_ne
001165  1  68                   pla         ;load status
001166  1  49 7D                eor_flag <~fnz ;mask bits not altered
001168  1  CD 1D 02             cmp fLDx+1  ;test flags
00116B  1  D0 FE                trap_ne
00116D  1  A9 FF 48 28          set_stat $ff
001171  1  A2 41                ldx #$41
001173  1  08                   php
001174  1  EC 19 02             cpx abs1+2  ;test result
001177  1  D0 FE                trap_ne
001179  1  68                   pla         ;load status
00117A  1  49 7D                eor_flag <~fnz ;mask bits not altered
00117C  1  CD 1E 02             cmp fLDx+2  ;test flags
00117F  1  D0 FE                trap_ne
001181  1  A9 FF 48 28          set_stat $ff
001185  1  A2 00                ldx #0
001187  1  08                   php
001188  1  EC 1A 02             cpx abs1+3  ;test result
00118B  1  D0 FE                trap_ne
00118D  1  68                   pla         ;load status
00118E  1  49 7D                eor_flag <~fnz ;mask bits not altered
001190  1  CD 1F 02             cmp fLDx+3  ;test flags
001193  1  D0 FE                trap_ne
001195  1               
001195  1  A2 00                ldx #0
001197  1  A5 0C                lda zpt
001199  1  49 C3                eor #$c3
00119B  1  C5 13                cmp zp1
00119D  1  D0 FE                trap_ne     ;store to zp data
00119F  1  86 0C                stx zpt     ;clear
0011A1  1  AD 03 02             lda abst
0011A4  1  49 C3                eor #$c3
0011A6  1  CD 17 02             cmp abs1
0011A9  1  D0 FE                trap_ne     ;store to abs data
0011AB  1  8E 03 02             stx abst    ;clear
0011AE  1  A5 0D                lda zpt+1
0011B0  1  49 C3                eor #$c3
0011B2  1  C5 14                cmp zp1+1
0011B4  1  D0 FE                trap_ne     ;store to zp data
0011B6  1  86 0D                stx zpt+1   ;clear
0011B8  1  AD 04 02             lda abst+1
0011BB  1  49 C3                eor #$c3
0011BD  1  CD 18 02             cmp abs1+1
0011C0  1  D0 FE                trap_ne     ;store to abs data
0011C2  1  8E 04 02             stx abst+1  ;clear
0011C5  1  A5 0E                lda zpt+2
0011C7  1  49 C3                eor #$c3
0011C9  1  C5 15                cmp zp1+2
0011CB  1  D0 FE                trap_ne     ;store to zp data
0011CD  1  86 0E                stx zpt+2   ;clear
0011CF  1  AD 05 02             lda abst+2
0011D2  1  49 C3                eor #$c3
0011D4  1  CD 19 02             cmp abs1+2
0011D7  1  D0 FE                trap_ne     ;store to abs data
0011D9  1  8E 05 02             stx abst+2  ;clear
0011DC  1  A5 0F                lda zpt+3
0011DE  1  49 C3                eor #$c3
0011E0  1  C5 16                cmp zp1+3
0011E2  1  D0 FE                trap_ne     ;store to zp data
0011E4  1  86 0F                stx zpt+3   ;clear
0011E6  1  AD 06 02             lda abst+3
0011E9  1  49 C3                eor #$c3
0011EB  1  CD 1A 02             cmp abs1+3
0011EE  1  D0 FE                trap_ne     ;store to abs data
0011F0  1  8E 06 02             stx abst+3  ;clear
0011F3  1  AD 00 02 C9          next_test
0011F7  1  13 D0 FE A9  
0011FB  1  14 8D 00 02  
0011FF  1               
0011FF  1               ; LDY / STY - zp / abs / #
0011FF  1  A9 00 48 28          set_stat 0
001203  1  A4 13                ldy zp1
001205  1  08                   php         ;test stores do not alter flags
001206  1  98                   tya
001207  1  49 C3                eor #$c3
001209  1  A8                   tay
00120A  1  28                   plp
00120B  1  8C 03 02             sty abst
00120E  1  08                   php         ;flags after load/store sequence
00120F  1  49 C3                eor #$c3
001211  1  A8                   tay
001212  1  C0 C3                cpy #$c3    ;test result
001214  1  D0 FE                trap_ne
001216  1  68                   pla         ;load status
001217  1  49 30                eor_flag 0
001219  1  CD 1C 02             cmp fLDx    ;test flags
00121C  1  D0 FE                trap_ne
00121E  1  A9 00 48 28          set_stat 0
001222  1  A4 14                ldy zp1+1
001224  1  08                   php         ;test stores do not alter flags
001225  1  98                   tya
001226  1  49 C3                eor #$c3
001228  1  A8                   tay
001229  1  28                   plp
00122A  1  8C 04 02             sty abst+1
00122D  1  08                   php         ;flags after load/store sequence
00122E  1  49 C3                eor #$c3
001230  1  A8                   tay
001231  1  C0 82                cpy #$82    ;test result
001233  1  D0 FE                trap_ne
001235  1  68                   pla         ;load status
001236  1  49 30                eor_flag 0
001238  1  CD 1D 02             cmp fLDx+1  ;test flags
00123B  1  D0 FE                trap_ne
00123D  1  A9 00 48 28          set_stat 0
001241  1  A4 15                ldy zp1+2
001243  1  08                   php         ;test stores do not alter flags
001244  1  98                   tya
001245  1  49 C3                eor #$c3
001247  1  A8                   tay
001248  1  28                   plp
001249  1  8C 05 02             sty abst+2
00124C  1  08                   php         ;flags after load/store sequence
00124D  1  49 C3                eor #$c3
00124F  1  A8                   tay
001250  1  C0 41                cpy #$41    ;test result
001252  1  D0 FE                trap_ne
001254  1  68                   pla         ;load status
001255  1  49 30                eor_flag 0
001257  1  CD 1E 02             cmp fLDx+2  ;test flags
00125A  1  D0 FE                trap_ne
00125C  1  A9 00 48 28          set_stat 0
001260  1  A4 16                ldy zp1+3
001262  1  08                   php         ;test stores do not alter flags
001263  1  98                   tya
001264  1  49 C3                eor #$c3
001266  1  A8                   tay
001267  1  28                   plp
001268  1  8C 06 02             sty abst+3
00126B  1  08                   php         ;flags after load/store sequence
00126C  1  49 C3                eor #$c3
00126E  1  A8                   tay
00126F  1  C0 00                cpy #0      ;test result
001271  1  D0 FE                trap_ne
001273  1  68                   pla         ;load status
001274  1  49 30                eor_flag 0
001276  1  CD 1F 02             cmp fLDx+3  ;test flags
001279  1  D0 FE                trap_ne
00127B  1               
00127B  1  A9 FF 48 28          set_stat $ff
00127F  1  A4 13                ldy zp1
001281  1  08                   php         ;test stores do not alter flags
001282  1  98                   tya
001283  1  49 C3                eor #$c3
001285  1  A8                   tay
001286  1  28                   plp
001287  1  8C 03 02             sty abst
00128A  1  08                   php         ;flags after load/store sequence
00128B  1  49 C3                eor #$c3
00128D  1  A8                   tay
00128E  1  C0 C3                cpy #$c3    ;test result
001290  1  D0 FE                trap_ne
001292  1  68                   pla         ;load status
001293  1  49 7D                eor_flag <~fnz ;mask bits not altered
001295  1  CD 1C 02             cmp fLDx    ;test flags
001298  1  D0 FE                trap_ne
00129A  1  A9 FF 48 28          set_stat $ff
00129E  1  A4 14                ldy zp1+1
0012A0  1  08                   php         ;test stores do not alter flags
0012A1  1  98                   tya
0012A2  1  49 C3                eor #$c3
0012A4  1  A8                   tay
0012A5  1  28                   plp
0012A6  1  8C 04 02             sty abst+1
0012A9  1  08                   php         ;flags after load/store sequence
0012AA  1  49 C3                eor #$c3
0012AC  1  A8                   tay
0012AD  1  C0 82                cpy #$82   ;test result
0012AF  1  D0 FE                trap_ne
0012B1  1  68                   pla         ;load status
0012B2  1  49 7D                eor_flag <~fnz ;mask bits not altered
0012B4  1  CD 1D 02             cmp fLDx+1  ;test flags
0012B7  1  D0 FE                trap_ne
0012B9  1  A9 FF 48 28          set_stat $ff
0012BD  1  A4 15                ldy zp1+2
0012BF  1  08                   php         ;test stores do not alter flags
0012C0  1  98                   tya
0012C1  1  49 C3                eor #$c3
0012C3  1  A8                   tay
0012C4  1  28                   plp
0012C5  1  8C 05 02             sty abst+2
0012C8  1  08                   php         ;flags after load/store sequence
0012C9  1  49 C3                eor #$c3
0012CB  1  A8                   tay
0012CC  1  C0 41                cpy #$41    ;test result
0012CE  1  D0 FE                trap_ne
0012D0  1  68                   pla         ;load status
0012D1  1  49 7D                eor_flag <~fnz ;mask bits not altered
0012D3  1  CD 1E 02             cmp fLDx+2  ;test flags
0012D6  1  D0 FE                trap_ne
0012D8  1  A9 FF 48 28          set_stat $ff
0012DC  1  A4 16                ldy zp1+3
0012DE  1  08                   php         ;test stores do not alter flags
0012DF  1  98                   tya
0012E0  1  49 C3                eor #$c3
0012E2  1  A8                   tay
0012E3  1  28                   plp
0012E4  1  8C 06 02             sty abst+3
0012E7  1  08                   php         ;flags after load/store sequence
0012E8  1  49 C3                eor #$c3
0012EA  1  A8                   tay
0012EB  1  C0 00                cpy #0      ;test result
0012ED  1  D0 FE                trap_ne
0012EF  1  68                   pla         ;load status
0012F0  1  49 7D                eor_flag <~fnz ;mask bits not altered
0012F2  1  CD 1F 02             cmp fLDx+3  ;test flags
0012F5  1  D0 FE                trap_ne
0012F7  1               
0012F7  1  A9 00 48 28          set_stat 0
0012FB  1  AC 17 02             ldy abs1
0012FE  1  08                   php         ;test stores do not alter flags
0012FF  1  98                   tya
001300  1  49 C3                eor #$c3
001302  1  A8                   tay
001303  1  28                   plp
001304  1  84 0C                sty zpt
001306  1  08                   php         ;flags after load/store sequence
001307  1  49 C3                eor #$c3
001309  1  A8                   tay
00130A  1  C4 13                cpy zp1     ;test result
00130C  1  D0 FE                trap_ne
00130E  1  68                   pla         ;load status
00130F  1  49 30                eor_flag 0
001311  1  CD 1C 02             cmp fLDx    ;test flags
001314  1  D0 FE                trap_ne
001316  1  A9 00 48 28          set_stat 0
00131A  1  AC 18 02             ldy abs1+1
00131D  1  08                   php         ;test stores do not alter flags
00131E  1  98                   tya
00131F  1  49 C3                eor #$c3
001321  1  A8                   tay
001322  1  28                   plp
001323  1  84 0D                sty zpt+1
001325  1  08                   php         ;flags after load/store sequence
001326  1  49 C3                eor #$c3
001328  1  A8                   tay
001329  1  C4 14                cpy zp1+1   ;test result
00132B  1  D0 FE                trap_ne
00132D  1  68                   pla         ;load status
00132E  1  49 30                eor_flag 0
001330  1  CD 1D 02             cmp fLDx+1  ;test flags
001333  1  D0 FE                trap_ne
001335  1  A9 00 48 28          set_stat 0
001339  1  AC 19 02             ldy abs1+2
00133C  1  08                   php         ;test stores do not alter flags
00133D  1  98                   tya
00133E  1  49 C3                eor #$c3
001340  1  A8                   tay
001341  1  28                   plp
001342  1  84 0E                sty zpt+2
001344  1  08                   php         ;flags after load/store sequence
001345  1  49 C3                eor #$c3
001347  1  A8                   tay
001348  1  C4 15                cpy zp1+2   ;test result
00134A  1  D0 FE                trap_ne
00134C  1  68                   pla         ;load status
00134D  1  49 30                eor_flag 0
00134F  1  CD 1E 02             cmp fLDx+2  ;test flags
001352  1  D0 FE                trap_ne
001354  1  A9 00 48 28          set_stat 0
001358  1  AC 1A 02             ldy abs1+3
00135B  1  08                   php         ;test stores do not alter flags
00135C  1  98                   tya
00135D  1  49 C3                eor #$c3
00135F  1  A8                   tay
001360  1  28                   plp
001361  1  84 0F                sty zpt+3
001363  1  08                   php         ;flags after load/store sequence
001364  1  49 C3                eor #$c3
001366  1  A8                   tay
001367  1  C4 16                cpy zp1+3   ;test result
001369  1  D0 FE                trap_ne
00136B  1  68                   pla         ;load status
00136C  1  49 30                eor_flag 0
00136E  1  CD 1F 02             cmp fLDx+3  ;test flags
001371  1  D0 FE                trap_ne
001373  1               
001373  1  A9 FF 48 28          set_stat $ff
001377  1  AC 17 02             ldy abs1
00137A  1  08                   php         ;test stores do not alter flags
00137B  1  98                   tya
00137C  1  49 C3                eor #$c3
00137E  1  A8                   tay
00137F  1  28                   plp
001380  1  84 0C                sty zpt
001382  1  08                   php         ;flags after load/store sequence
001383  1  49 C3                eor #$c3
001385  1  A8                   tay
001386  1  C5 13                cmp zp1     ;test result
001388  1  D0 FE                trap_ne
00138A  1  68                   pla         ;load status
00138B  1  49 7D                eor_flag <~fnz ;mask bits not altered
00138D  1  CD 1C 02             cmp fLDx    ;test flags
001390  1  D0 FE                trap_ne
001392  1  A9 FF 48 28          set_stat $ff
001396  1  AC 18 02             ldy abs1+1
001399  1  08                   php         ;test stores do not alter flags
00139A  1  98                   tya
00139B  1  49 C3                eor #$c3
00139D  1  A8                   tay
00139E  1  28                   plp
00139F  1  84 0D                sty zpt+1
0013A1  1  08                   php         ;flags after load/store sequence
0013A2  1  49 C3                eor #$c3
0013A4  1  A8                   tay
0013A5  1  C5 14                cmp zp1+1   ;test result
0013A7  1  D0 FE                trap_ne
0013A9  1  68                   pla         ;load status
0013AA  1  49 7D                eor_flag <~fnz ;mask bits not altered
0013AC  1  CD 1D 02             cmp fLDx+1  ;test flags
0013AF  1  D0 FE                trap_ne
0013B1  1  A9 FF 48 28          set_stat $ff
0013B5  1  AC 19 02             ldy abs1+2
0013B8  1  08                   php         ;test stores do not alter flags
0013B9  1  98                   tya
0013BA  1  49 C3                eor #$c3
0013BC  1  A8                   tay
0013BD  1  28                   plp
0013BE  1  84 0E                sty zpt+2
0013C0  1  08                   php         ;flags after load/store sequence
0013C1  1  49 C3                eor #$c3
0013C3  1  A8                   tay
0013C4  1  C5 15                cmp zp1+2   ;test result
0013C6  1  D0 FE                trap_ne
0013C8  1  68                   pla         ;load status
0013C9  1  49 7D                eor_flag <~fnz ;mask bits not altered
0013CB  1  CD 1E 02             cmp fLDx+2  ;test flags
0013CE  1  D0 FE                trap_ne
0013D0  1  A9 FF 48 28          set_stat $ff
0013D4  1  AC 1A 02             ldy abs1+3
0013D7  1  08                   php         ;test stores do not alter flags
0013D8  1  98                   tya
0013D9  1  49 C3                eor #$c3
0013DB  1  A8                   tay
0013DC  1  28                   plp
0013DD  1  84 0F                sty zpt+3
0013DF  1  08                   php         ;flags after load/store sequence
0013E0  1  49 C3                eor #$c3
0013E2  1  A8                   tay
0013E3  1  C5 16                cmp zp1+3   ;test result
0013E5  1  D0 FE                trap_ne
0013E7  1  68                   pla         ;load status
0013E8  1  49 7D                eor_flag <~fnz ;mask bits not altered
0013EA  1  CD 1F 02             cmp fLDx+3  ;test flags
0013ED  1  D0 FE                trap_ne
0013EF  1               
0013EF  1               
0013EF  1  A9 00 48 28          set_stat 0
0013F3  1  A0 C3                ldy #$c3
0013F5  1  08                   php
0013F6  1  CC 17 02             cpy abs1    ;test result
0013F9  1  D0 FE                trap_ne
0013FB  1  68                   pla         ;load status
0013FC  1  49 30                eor_flag 0
0013FE  1  CD 1C 02             cmp fLDx    ;test flags
001401  1  D0 FE                trap_ne
001403  1  A9 00 48 28          set_stat 0
001407  1  A0 82                ldy #$82
001409  1  08                   php
00140A  1  CC 18 02             cpy abs1+1  ;test result
00140D  1  D0 FE                trap_ne
00140F  1  68                   pla         ;load status
001410  1  49 30                eor_flag 0
001412  1  CD 1D 02             cmp fLDx+1  ;test flags
001415  1  D0 FE                trap_ne
001417  1  A9 00 48 28          set_stat 0
00141B  1  A0 41                ldy #$41
00141D  1  08                   php
00141E  1  CC 19 02             cpy abs1+2  ;test result
001421  1  D0 FE                trap_ne
001423  1  68                   pla         ;load status
001424  1  49 30                eor_flag 0
001426  1  CD 1E 02             cmp fLDx+2  ;test flags
001429  1  D0 FE                trap_ne
00142B  1  A9 00 48 28          set_stat 0
00142F  1  A0 00                ldy #0
001431  1  08                   php
001432  1  CC 1A 02             cpy abs1+3  ;test result
001435  1  D0 FE                trap_ne
001437  1  68                   pla         ;load status
001438  1  49 30                eor_flag 0
00143A  1  CD 1F 02             cmp fLDx+3  ;test flags
00143D  1  D0 FE                trap_ne
00143F  1               
00143F  1  A9 FF 48 28          set_stat $ff
001443  1  A0 C3                ldy #$c3
001445  1  08                   php
001446  1  CC 17 02             cpy abs1    ;test result
001449  1  D0 FE                trap_ne
00144B  1  68                   pla         ;load status
00144C  1  49 7D                eor_flag <~fnz ;mask bits not altered
00144E  1  CD 1C 02             cmp fLDx    ;test flags
001451  1  D0 FE                trap_ne
001453  1  A9 FF 48 28          set_stat $ff
001457  1  A0 82                ldy #$82
001459  1  08                   php
00145A  1  CC 18 02             cpy abs1+1  ;test result
00145D  1  D0 FE                trap_ne
00145F  1  68                   pla         ;load status
001460  1  49 7D                eor_flag <~fnz ;mask bits not altered
001462  1  CD 1D 02             cmp fLDx+1  ;test flags
001465  1  D0 FE                trap_ne
001467  1  A9 FF 48 28          set_stat $ff
00146B  1  A0 41                ldy #$41
00146D  1  08                   php
00146E  1  CC 19 02             cpy abs1+2   ;test result
001471  1  D0 FE                trap_ne
001473  1  68                   pla         ;load status
001474  1  49 7D                eor_flag <~fnz ;mask bits not altered
001476  1  CD 1E 02             cmp fLDx+2  ;test flags
001479  1  D0 FE                trap_ne
00147B  1  A9 FF 48 28          set_stat $ff
00147F  1  A0 00                ldy #0
001481  1  08                   php
001482  1  CC 1A 02             cpy abs1+3  ;test result
001485  1  D0 FE                trap_ne
001487  1  68                   pla         ;load status
001488  1  49 7D                eor_flag <~fnz ;mask bits not altered
00148A  1  CD 1F 02             cmp fLDx+3  ;test flags
00148D  1  D0 FE                trap_ne
00148F  1               
00148F  1  A0 00                ldy #0
001491  1  A5 0C                lda zpt
001493  1  49 C3                eor #$c3
001495  1  C5 13                cmp zp1
001497  1  D0 FE                trap_ne     ;store to zp   data
001499  1  84 0C                sty zpt     ;clear
00149B  1  AD 03 02             lda abst
00149E  1  49 C3                eor #$c3
0014A0  1  CD 17 02             cmp abs1
0014A3  1  D0 FE                trap_ne     ;store to abs   data
0014A5  1  8C 03 02             sty abst    ;clear
0014A8  1  A5 0D                lda zpt+1
0014AA  1  49 C3                eor #$c3
0014AC  1  C5 14                cmp zp1+1
0014AE  1  D0 FE                trap_ne     ;store to zp+1 data
0014B0  1  84 0D                sty zpt+1   ;clear
0014B2  1  AD 04 02             lda abst+1
0014B5  1  49 C3                eor #$c3
0014B7  1  CD 18 02             cmp abs1+1
0014BA  1  D0 FE                trap_ne     ;store to abs+1 data
0014BC  1  8C 04 02             sty abst+1  ;clear
0014BF  1  A5 0E                lda zpt+2
0014C1  1  49 C3                eor #$c3
0014C3  1  C5 15                cmp zp1+2
0014C5  1  D0 FE                trap_ne     ;store to zp+2 data
0014C7  1  84 0E                sty zpt+2   ;clear
0014C9  1  AD 05 02             lda abst+2
0014CC  1  49 C3                eor #$c3
0014CE  1  CD 19 02             cmp abs1+2
0014D1  1  D0 FE                trap_ne     ;store to abs+2 data
0014D3  1  8C 05 02             sty abst+2  ;clear
0014D6  1  A5 0F                lda zpt+3
0014D8  1  49 C3                eor #$c3
0014DA  1  C5 16                cmp zp1+3
0014DC  1  D0 FE                trap_ne     ;store to zp+3 data
0014DE  1  84 0F                sty zpt+3   ;clear
0014E0  1  AD 06 02             lda abst+3
0014E3  1  49 C3                eor #$c3
0014E5  1  CD 1A 02             cmp abs1+3
0014E8  1  D0 FE                trap_ne     ;store to abs+3 data
0014EA  1  8C 06 02             sty abst+3  ;clear
0014ED  1  AD 00 02 C9          next_test
0014F1  1  14 D0 FE A9  
0014F5  1  15 8D 00 02  
0014F9  1               
0014F9  1               ; testing load / store accumulator LDA / STA all addressing modes
0014F9  1               ; LDA / STA - zp,x / abs,x
0014F9  1  A2 03                ldx #3
0014FB  1               tldax:
0014FB  1  A9 00 48 28          set_stat 0
0014FF  1  B5 13                lda zp1,x
001501  1  08                   php         ;test stores do not alter flags
001502  1  49 C3                eor #$c3
001504  1  28                   plp
001505  1  9D 03 02             sta abst,x
001508  1  08                   php         ;flags after load/store sequence
001509  1  49 C3                eor #$c3
00150B  1  DD 17 02             cmp abs1,x  ;test result
00150E  1  D0 FE                trap_ne
001510  1  68                   pla         ;load status
001511  1  49 30                eor_flag 0
001513  1  DD 1C 02             cmp fLDx,x  ;test flags
001516  1  D0 FE                trap_ne
001518  1  CA                   dex
001519  1  10 E0                bpl tldax
00151B  1               
00151B  1  A2 03                ldx #3
00151D  1               tldax1:
00151D  1  A9 FF 48 28          set_stat $ff
001521  1  B5 13                lda zp1,x
001523  1  08                   php         ;test stores do not alter flags
001524  1  49 C3                eor #$c3
001526  1  28                   plp
001527  1  9D 03 02             sta abst,x
00152A  1  08                   php         ;flags after load/store sequence
00152B  1  49 C3                eor #$c3
00152D  1  DD 17 02             cmp abs1,x   ;test result
001530  1  D0 FE                trap_ne
001532  1  68                   pla         ;load status
001533  1  49 7D                eor_flag <~fnz ;mask bits not altered
001535  1  DD 1C 02             cmp fLDx,x  ;test flags
001538  1  D0 FE                trap_ne
00153A  1  CA                   dex
00153B  1  10 E0                bpl tldax1
00153D  1               
00153D  1  A2 03                ldx #3
00153F  1               tldax2:
00153F  1  A9 00 48 28          set_stat 0
001543  1  BD 17 02             lda abs1,x
001546  1  08                   php         ;test stores do not alter flags
001547  1  49 C3                eor #$c3
001549  1  28                   plp
00154A  1  95 0C                sta zpt,x
00154C  1  08                   php         ;flags after load/store sequence
00154D  1  49 C3                eor #$c3
00154F  1  D5 13                cmp zp1,x   ;test result
001551  1  D0 FE                trap_ne
001553  1  68                   pla         ;load status
001554  1  49 30                eor_flag 0
001556  1  DD 1C 02             cmp fLDx,x  ;test flags
001559  1  D0 FE                trap_ne
00155B  1  CA                   dex
00155C  1  10 E1                bpl tldax2
00155E  1               
00155E  1  A2 03                ldx #3
001560  1               tldax3:
001560  1  A9 FF 48 28          set_stat $ff
001564  1  BD 17 02             lda abs1,x
001567  1  08                   php         ;test stores do not alter flags
001568  1  49 C3                eor #$c3
00156A  1  28                   plp
00156B  1  95 0C                sta zpt,x
00156D  1  08                   php         ;flags after load/store sequence
00156E  1  49 C3                eor #$c3
001570  1  D5 13                cmp zp1,x   ;test result
001572  1  D0 FE                trap_ne
001574  1  68                   pla         ;load status
001575  1  49 7D                eor_flag <~fnz ;mask bits not altered
001577  1  DD 1C 02             cmp fLDx,x  ;test flags
00157A  1  D0 FE                trap_ne
00157C  1  CA                   dex
00157D  1  10 E1                bpl tldax3
00157F  1               
00157F  1  A2 03                ldx #3      ;testing store result
001581  1  A0 00                ldy #0
001583  1  B5 0C        tstax:  lda zpt,x
001585  1  49 C3                eor #$c3
001587  1  D5 13                cmp zp1,x
001589  1  D0 FE                trap_ne     ;store to zp,x data
00158B  1  94 0C                sty zpt,x   ;clear
00158D  1  BD 03 02             lda abst,x
001590  1  49 C3                eor #$c3
001592  1  DD 17 02             cmp abs1,x
001595  1  D0 FE                trap_ne     ;store to abs,x data
001597  1  8A                   txa
001598  1  9D 03 02             sta abst,x  ;clear
00159B  1  CA                   dex
00159C  1  10 E5                bpl tstax
00159E  1  AD 00 02 C9          next_test
0015A2  1  15 D0 FE A9  
0015A6  1  16 8D 00 02  
0015AA  1               
0015AA  1               ; LDA / STA - (zp),y / abs,y / (zp,x)
0015AA  1  A0 03                ldy #3
0015AC  1               tlday:
0015AC  1  A9 00 48 28          set_stat 0
0015B0  1  B1 24                lda (ind1),y
0015B2  1  08                   php         ;test stores do not alter flags
0015B3  1  49 C3                eor #$c3
0015B5  1  28                   plp
0015B6  1  99 03 02             sta abst,y
0015B9  1  08                   php         ;flags after load/store sequence
0015BA  1  49 C3                eor #$c3
0015BC  1  D9 17 02             cmp abs1,y  ;test result
0015BF  1  D0 FE                trap_ne
0015C1  1  68                   pla         ;load status
0015C2  1  49 30                eor_flag 0
0015C4  1  D9 1C 02             cmp fLDx,y  ;test flags
0015C7  1  D0 FE                trap_ne
0015C9  1  88                   dey
0015CA  1  10 E0                bpl tlday
0015CC  1               
0015CC  1  A0 03                ldy #3
0015CE  1               tlday1:
0015CE  1  A9 FF 48 28          set_stat $ff
0015D2  1  B1 24                lda (ind1),y
0015D4  1  08                   php         ;test stores do not alter flags
0015D5  1  49 C3                eor #$c3
0015D7  1  28                   plp
0015D8  1  99 03 02             sta abst,y
0015DB  1  08                   php         ;flags after load/store sequence
0015DC  1  49 C3                eor #$c3
0015DE  1  D9 17 02             cmp abs1,y  ;test result
0015E1  1  D0 FE                trap_ne
0015E3  1  68                   pla         ;load status
0015E4  1  49 7D                eor_flag <~fnz ;mask bits not altered
0015E6  1  D9 1C 02             cmp fLDx,y  ;test flags
0015E9  1  D0 FE                trap_ne
0015EB  1  88                   dey
0015EC  1  10 E0                bpl tlday1
0015EE  1               
0015EE  1  A0 03                ldy #3      ;testing store result
0015F0  1  A2 00                ldx #0
0015F2  1  B9 03 02     tstay:  lda abst,y
0015F5  1  49 C3                eor #$c3
0015F7  1  D9 17 02             cmp abs1,y
0015FA  1  D0 FE                trap_ne     ;store to abs data
0015FC  1  8A                   txa
0015FD  1  99 03 02             sta abst,y  ;clear
001600  1  88                   dey
001601  1  10 EF                bpl tstay
001603  1               
001603  1  A0 03                ldy #3
001605  1               tlday2:
001605  1  A9 00 48 28          set_stat 0
001609  1  B9 17 02             lda abs1,y
00160C  1  08                   php         ;test stores do not alter flags
00160D  1  49 C3                eor #$c3
00160F  1  28                   plp
001610  1  91 30                sta (indt),y
001612  1  08                   php         ;flags after load/store sequence
001613  1  49 C3                eor #$c3
001615  1  D1 24                cmp (ind1),y    ;test result
001617  1  D0 FE                trap_ne
001619  1  68                   pla         ;load status
00161A  1  49 30                eor_flag 0
00161C  1  D9 1C 02             cmp fLDx,y  ;test flags
00161F  1  D0 FE                trap_ne
001621  1  88                   dey
001622  1  10 E1                bpl tlday2
001624  1               
001624  1  A0 03                ldy #3
001626  1               tlday3:
001626  1  A9 FF 48 28          set_stat $ff
00162A  1  B9 17 02             lda abs1,y
00162D  1  08                   php         ;test stores do not alter flags
00162E  1  49 C3                eor #$c3
001630  1  28                   plp
001631  1  91 30                sta (indt),y
001633  1  08                   php         ;flags after load/store sequence
001634  1  49 C3                eor #$c3
001636  1  D1 24                cmp (ind1),y   ;test result
001638  1  D0 FE                trap_ne
00163A  1  68                   pla         ;load status
00163B  1  49 7D                eor_flag <~fnz ;mask bits not altered
00163D  1  D9 1C 02             cmp fLDx,y  ;test flags
001640  1  D0 FE                trap_ne
001642  1  88                   dey
001643  1  10 E1                bpl tlday3
001645  1               
001645  1  A0 03                ldy #3      ;testing store result
001647  1  A2 00                ldx #0
001649  1  B9 03 02     tstay1: lda abst,y
00164C  1  49 C3                eor #$c3
00164E  1  D9 17 02             cmp abs1,y
001651  1  D0 FE                trap_ne     ;store to abs data
001653  1  8A                   txa
001654  1  99 03 02             sta abst,y  ;clear
001657  1  88                   dey
001658  1  10 EF                bpl tstay1
00165A  1               
00165A  1  A2 06                ldx #6
00165C  1  A0 03                ldy #3
00165E  1               tldax4:
00165E  1  A9 00 48 28          set_stat 0
001662  1  A1 24                lda (ind1,x)
001664  1  08                   php         ;test stores do not alter flags
001665  1  49 C3                eor #$c3
001667  1  28                   plp
001668  1  81 30                sta (indt,x)
00166A  1  08                   php         ;flags after load/store sequence
00166B  1  49 C3                eor #$c3
00166D  1  D9 17 02             cmp abs1,y  ;test result
001670  1  D0 FE                trap_ne
001672  1  68                   pla         ;load status
001673  1  49 30                eor_flag 0
001675  1  D9 1C 02             cmp fLDx,y  ;test flags
001678  1  D0 FE                trap_ne
00167A  1  CA                   dex
00167B  1  CA                   dex
00167C  1  88                   dey
00167D  1  10 DF                bpl tldax4
00167F  1               
00167F  1  A2 06                ldx #6
001681  1  A0 03                ldy #3
001683  1               tldax5:
001683  1  A9 FF 48 28          set_stat $ff
001687  1  A1 24                lda (ind1,x)
001689  1  08                   php         ;test stores do not alter flags
00168A  1  49 C3                eor #$c3
00168C  1  28                   plp
00168D  1  81 30                sta (indt,x)
00168F  1  08                   php         ;flags after load/store sequence
001690  1  49 C3                eor #$c3
001692  1  D9 17 02             cmp abs1,y  ;test result
001695  1  D0 FE                trap_ne
001697  1  68                   pla         ;load status
001698  1  49 7D                eor_flag <~fnz ;mask bits not altered
00169A  1  D9 1C 02             cmp fLDx,y  ;test flags
00169D  1  D0 FE                trap_ne
00169F  1  CA                   dex
0016A0  1  CA                   dex
0016A1  1  88                   dey
0016A2  1  10 DF                bpl tldax5
0016A4  1               
0016A4  1  A0 03                ldy #3      ;testing store result
0016A6  1  A2 00                ldx #0
0016A8  1  B9 03 02     tstay2: lda abst,y
0016AB  1  49 C3                eor #$c3
0016AD  1  D9 17 02             cmp abs1,y
0016B0  1  D0 FE                trap_ne     ;store to abs data
0016B2  1  8A                   txa
0016B3  1  99 03 02             sta abst,y  ;clear
0016B6  1  88                   dey
0016B7  1  10 EF                bpl tstay2
0016B9  1  AD 00 02 C9          next_test
0016BD  1  16 D0 FE A9  
0016C1  1  17 8D 00 02  
0016C5  1               
0016C5  1               ; indexed wraparound test (only zp should wrap)
0016C5  1  A2 FD                ldx #3+$fa
0016C7  1  B5 19        tldax6: lda <(zp1-$fa),x   ;wrap on indexed zp
0016C9  1  9D 09 01             sta abst-$fa,x      ;no STX abs,x!
0016CC  1  CA                   dex
0016CD  1  E0 FA                cpx #$fa
0016CF  1  B0 F6                bcs tldax6
0016D1  1  A2 FD                ldx #3+$fa
0016D3  1  BD 1D 01     tldax7: lda abs1-$fa,x      ;no wrap on indexed abs
0016D6  1  95 12                sta <(zpt-$fa),x
0016D8  1  CA                   dex
0016D9  1  E0 FA                cpx #$fa
0016DB  1  B0 F6                bcs tldax7
0016DD  1               
0016DD  1  A2 03                ldx #3      ;testing wraparound result
0016DF  1  A0 00                ldy #0
0016E1  1  B5 0C        tstax1: lda zpt,x
0016E3  1  D5 13                cmp zp1,x
0016E5  1  D0 FE                trap_ne     ;store to zp,x data
0016E7  1  94 0C                sty zpt,x   ;clear
0016E9  1  BD 03 02             lda abst,x
0016EC  1  DD 17 02             cmp abs1,x
0016EF  1  D0 FE                trap_ne     ;store to abs,x data
0016F1  1  8A                   txa
0016F2  1  9D 03 02             sta abst,x  ;clear
0016F5  1  CA                   dex
0016F6  1  10 E9                bpl tstax1
0016F8  1               
0016F8  1  A0 FB                ldy #3+$f8
0016FA  1  A2 FE                ldx #6+$f8
0016FC  1  A1 2C        tlday4: lda (<(ind1-$f8),x) ;wrap on indexed zp indirect
0016FE  1  99 0B 01             sta abst-$f8,y
001701  1  CA                   dex
001702  1  CA                   dex
001703  1  88                   dey
001704  1  C0 F8                cpy #$f8
001706  1  B0 F4                bcs tlday4
001708  1  A0 03                ldy #3      ;testing wraparound result
00170A  1  A2 00                ldx #0
00170C  1  B9 03 02     tstay4: lda abst,y
00170F  1  D9 17 02             cmp abs1,y
001712  1  D0 FE                trap_ne     ;store to abs data
001714  1  8A                   txa
001715  1  99 03 02             sta abst,y  ;clear
001718  1  88                   dey
001719  1  10 F1                bpl tstay4
00171B  1               
00171B  1  A0 FB                ldy #3+$f8
00171D  1  B9 1F 01     tlday5: lda abs1-$f8,y  ;no wrap on indexed abs
001720  1  91 38                sta (inwt),y
001722  1  88                   dey
001723  1  C0 F8                cpy #$f8
001725  1  B0 F6                bcs tlday5
001727  1  A0 03                ldy #3      ;testing wraparound result
001729  1  A2 00                ldx #0
00172B  1  B9 03 02     tstay5: lda abst,y
00172E  1  D9 17 02             cmp abs1,y
001731  1  D0 FE                trap_ne     ;store to abs data
001733  1  8A                   txa
001734  1  99 03 02             sta abst,y  ;clear
001737  1  88                   dey
001738  1  10 F1                bpl tstay5
00173A  1               
00173A  1  A0 FB                ldy #3+$f8
00173C  1  A2 FE                ldx #6+$f8
00173E  1  B1 2E        tlday6: lda (inw1),y    ;no wrap on zp indirect indexed
001740  1  81 38                sta (<(indt-$f8),x)
001742  1  CA                   dex
001743  1  CA                   dex
001744  1  88                   dey
001745  1  C0 F8                cpy #$f8
001747  1  B0 F5                bcs tlday6
001749  1  A0 03                ldy #3      ;testing wraparound result
00174B  1  A2 00                ldx #0
00174D  1  B9 03 02     tstay6: lda abst,y
001750  1  D9 17 02             cmp abs1,y
001753  1  D0 FE                trap_ne     ;store to abs data
001755  1  8A                   txa
001756  1  99 03 02             sta abst,y  ;clear
001759  1  88                   dey
00175A  1  10 F1                bpl tstay6
00175C  1  AD 00 02 C9          next_test
001760  1  17 D0 FE A9  
001764  1  18 8D 00 02  
001768  1               
001768  1               ; LDA / STA - zp / abs / #
001768  1  A9 00 48 28          set_stat 0
00176C  1  A5 13                lda zp1
00176E  1  08                   php         ;test stores do not alter flags
00176F  1  49 C3                eor #$c3
001771  1  28                   plp
001772  1  8D 03 02             sta abst
001775  1  08                   php         ;flags after load/store sequence
001776  1  49 C3                eor #$c3
001778  1  C9 C3                cmp #$c3    ;test result
00177A  1  D0 FE                trap_ne
00177C  1  68                   pla         ;load status
00177D  1  49 30                eor_flag 0
00177F  1  CD 1C 02             cmp fLDx    ;test flags
001782  1  D0 FE                trap_ne
001784  1  A9 00 48 28          set_stat 0
001788  1  A5 14                lda zp1+1
00178A  1  08                   php         ;test stores do not alter flags
00178B  1  49 C3                eor #$c3
00178D  1  28                   plp
00178E  1  8D 04 02             sta abst+1
001791  1  08                   php         ;flags after load/store sequence
001792  1  49 C3                eor #$c3
001794  1  C9 82                cmp #$82    ;test result
001796  1  D0 FE                trap_ne
001798  1  68                   pla         ;load status
001799  1  49 30                eor_flag 0
00179B  1  CD 1D 02             cmp fLDx+1  ;test flags
00179E  1  D0 FE                trap_ne
0017A0  1  A9 00 48 28          set_stat 0
0017A4  1  A5 15                lda zp1+2
0017A6  1  08                   php         ;test stores do not alter flags
0017A7  1  49 C3                eor #$c3
0017A9  1  28                   plp
0017AA  1  8D 05 02             sta abst+2
0017AD  1  08                   php         ;flags after load/store sequence
0017AE  1  49 C3                eor #$c3
0017B0  1  C9 41                cmp #$41    ;test result
0017B2  1  D0 FE                trap_ne
0017B4  1  68                   pla         ;load status
0017B5  1  49 30                eor_flag 0
0017B7  1  CD 1E 02             cmp fLDx+2  ;test flags
0017BA  1  D0 FE                trap_ne
0017BC  1  A9 00 48 28          set_stat 0
0017C0  1  A5 16                lda zp1+3
0017C2  1  08                   php         ;test stores do not alter flags
0017C3  1  49 C3                eor #$c3
0017C5  1  28                   plp
0017C6  1  8D 06 02             sta abst+3
0017C9  1  08                   php         ;flags after load/store sequence
0017CA  1  49 C3                eor #$c3
0017CC  1  C9 00                cmp #0      ;test result
0017CE  1  D0 FE                trap_ne
0017D0  1  68                   pla         ;load status
0017D1  1  49 30                eor_flag 0
0017D3  1  CD 1F 02             cmp fLDx+3  ;test flags
0017D6  1  D0 FE                trap_ne
0017D8  1  A9 FF 48 28          set_stat $ff
0017DC  1  A5 13                lda zp1
0017DE  1  08                   php         ;test stores do not alter flags
0017DF  1  49 C3                eor #$c3
0017E1  1  28                   plp
0017E2  1  8D 03 02             sta abst
0017E5  1  08                   php         ;flags after load/store sequence
0017E6  1  49 C3                eor #$c3
0017E8  1  C9 C3                cmp #$c3    ;test result
0017EA  1  D0 FE                trap_ne
0017EC  1  68                   pla         ;load status
0017ED  1  49 7D                eor_flag <~fnz ;mask bits not altered
0017EF  1  CD 1C 02             cmp fLDx    ;test flags
0017F2  1  D0 FE                trap_ne
0017F4  1  A9 FF 48 28          set_stat $ff
0017F8  1  A5 14                lda zp1+1
0017FA  1  08                   php         ;test stores do not alter flags
0017FB  1  49 C3                eor #$c3
0017FD  1  28                   plp
0017FE  1  8D 04 02             sta abst+1
001801  1  08                   php         ;flags after load/store sequence
001802  1  49 C3                eor #$c3
001804  1  C9 82                cmp #$82    ;test result
001806  1  D0 FE                trap_ne
001808  1  68                   pla         ;load status
001809  1  49 7D                eor_flag <~fnz ;mask bits not altered
00180B  1  CD 1D 02             cmp fLDx+1  ;test flags
00180E  1  D0 FE                trap_ne
001810  1  A9 FF 48 28          set_stat $ff
001814  1  A5 15                lda zp1+2
001816  1  08                   php         ;test stores do not alter flags
001817  1  49 C3                eor #$c3
001819  1  28                   plp
00181A  1  8D 05 02             sta abst+2
00181D  1  08                   php         ;flags after load/store sequence
00181E  1  49 C3                eor #$c3
001820  1  C9 41                cmp #$41    ;test result
001822  1  D0 FE                trap_ne
001824  1  68                   pla         ;load status
001825  1  49 7D                eor_flag <~fnz ;mask bits not altered
001827  1  CD 1E 02             cmp fLDx+2  ;test flags
00182A  1  D0 FE                trap_ne
00182C  1  A9 FF 48 28          set_stat $ff
001830  1  A5 16                lda zp1+3
001832  1  08                   php         ;test stores do not alter flags
001833  1  49 C3                eor #$c3
001835  1  28                   plp
001836  1  8D 06 02             sta abst+3
001839  1  08                   php         ;flags after load/store sequence
00183A  1  49 C3                eor #$c3
00183C  1  C9 00                cmp #0      ;test result
00183E  1  D0 FE                trap_ne
001840  1  68                   pla         ;load status
001841  1  49 7D                eor_flag <~fnz ;mask bits not altered
001843  1  CD 1F 02             cmp fLDx+3  ;test flags
001846  1  D0 FE                trap_ne
001848  1  A9 00 48 28          set_stat 0
00184C  1  AD 17 02             lda abs1
00184F  1  08                   php         ;test stores do not alter flags
001850  1  49 C3                eor #$c3
001852  1  28                   plp
001853  1  85 0C                sta zpt
001855  1  08                   php         ;flags after load/store sequence
001856  1  49 C3                eor #$c3
001858  1  C5 13                cmp zp1     ;test result
00185A  1  D0 FE                trap_ne
00185C  1  68                   pla         ;load status
00185D  1  49 30                eor_flag 0
00185F  1  CD 1C 02             cmp fLDx    ;test flags
001862  1  D0 FE                trap_ne
001864  1  A9 00 48 28          set_stat 0
001868  1  AD 18 02             lda abs1+1
00186B  1  08                   php         ;test stores do not alter flags
00186C  1  49 C3                eor #$c3
00186E  1  28                   plp
00186F  1  85 0D                sta zpt+1
001871  1  08                   php         ;flags after load/store sequence
001872  1  49 C3                eor #$c3
001874  1  C5 14                cmp zp1+1   ;test result
001876  1  D0 FE                trap_ne
001878  1  68                   pla         ;load status
001879  1  49 30                eor_flag 0
00187B  1  CD 1D 02             cmp fLDx+1  ;test flags
00187E  1  D0 FE                trap_ne
001880  1  A9 00 48 28          set_stat 0
001884  1  AD 19 02             lda abs1+2
001887  1  08                   php         ;test stores do not alter flags
001888  1  49 C3                eor #$c3
00188A  1  28                   plp
00188B  1  85 0E                sta zpt+2
00188D  1  08                   php         ;flags after load/store sequence
00188E  1  49 C3                eor #$c3
001890  1  C5 15                cmp zp1+2   ;test result
001892  1  D0 FE                trap_ne
001894  1  68                   pla         ;load status
001895  1  49 30                eor_flag 0
001897  1  CD 1E 02             cmp fLDx+2  ;test flags
00189A  1  D0 FE                trap_ne
00189C  1  A9 00 48 28          set_stat 0
0018A0  1  AD 1A 02             lda abs1+3
0018A3  1  08                   php         ;test stores do not alter flags
0018A4  1  49 C3                eor #$c3
0018A6  1  28                   plp
0018A7  1  85 0F                sta zpt+3
0018A9  1  08                   php         ;flags after load/store sequence
0018AA  1  49 C3                eor #$c3
0018AC  1  C5 16                cmp zp1+3   ;test result
0018AE  1  D0 FE                trap_ne
0018B0  1  68                   pla         ;load status
0018B1  1  49 30                eor_flag 0
0018B3  1  CD 1F 02             cmp fLDx+3  ;test flags
0018B6  1  D0 FE                trap_ne
0018B8  1  A9 FF 48 28          set_stat $ff
0018BC  1  AD 17 02             lda abs1
0018BF  1  08                   php         ;test stores do not alter flags
0018C0  1  49 C3                eor #$c3
0018C2  1  28                   plp
0018C3  1  85 0C                sta zpt
0018C5  1  08                   php         ;flags after load/store sequence
0018C6  1  49 C3                eor #$c3
0018C8  1  C5 13                cmp zp1     ;test result
0018CA  1  D0 FE                trap_ne
0018CC  1  68                   pla         ;load status
0018CD  1  49 7D                eor_flag <~fnz ;mask bits not altered
0018CF  1  CD 1C 02             cmp fLDx    ;test flags
0018D2  1  D0 FE                trap_ne
0018D4  1  A9 FF 48 28          set_stat $ff
0018D8  1  AD 18 02             lda abs1+1
0018DB  1  08                   php         ;test stores do not alter flags
0018DC  1  49 C3                eor #$c3
0018DE  1  28                   plp
0018DF  1  85 0D                sta zpt+1
0018E1  1  08                   php         ;flags after load/store sequence
0018E2  1  49 C3                eor #$c3
0018E4  1  C5 14                cmp zp1+1   ;test result
0018E6  1  D0 FE                trap_ne
0018E8  1  68                   pla         ;load status
0018E9  1  49 7D                eor_flag <~fnz ;mask bits not altered
0018EB  1  CD 1D 02             cmp fLDx+1  ;test flags
0018EE  1  D0 FE                trap_ne
0018F0  1  A9 FF 48 28          set_stat $ff
0018F4  1  AD 19 02             lda abs1+2
0018F7  1  08                   php         ;test stores do not alter flags
0018F8  1  49 C3                eor #$c3
0018FA  1  28                   plp
0018FB  1  85 0E                sta zpt+2
0018FD  1  08                   php         ;flags after load/store sequence
0018FE  1  49 C3                eor #$c3
001900  1  C5 15                cmp zp1+2   ;test result
001902  1  D0 FE                trap_ne
001904  1  68                   pla         ;load status
001905  1  49 7D                eor_flag <~fnz ;mask bits not altered
001907  1  CD 1E 02             cmp fLDx+2  ;test flags
00190A  1  D0 FE                trap_ne
00190C  1  A9 FF 48 28          set_stat $ff
001910  1  AD 1A 02             lda abs1+3
001913  1  08                   php         ;test stores do not alter flags
001914  1  49 C3                eor #$c3
001916  1  28                   plp
001917  1  85 0F                sta zpt+3
001919  1  08                   php         ;flags after load/store sequence
00191A  1  49 C3                eor #$c3
00191C  1  C5 16                cmp zp1+3   ;test result
00191E  1  D0 FE                trap_ne
001920  1  68                   pla         ;load status
001921  1  49 7D                eor_flag <~fnz ;mask bits not altered
001923  1  CD 1F 02             cmp fLDx+3  ;test flags
001926  1  D0 FE                trap_ne
001928  1  A9 00 48 28          set_stat 0
00192C  1  A9 C3                lda #$c3
00192E  1  08                   php
00192F  1  CD 17 02             cmp abs1    ;test result
001932  1  D0 FE                trap_ne
001934  1  68                   pla         ;load status
001935  1  49 30                eor_flag 0
001937  1  CD 1C 02             cmp fLDx    ;test flags
00193A  1  D0 FE                trap_ne
00193C  1  A9 00 48 28          set_stat 0
001940  1  A9 82                lda #$82
001942  1  08                   php
001943  1  CD 18 02             cmp abs1+1  ;test result
001946  1  D0 FE                trap_ne
001948  1  68                   pla         ;load status
001949  1  49 30                eor_flag 0
00194B  1  CD 1D 02             cmp fLDx+1  ;test flags
00194E  1  D0 FE                trap_ne
001950  1  A9 00 48 28          set_stat 0
001954  1  A9 41                lda #$41
001956  1  08                   php
001957  1  CD 19 02             cmp abs1+2  ;test result
00195A  1  D0 FE                trap_ne
00195C  1  68                   pla         ;load status
00195D  1  49 30                eor_flag 0
00195F  1  CD 1E 02             cmp fLDx+2  ;test flags
001962  1  D0 FE                trap_ne
001964  1  A9 00 48 28          set_stat 0
001968  1  A9 00                lda #0
00196A  1  08                   php
00196B  1  CD 1A 02             cmp abs1+3  ;test result
00196E  1  D0 FE                trap_ne
001970  1  68                   pla         ;load status
001971  1  49 30                eor_flag 0
001973  1  CD 1F 02             cmp fLDx+3  ;test flags
001976  1  D0 FE                trap_ne
001978  1               
001978  1  A9 FF 48 28          set_stat $ff
00197C  1  A9 C3                lda #$c3
00197E  1  08                   php
00197F  1  CD 17 02             cmp abs1    ;test result
001982  1  D0 FE                trap_ne
001984  1  68                   pla         ;load status
001985  1  49 7D                eor_flag <~fnz ;mask bits not altered
001987  1  CD 1C 02             cmp fLDx    ;test flags
00198A  1  D0 FE                trap_ne
00198C  1  A9 FF 48 28          set_stat $ff
001990  1  A9 82                lda #$82
001992  1  08                   php
001993  1  CD 18 02             cmp abs1+1  ;test result
001996  1  D0 FE                trap_ne
001998  1  68                   pla         ;load status
001999  1  49 7D                eor_flag <~fnz ;mask bits not altered
00199B  1  CD 1D 02             cmp fLDx+1  ;test flags
00199E  1  D0 FE                trap_ne
0019A0  1  A9 FF 48 28          set_stat $ff
0019A4  1  A9 41                lda #$41
0019A6  1  08                   php
0019A7  1  CD 19 02             cmp abs1+2  ;test result
0019AA  1  D0 FE                trap_ne
0019AC  1  68                   pla         ;load status
0019AD  1  49 7D                eor_flag <~fnz ;mask bits not altered
0019AF  1  CD 1E 02             cmp fLDx+2  ;test flags
0019B2  1  D0 FE                trap_ne
0019B4  1  A9 FF 48 28          set_stat $ff
0019B8  1  A9 00                lda #0
0019BA  1  08                   php
0019BB  1  CD 1A 02             cmp abs1+3  ;test result
0019BE  1  D0 FE                trap_ne
0019C0  1  68                   pla         ;load status
0019C1  1  49 7D                eor_flag <~fnz ;mask bits not altered
0019C3  1  CD 1F 02             cmp fLDx+3  ;test flags
0019C6  1  D0 FE                trap_ne
0019C8  1               
0019C8  1  A2 00                ldx #0
0019CA  1  A5 0C                lda zpt
0019CC  1  49 C3                eor #$c3
0019CE  1  C5 13                cmp zp1
0019D0  1  D0 FE                trap_ne     ;store to zp data
0019D2  1  86 0C                stx zpt     ;clear
0019D4  1  AD 03 02             lda abst
0019D7  1  49 C3                eor #$c3
0019D9  1  CD 17 02             cmp abs1
0019DC  1  D0 FE                trap_ne     ;store to abs data
0019DE  1  8E 03 02             stx abst    ;clear
0019E1  1  A5 0D                lda zpt+1
0019E3  1  49 C3                eor #$c3
0019E5  1  C5 14                cmp zp1+1
0019E7  1  D0 FE                trap_ne     ;store to zp data
0019E9  1  86 0D                stx zpt+1   ;clear
0019EB  1  AD 04 02             lda abst+1
0019EE  1  49 C3                eor #$c3
0019F0  1  CD 18 02             cmp abs1+1
0019F3  1  D0 FE                trap_ne     ;store to abs data
0019F5  1  8E 04 02             stx abst+1  ;clear
0019F8  1  A5 0E                lda zpt+2
0019FA  1  49 C3                eor #$c3
0019FC  1  C5 15                cmp zp1+2
0019FE  1  D0 FE                trap_ne     ;store to zp data
001A00  1  86 0E                stx zpt+2   ;clear
001A02  1  AD 05 02             lda abst+2
001A05  1  49 C3                eor #$c3
001A07  1  CD 19 02             cmp abs1+2
001A0A  1  D0 FE                trap_ne     ;store to abs data
001A0C  1  8E 05 02             stx abst+2  ;clear
001A0F  1  A5 0F                lda zpt+3
001A11  1  49 C3                eor #$c3
001A13  1  C5 16                cmp zp1+3
001A15  1  D0 FE                trap_ne     ;store to zp data
001A17  1  86 0F                stx zpt+3   ;clear
001A19  1  AD 06 02             lda abst+3
001A1C  1  49 C3                eor #$c3
001A1E  1  CD 1A 02             cmp abs1+3
001A21  1  D0 FE                trap_ne     ;store to abs data
001A23  1  8E 06 02             stx abst+3  ;clear
001A26  1  AD 00 02 C9          next_test
001A2A  1  18 D0 FE A9  
001A2E  1  19 8D 00 02  
001A32  1               
001A32  1               ; testing bit test & compares BIT CPX CPY CMP all addressing modes
001A32  1               ; BIT - zp / abs
001A32  1  A9 00 48 A9          set_a $ff,0
001A36  1  FF 28        
001A38  1  24 16                bit zp1+3   ;00 - should set Z / clear  NV
001A3A  1  08 C9 FF D0          tst_a $ff,fz
001A3E  1  FE 68 48 C9  
001A42  1  32 D0 FE 28  
001A46  1  A9 00 48 A9          set_a 1,0
001A4A  1  01 28        
001A4C  1  24 15                bit zp1+2   ;41 - should set V (M6) / clear NZ
001A4E  1  08 C9 01 D0          tst_a 1,fv
001A52  1  FE 68 48 C9  
001A56  1  70 D0 FE 28  
001A5A  1  A9 00 48 A9          set_a 1,0
001A5E  1  01 28        
001A60  1  24 14                bit zp1+1   ;82 - should set N (M7) & Z / clear V
001A62  1  08 C9 01 D0          tst_a 1,fnz
001A66  1  FE 68 48 C9  
001A6A  1  B2 D0 FE 28  
001A6E  1  A9 00 48 A9          set_a 1,0
001A72  1  01 28        
001A74  1  24 13                bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
001A76  1  08 C9 01 D0          tst_a 1,fnv
001A7A  1  FE 68 48 C9  
001A7E  1  F0 D0 FE 28  
001A82  1               
001A82  1  A9 FF 48 A9          set_a $ff,$ff
001A86  1  FF 28        
001A88  1  24 16                bit zp1+3   ;00 - should set Z / clear  NV
001A8A  1  08 C9 FF D0          tst_a $ff,~fnv
001A8E  1  FE 68 48 C9  
001A92  1  3F D0 FE 28  
001A96  1  A9 FF 48 A9          set_a 1,$ff
001A9A  1  01 28        
001A9C  1  24 15                bit zp1+2   ;41 - should set V (M6) / clear NZ
001A9E  1  08 C9 01 D0          tst_a 1,~fnz
001AA2  1  FE 68 48 C9  
001AA6  1  7D D0 FE 28  
001AAA  1  A9 FF 48 A9          set_a 1,$ff
001AAE  1  01 28        
001AB0  1  24 14                bit zp1+1   ;82 - should set N (M7) & Z / clear V
001AB2  1  08 C9 01 D0          tst_a 1,~fv
001AB6  1  FE 68 48 C9  
001ABA  1  BF D0 FE 28  
001ABE  1  A9 FF 48 A9          set_a 1,$ff
001AC2  1  01 28        
001AC4  1  24 13                bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
001AC6  1  08 C9 01 D0          tst_a 1,~fz
001ACA  1  FE 68 48 C9  
001ACE  1  FD D0 FE 28  
001AD2  1               
001AD2  1  A9 00 48 A9          set_a $ff,0
001AD6  1  FF 28        
001AD8  1  2C 1A 02             bit abs1+3  ;00 - should set Z / clear  NV
001ADB  1  08 C9 FF D0          tst_a $ff,fz
001ADF  1  FE 68 48 C9  
001AE3  1  32 D0 FE 28  
001AE7  1  A9 00 48 A9          set_a 1,0
001AEB  1  01 28        
001AED  1  2C 19 02             bit abs1+2  ;41 - should set V (M6) / clear NZ
001AF0  1  08 C9 01 D0          tst_a 1,fv
001AF4  1  FE 68 48 C9  
001AF8  1  70 D0 FE 28  
001AFC  1  A9 00 48 A9          set_a 1,0
001B00  1  01 28        
001B02  1  2C 18 02             bit abs1+1  ;82 - should set N (M7) & Z / clear V
001B05  1  08 C9 01 D0          tst_a 1,fnz
001B09  1  FE 68 48 C9  
001B0D  1  B2 D0 FE 28  
001B11  1  A9 00 48 A9          set_a 1,0
001B15  1  01 28        
001B17  1  2C 17 02             bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
001B1A  1  08 C9 01 D0          tst_a 1,fnv
001B1E  1  FE 68 48 C9  
001B22  1  F0 D0 FE 28  
001B26  1               
001B26  1  A9 FF 48 A9          set_a $ff,$ff
001B2A  1  FF 28        
001B2C  1  2C 1A 02             bit abs1+3  ;00 - should set Z / clear  NV
001B2F  1  08 C9 FF D0          tst_a $ff,~fnv
001B33  1  FE 68 48 C9  
001B37  1  3F D0 FE 28  
001B3B  1  A9 FF 48 A9          set_a 1,$ff
001B3F  1  01 28        
001B41  1  2C 19 02             bit abs1+2  ;41 - should set V (M6) / clear NZ
001B44  1  08 C9 01 D0          tst_a 1,~fnz
001B48  1  FE 68 48 C9  
001B4C  1  7D D0 FE 28  
001B50  1  A9 FF 48 A9          set_a 1,$ff
001B54  1  01 28        
001B56  1  2C 18 02             bit abs1+1  ;82 - should set N (M7) & Z / clear V
001B59  1  08 C9 01 D0          tst_a 1,~fv
001B5D  1  FE 68 48 C9  
001B61  1  BF D0 FE 28  
001B65  1  A9 FF 48 A9          set_a 1,$ff
001B69  1  01 28        
001B6B  1  2C 17 02             bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
001B6E  1  08 C9 01 D0          tst_a 1,~fz
001B72  1  FE 68 48 C9  
001B76  1  FD D0 FE 28  
001B7A  1  AD 00 02 C9          next_test
001B7E  1  19 D0 FE A9  
001B82  1  1A 8D 00 02  
001B86  1               
001B86  1               ; CPX - zp / abs / #
001B86  1  A9 00 48 A2          set_x $80,0
001B8A  1  80 28        
001B8C  1  E4 17                cpx zp7f
001B8E  1  08 68 48 C9          tst_stat fc
001B92  1  31 D0 FE 28  
001B96  1  CA                   dex
001B97  1  E4 17                cpx zp7f
001B99  1  08 68 48 C9          tst_stat fzc
001B9D  1  33 D0 FE 28  
001BA1  1  CA                   dex
001BA2  1  E4 17                cpx zp7f
001BA4  1  08 E0 7E D0          tst_x $7e,fn
001BA8  1  FE 68 48 C9  
001BAC  1  B0 D0 FE 28  
001BB0  1  A9 FF 48 A2          set_x $80,$ff
001BB4  1  80 28        
001BB6  1  E4 17                cpx zp7f
001BB8  1  08 68 48 C9          tst_stat ~fnz
001BBC  1  7D D0 FE 28  
001BC0  1  CA                   dex
001BC1  1  E4 17                cpx zp7f
001BC3  1  08 68 48 C9          tst_stat ~fn
001BC7  1  7F D0 FE 28  
001BCB  1  CA                   dex
001BCC  1  E4 17                cpx zp7f
001BCE  1  08 E0 7E D0          tst_x $7e,~fzc
001BD2  1  FE 68 48 C9  
001BD6  1  FC D0 FE 28  
001BDA  1               
001BDA  1  A9 00 48 A2          set_x $80,0
001BDE  1  80 28        
001BE0  1  EC 1B 02             cpx abs7f
001BE3  1  08 68 48 C9          tst_stat fc
001BE7  1  31 D0 FE 28  
001BEB  1  CA                   dex
001BEC  1  EC 1B 02             cpx abs7f
001BEF  1  08 68 48 C9          tst_stat fzc
001BF3  1  33 D0 FE 28  
001BF7  1  CA                   dex
001BF8  1  EC 1B 02             cpx abs7f
001BFB  1  08 E0 7E D0          tst_x $7e,fn
001BFF  1  FE 68 48 C9  
001C03  1  B0 D0 FE 28  
001C07  1  A9 FF 48 A2          set_x $80,$ff
001C0B  1  80 28        
001C0D  1  EC 1B 02             cpx abs7f
001C10  1  08 68 48 C9          tst_stat ~fnz
001C14  1  7D D0 FE 28  
001C18  1  CA                   dex
001C19  1  EC 1B 02             cpx abs7f
001C1C  1  08 68 48 C9          tst_stat ~fn
001C20  1  7F D0 FE 28  
001C24  1  CA                   dex
001C25  1  EC 1B 02             cpx abs7f
001C28  1  08 E0 7E D0          tst_x $7e,~fzc
001C2C  1  FE 68 48 C9  
001C30  1  FC D0 FE 28  
001C34  1               
001C34  1  A9 00 48 A2          set_x $80,0
001C38  1  80 28        
001C3A  1  E0 7F                cpx #$7f
001C3C  1  08 68 48 C9          tst_stat fc
001C40  1  31 D0 FE 28  
001C44  1  CA                   dex
001C45  1  E0 7F                cpx #$7f
001C47  1  08 68 48 C9          tst_stat fzc
001C4B  1  33 D0 FE 28  
001C4F  1  CA                   dex
001C50  1  E0 7F                cpx #$7f
001C52  1  08 E0 7E D0          tst_x $7e,fn
001C56  1  FE 68 48 C9  
001C5A  1  B0 D0 FE 28  
001C5E  1  A9 FF 48 A2          set_x $80,$ff
001C62  1  80 28        
001C64  1  E0 7F                cpx #$7f
001C66  1  08 68 48 C9          tst_stat ~fnz
001C6A  1  7D D0 FE 28  
001C6E  1  CA                   dex
001C6F  1  E0 7F                cpx #$7f
001C71  1  08 68 48 C9          tst_stat ~fn
001C75  1  7F D0 FE 28  
001C79  1  CA                   dex
001C7A  1  E0 7F                cpx #$7f
001C7C  1  08 E0 7E D0          tst_x $7e,~fzc
001C80  1  FE 68 48 C9  
001C84  1  FC D0 FE 28  
001C88  1  AD 00 02 C9          next_test
001C8C  1  1A D0 FE A9  
001C90  1  1B 8D 00 02  
001C94  1               
001C94  1               ; CPY - zp / abs / #
001C94  1  A9 00 48 A0          set_y $80,0
001C98  1  80 28        
001C9A  1  C4 17                cpy zp7f
001C9C  1  08 68 48 C9          tst_stat fc
001CA0  1  31 D0 FE 28  
001CA4  1  88                   dey
001CA5  1  C4 17                cpy zp7f
001CA7  1  08 68 48 C9          tst_stat fzc
001CAB  1  33 D0 FE 28  
001CAF  1  88                   dey
001CB0  1  C4 17                cpy zp7f
001CB2  1  08 C0 7E D0          tst_y $7e,fn
001CB6  1  FE 68 48 C9  
001CBA  1  B0 D0 FE 28  
001CBE  1  A9 FF 48 A0          set_y $80,$ff
001CC2  1  80 28        
001CC4  1  C4 17                cpy zp7f
001CC6  1  08 68 48 C9          tst_stat ~fnz
001CCA  1  7D D0 FE 28  
001CCE  1  88                   dey
001CCF  1  C4 17                cpy zp7f
001CD1  1  08 68 48 C9          tst_stat ~fn
001CD5  1  7F D0 FE 28  
001CD9  1  88                   dey
001CDA  1  C4 17                cpy zp7f
001CDC  1  08 C0 7E D0          tst_y $7e,~fzc
001CE0  1  FE 68 48 C9  
001CE4  1  FC D0 FE 28  
001CE8  1               
001CE8  1  A9 00 48 A0          set_y $80,0
001CEC  1  80 28        
001CEE  1  CC 1B 02             cpy abs7f
001CF1  1  08 68 48 C9          tst_stat fc
001CF5  1  31 D0 FE 28  
001CF9  1  88                   dey
001CFA  1  CC 1B 02             cpy abs7f
001CFD  1  08 68 48 C9          tst_stat fzc
001D01  1  33 D0 FE 28  
001D05  1  88                   dey
001D06  1  CC 1B 02             cpy abs7f
001D09  1  08 C0 7E D0          tst_y $7e,fn
001D0D  1  FE 68 48 C9  
001D11  1  B0 D0 FE 28  
001D15  1  A9 FF 48 A0          set_y $80,$ff
001D19  1  80 28        
001D1B  1  CC 1B 02             cpy abs7f
001D1E  1  08 68 48 C9          tst_stat ~fnz
001D22  1  7D D0 FE 28  
001D26  1  88                   dey
001D27  1  CC 1B 02             cpy abs7f
001D2A  1  08 68 48 C9          tst_stat ~fn
001D2E  1  7F D0 FE 28  
001D32  1  88                   dey
001D33  1  CC 1B 02             cpy abs7f
001D36  1  08 C0 7E D0          tst_y $7e,~fzc
001D3A  1  FE 68 48 C9  
001D3E  1  FC D0 FE 28  
001D42  1               
001D42  1  A9 00 48 A0          set_y $80,0
001D46  1  80 28        
001D48  1  C0 7F                cpy #$7f
001D4A  1  08 68 48 C9          tst_stat fc
001D4E  1  31 D0 FE 28  
001D52  1  88                   dey
001D53  1  C0 7F                cpy #$7f
001D55  1  08 68 48 C9          tst_stat fzc
001D59  1  33 D0 FE 28  
001D5D  1  88                   dey
001D5E  1  C0 7F                cpy #$7f
001D60  1  08 C0 7E D0          tst_y $7e,fn
001D64  1  FE 68 48 C9  
001D68  1  B0 D0 FE 28  
001D6C  1  A9 FF 48 A0          set_y $80,$ff
001D70  1  80 28        
001D72  1  C0 7F                cpy #$7f
001D74  1  08 68 48 C9          tst_stat ~fnz
001D78  1  7D D0 FE 28  
001D7C  1  88                   dey
001D7D  1  C0 7F                cpy #$7f
001D7F  1  08 68 48 C9          tst_stat ~fn
001D83  1  7F D0 FE 28  
001D87  1  88                   dey
001D88  1  C0 7F                cpy #$7f
001D8A  1  08 C0 7E D0          tst_y $7e,~fzc
001D8E  1  FE 68 48 C9  
001D92  1  FC D0 FE 28  
001D96  1  AD 00 02 C9          next_test
001D9A  1  1B D0 FE A9  
001D9E  1  1C 8D 00 02  
001DA2  1               
001DA2  1               ; CMP - zp / abs / #
001DA2  1  A9 00 48 A9          set_a $80,0
001DA6  1  80 28        
001DA8  1  C5 17                cmp zp7f
001DAA  1  08 C9 80 D0          tst_a $80,fc
001DAE  1  FE 68 48 C9  
001DB2  1  31 D0 FE 28  
001DB6  1  A9 00 48 A9          set_a $7f,0
001DBA  1  7F 28        
001DBC  1  C5 17                cmp zp7f
001DBE  1  08 C9 7F D0          tst_a $7f,fzc
001DC2  1  FE 68 48 C9  
001DC6  1  33 D0 FE 28  
001DCA  1  A9 00 48 A9          set_a $7e,0
001DCE  1  7E 28        
001DD0  1  C5 17                cmp zp7f
001DD2  1  08 C9 7E D0          tst_a $7e,fn
001DD6  1  FE 68 48 C9  
001DDA  1  B0 D0 FE 28  
001DDE  1  A9 FF 48 A9          set_a $80,$ff
001DE2  1  80 28        
001DE4  1  C5 17                cmp zp7f
001DE6  1  08 C9 80 D0          tst_a $80,~fnz
001DEA  1  FE 68 48 C9  
001DEE  1  7D D0 FE 28  
001DF2  1  A9 FF 48 A9          set_a $7f,$ff
001DF6  1  7F 28        
001DF8  1  C5 17                cmp zp7f
001DFA  1  08 C9 7F D0          tst_a $7f,~fn
001DFE  1  FE 68 48 C9  
001E02  1  7F D0 FE 28  
001E06  1  A9 FF 48 A9          set_a $7e,$ff
001E0A  1  7E 28        
001E0C  1  C5 17                cmp zp7f
001E0E  1  08 C9 7E D0          tst_a $7e,~fzc
001E12  1  FE 68 48 C9  
001E16  1  FC D0 FE 28  
001E1A  1               
001E1A  1  A9 00 48 A9          set_a $80,0
001E1E  1  80 28        
001E20  1  CD 1B 02             cmp abs7f
001E23  1  08 C9 80 D0          tst_a $80,fc
001E27  1  FE 68 48 C9  
001E2B  1  31 D0 FE 28  
001E2F  1  A9 00 48 A9          set_a $7f,0
001E33  1  7F 28        
001E35  1  CD 1B 02             cmp abs7f
001E38  1  08 C9 7F D0          tst_a $7f,fzc
001E3C  1  FE 68 48 C9  
001E40  1  33 D0 FE 28  
001E44  1  A9 00 48 A9          set_a $7e,0
001E48  1  7E 28        
001E4A  1  CD 1B 02             cmp abs7f
001E4D  1  08 C9 7E D0          tst_a $7e,fn
001E51  1  FE 68 48 C9  
001E55  1  B0 D0 FE 28  
001E59  1  A9 FF 48 A9          set_a $80,$ff
001E5D  1  80 28        
001E5F  1  CD 1B 02             cmp abs7f
001E62  1  08 C9 80 D0          tst_a $80,~fnz
001E66  1  FE 68 48 C9  
001E6A  1  7D D0 FE 28  
001E6E  1  A9 FF 48 A9          set_a $7f,$ff
001E72  1  7F 28        
001E74  1  CD 1B 02             cmp abs7f
001E77  1  08 C9 7F D0          tst_a $7f,~fn
001E7B  1  FE 68 48 C9  
001E7F  1  7F D0 FE 28  
001E83  1  A9 FF 48 A9          set_a $7e,$ff
001E87  1  7E 28        
001E89  1  CD 1B 02             cmp abs7f
001E8C  1  08 C9 7E D0          tst_a $7e,~fzc
001E90  1  FE 68 48 C9  
001E94  1  FC D0 FE 28  
001E98  1               
001E98  1  A9 00 48 A9          set_a $80,0
001E9C  1  80 28        
001E9E  1  C9 7F                cmp #$7f
001EA0  1  08 C9 80 D0          tst_a $80,fc
001EA4  1  FE 68 48 C9  
001EA8  1  31 D0 FE 28  
001EAC  1  A9 00 48 A9          set_a $7f,0
001EB0  1  7F 28        
001EB2  1  C9 7F                cmp #$7f
001EB4  1  08 C9 7F D0          tst_a $7f,fzc
001EB8  1  FE 68 48 C9  
001EBC  1  33 D0 FE 28  
001EC0  1  A9 00 48 A9          set_a $7e,0
001EC4  1  7E 28        
001EC6  1  C9 7F                cmp #$7f
001EC8  1  08 C9 7E D0          tst_a $7e,fn
001ECC  1  FE 68 48 C9  
001ED0  1  B0 D0 FE 28  
001ED4  1  A9 FF 48 A9          set_a $80,$ff
001ED8  1  80 28        
001EDA  1  C9 7F                cmp #$7f
001EDC  1  08 C9 80 D0          tst_a $80,~fnz
001EE0  1  FE 68 48 C9  
001EE4  1  7D D0 FE 28  
001EE8  1  A9 FF 48 A9          set_a $7f,$ff
001EEC  1  7F 28        
001EEE  1  C9 7F                cmp #$7f
001EF0  1  08 C9 7F D0          tst_a $7f,~fn
001EF4  1  FE 68 48 C9  
001EF8  1  7F D0 FE 28  
001EFC  1  A9 FF 48 A9          set_a $7e,$ff
001F00  1  7E 28        
001F02  1  C9 7F                cmp #$7f
001F04  1  08 C9 7E D0          tst_a $7e,~fzc
001F08  1  FE 68 48 C9  
001F0C  1  FC D0 FE 28  
001F10  1               
001F10  1  A2 04                ldx #4          ;with indexing by X
001F12  1  A9 00 48 A9          set_a $80,0
001F16  1  80 28        
001F18  1  D5 13                cmp zp1,x
001F1A  1  08 C9 80 D0          tst_a $80,fc
001F1E  1  FE 68 48 C9  
001F22  1  31 D0 FE 28  
001F26  1  A9 00 48 A9          set_a $7f,0
001F2A  1  7F 28        
001F2C  1  D5 13                cmp zp1,x
001F2E  1  08 C9 7F D0          tst_a $7f,fzc
001F32  1  FE 68 48 C9  
001F36  1  33 D0 FE 28  
001F3A  1  A9 00 48 A9          set_a $7e,0
001F3E  1  7E 28        
001F40  1  D5 13                cmp zp1,x
001F42  1  08 C9 7E D0          tst_a $7e,fn
001F46  1  FE 68 48 C9  
001F4A  1  B0 D0 FE 28  
001F4E  1  A9 FF 48 A9          set_a $80,$ff
001F52  1  80 28        
001F54  1  D5 13                cmp zp1,x
001F56  1  08 C9 80 D0          tst_a $80,~fnz
001F5A  1  FE 68 48 C9  
001F5E  1  7D D0 FE 28  
001F62  1  A9 FF 48 A9          set_a $7f,$ff
001F66  1  7F 28        
001F68  1  D5 13                cmp zp1,x
001F6A  1  08 C9 7F D0          tst_a $7f,~fn
001F6E  1  FE 68 48 C9  
001F72  1  7F D0 FE 28  
001F76  1  A9 FF 48 A9          set_a $7e,$ff
001F7A  1  7E 28        
001F7C  1  D5 13                cmp zp1,x
001F7E  1  08 C9 7E D0          tst_a $7e,~fzc
001F82  1  FE 68 48 C9  
001F86  1  FC D0 FE 28  
001F8A  1               
001F8A  1  A9 00 48 A9          set_a $80,0
001F8E  1  80 28        
001F90  1  DD 17 02             cmp abs1,x
001F93  1  08 C9 80 D0          tst_a $80,fc
001F97  1  FE 68 48 C9  
001F9B  1  31 D0 FE 28  
001F9F  1  A9 00 48 A9          set_a $7f,0
001FA3  1  7F 28        
001FA5  1  DD 17 02             cmp abs1,x
001FA8  1  08 C9 7F D0          tst_a $7f,fzc
001FAC  1  FE 68 48 C9  
001FB0  1  33 D0 FE 28  
001FB4  1  A9 00 48 A9          set_a $7e,0
001FB8  1  7E 28        
001FBA  1  DD 17 02             cmp abs1,x
001FBD  1  08 C9 7E D0          tst_a $7e,fn
001FC1  1  FE 68 48 C9  
001FC5  1  B0 D0 FE 28  
001FC9  1  A9 FF 48 A9          set_a $80,$ff
001FCD  1  80 28        
001FCF  1  DD 17 02             cmp abs1,x
001FD2  1  08 C9 80 D0          tst_a $80,~fnz
001FD6  1  FE 68 48 C9  
001FDA  1  7D D0 FE 28  
001FDE  1  A9 FF 48 A9          set_a $7f,$ff
001FE2  1  7F 28        
001FE4  1  DD 17 02             cmp abs1,x
001FE7  1  08 C9 7F D0          tst_a $7f,~fn
001FEB  1  FE 68 48 C9  
001FEF  1  7F D0 FE 28  
001FF3  1  A9 FF 48 A9          set_a $7e,$ff
001FF7  1  7E 28        
001FF9  1  DD 17 02             cmp abs1,x
001FFC  1  08 C9 7E D0          tst_a $7e,~fzc
002000  1  FE 68 48 C9  
002004  1  FC D0 FE 28  
002008  1               
002008  1  A0 04                ldy #4          ;with indexing by Y
00200A  1  A2 08                ldx #8          ;with indexed indirect
00200C  1  A9 00 48 A9          set_a $80,0
002010  1  80 28        
002012  1  D9 17 02             cmp abs1,y
002015  1  08 C9 80 D0          tst_a $80,fc
002019  1  FE 68 48 C9  
00201D  1  31 D0 FE 28  
002021  1  A9 00 48 A9          set_a $7f,0
002025  1  7F 28        
002027  1  D9 17 02             cmp abs1,y
00202A  1  08 C9 7F D0          tst_a $7f,fzc
00202E  1  FE 68 48 C9  
002032  1  33 D0 FE 28  
002036  1  A9 00 48 A9          set_a $7e,0
00203A  1  7E 28        
00203C  1  D9 17 02             cmp abs1,y
00203F  1  08 C9 7E D0          tst_a $7e,fn
002043  1  FE 68 48 C9  
002047  1  B0 D0 FE 28  
00204B  1  A9 FF 48 A9          set_a $80,$ff
00204F  1  80 28        
002051  1  D9 17 02             cmp abs1,y
002054  1  08 C9 80 D0          tst_a $80,~fnz
002058  1  FE 68 48 C9  
00205C  1  7D D0 FE 28  
002060  1  A9 FF 48 A9          set_a $7f,$ff
002064  1  7F 28        
002066  1  D9 17 02             cmp abs1,y
002069  1  08 C9 7F D0          tst_a $7f,~fn
00206D  1  FE 68 48 C9  
002071  1  7F D0 FE 28  
002075  1  A9 FF 48 A9          set_a $7e,$ff
002079  1  7E 28        
00207B  1  D9 17 02             cmp abs1,y
00207E  1  08 C9 7E D0          tst_a $7e,~fzc
002082  1  FE 68 48 C9  
002086  1  FC D0 FE 28  
00208A  1               
00208A  1  A9 00 48 A9          set_a $80,0
00208E  1  80 28        
002090  1  C1 24                cmp (ind1,x)
002092  1  08 C9 80 D0          tst_a $80,fc
002096  1  FE 68 48 C9  
00209A  1  31 D0 FE 28  
00209E  1  A9 00 48 A9          set_a $7f,0
0020A2  1  7F 28        
0020A4  1  C1 24                cmp (ind1,x)
0020A6  1  08 C9 7F D0          tst_a $7f,fzc
0020AA  1  FE 68 48 C9  
0020AE  1  33 D0 FE 28  
0020B2  1  A9 00 48 A9          set_a $7e,0
0020B6  1  7E 28        
0020B8  1  C1 24                cmp (ind1,x)
0020BA  1  08 C9 7E D0          tst_a $7e,fn
0020BE  1  FE 68 48 C9  
0020C2  1  B0 D0 FE 28  
0020C6  1  A9 FF 48 A9          set_a $80,$ff
0020CA  1  80 28        
0020CC  1  C1 24                cmp (ind1,x)
0020CE  1  08 C9 80 D0          tst_a $80,~fnz
0020D2  1  FE 68 48 C9  
0020D6  1  7D D0 FE 28  
0020DA  1  A9 FF 48 A9          set_a $7f,$ff
0020DE  1  7F 28        
0020E0  1  C1 24                cmp (ind1,x)
0020E2  1  08 C9 7F D0          tst_a $7f,~fn
0020E6  1  FE 68 48 C9  
0020EA  1  7F D0 FE 28  
0020EE  1  A9 FF 48 A9          set_a $7e,$ff
0020F2  1  7E 28        
0020F4  1  C1 24                cmp (ind1,x)
0020F6  1  08 C9 7E D0          tst_a $7e,~fzc
0020FA  1  FE 68 48 C9  
0020FE  1  FC D0 FE 28  
002102  1               
002102  1  A9 00 48 A9          set_a $80,0
002106  1  80 28        
002108  1  D1 24                cmp (ind1),y
00210A  1  08 C9 80 D0          tst_a $80,fc
00210E  1  FE 68 48 C9  
002112  1  31 D0 FE 28  
002116  1  A9 00 48 A9          set_a $7f,0
00211A  1  7F 28        
00211C  1  D1 24                cmp (ind1),y
00211E  1  08 C9 7F D0          tst_a $7f,fzc
002122  1  FE 68 48 C9  
002126  1  33 D0 FE 28  
00212A  1  A9 00 48 A9          set_a $7e,0
00212E  1  7E 28        
002130  1  D1 24                cmp (ind1),y
002132  1  08 C9 7E D0          tst_a $7e,fn
002136  1  FE 68 48 C9  
00213A  1  B0 D0 FE 28  
00213E  1  A9 FF 48 A9          set_a $80,$ff
002142  1  80 28        
002144  1  D1 24                cmp (ind1),y
002146  1  08 C9 80 D0          tst_a $80,~fnz
00214A  1  FE 68 48 C9  
00214E  1  7D D0 FE 28  
002152  1  A9 FF 48 A9          set_a $7f,$ff
002156  1  7F 28        
002158  1  D1 24                cmp (ind1),y
00215A  1  08 C9 7F D0          tst_a $7f,~fn
00215E  1  FE 68 48 C9  
002162  1  7F D0 FE 28  
002166  1  A9 FF 48 A9          set_a $7e,$ff
00216A  1  7E 28        
00216C  1  D1 24                cmp (ind1),y
00216E  1  08 C9 7E D0          tst_a $7e,~fzc
002172  1  FE 68 48 C9  
002176  1  FC D0 FE 28  
00217A  1  AD 00 02 C9          next_test
00217E  1  1C D0 FE A9  
002182  1  1D 8D 00 02  
002186  1               
002186  1               ; testing shifts - ASL LSR ROL ROR all addressing modes
002186  1               ; shifts - accumulator
002186  1  A2 03                ldx #3
002188  1               tasl:
002188  1  A9 00 48 B5          set_ax zp1,0
00218C  1  13 28        
00218E  1  0A                   asl a
00218F  1  08 DD 20 02          tst_ax rASL,fASL,0
002193  1  D0 FE 68 49  
002197  1  30 DD 30 02  
00219D  1  CA                   dex
00219E  1  10 E8                bpl tasl
0021A0  1  A2 03                ldx #3
0021A2  1               tasl1:
0021A2  1  A9 FF 48 B5          set_ax zp1,$ff
0021A6  1  13 28        
0021A8  1  0A                   asl a
0021A9  1  08 DD 20 02          tst_ax rASL,fASL,$ff-fnzc
0021AD  1  D0 FE 68 49  
0021B1  1  7C DD 30 02  
0021B7  1  CA                   dex
0021B8  1  10 E8                bpl tasl1
0021BA  1               
0021BA  1  A2 03                ldx #3
0021BC  1               tlsr:
0021BC  1  A9 00 48 B5          set_ax zp1,0
0021C0  1  13 28        
0021C2  1  4A                   lsr a
0021C3  1  08 DD 28 02          tst_ax rLSR,fLSR,0
0021C7  1  D0 FE 68 49  
0021CB  1  30 DD 38 02  
0021D1  1  CA                   dex
0021D2  1  10 E8                bpl tlsr
0021D4  1  A2 03                ldx #3
0021D6  1               tlsr1:
0021D6  1  A9 FF 48 B5          set_ax zp1,$ff
0021DA  1  13 28        
0021DC  1  4A                   lsr a
0021DD  1  08 DD 28 02          tst_ax rLSR,fLSR,$ff-fnzc
0021E1  1  D0 FE 68 49  
0021E5  1  7C DD 38 02  
0021EB  1  CA                   dex
0021EC  1  10 E8                bpl tlsr1
0021EE  1               
0021EE  1  A2 03                ldx #3
0021F0  1               trol:
0021F0  1  A9 00 48 B5          set_ax zp1,0
0021F4  1  13 28        
0021F6  1  2A                   rol a
0021F7  1  08 DD 20 02          tst_ax rROL,fROL,0
0021FB  1  D0 FE 68 49  
0021FF  1  30 DD 30 02  
002205  1  CA                   dex
002206  1  10 E8                bpl trol
002208  1  A2 03                ldx #3
00220A  1               trol1:
00220A  1  A9 FE 48 B5          set_ax zp1,$ff-fc
00220E  1  13 28        
002210  1  2A                   rol a
002211  1  08 DD 20 02          tst_ax rROL,fROL,$ff-fnzc
002215  1  D0 FE 68 49  
002219  1  7C DD 30 02  
00221F  1  CA                   dex
002220  1  10 E8                bpl trol1
002222  1               
002222  1  A2 03                ldx #3
002224  1               trolc:
002224  1  A9 01 48 B5          set_ax zp1,fc
002228  1  13 28        
00222A  1  2A                   rol a
00222B  1  08 DD 24 02          tst_ax rROLc,fROLc,0
00222F  1  D0 FE 68 49  
002233  1  30 DD 34 02  
002239  1  CA                   dex
00223A  1  10 E8                bpl trolc
00223C  1  A2 03                ldx #3
00223E  1               trolc1:
00223E  1  A9 FF 48 B5          set_ax zp1,$ff
002242  1  13 28        
002244  1  2A                   rol a
002245  1  08 DD 24 02          tst_ax rROLc,fROLc,$ff-fnzc
002249  1  D0 FE 68 49  
00224D  1  7C DD 34 02  
002253  1  CA                   dex
002254  1  10 E8                bpl trolc1
002256  1               
002256  1  A2 03                ldx #3
002258  1               tror:
002258  1  A9 00 48 B5          set_ax zp1,0
00225C  1  13 28        
00225E  1  6A                   ror a
00225F  1  08 DD 28 02          tst_ax rROR,fROR,0
002263  1  D0 FE 68 49  
002267  1  30 DD 38 02  
00226D  1  CA                   dex
00226E  1  10 E8                bpl tror
002270  1  A2 03                ldx #3
002272  1               tror1:
002272  1  A9 FE 48 B5          set_ax zp1,$ff-fc
002276  1  13 28        
002278  1  6A                   ror a
002279  1  08 DD 28 02          tst_ax rROR,fROR,$ff-fnzc
00227D  1  D0 FE 68 49  
002281  1  7C DD 38 02  
002287  1  CA                   dex
002288  1  10 E8                bpl tror1
00228A  1               
00228A  1  A2 03                ldx #3
00228C  1               trorc:
00228C  1  A9 01 48 B5          set_ax zp1,fc
002290  1  13 28        
002292  1  6A                   ror a
002293  1  08 DD 2C 02          tst_ax rRORc,fRORc,0
002297  1  D0 FE 68 49  
00229B  1  30 DD 3C 02  
0022A1  1  CA                   dex
0022A2  1  10 E8                bpl trorc
0022A4  1  A2 03                ldx #3
0022A6  1               trorc1:
0022A6  1  A9 FF 48 B5          set_ax zp1,$ff
0022AA  1  13 28        
0022AC  1  6A                   ror a
0022AD  1  08 DD 2C 02          tst_ax rRORc,fRORc,$ff-fnzc
0022B1  1  D0 FE 68 49  
0022B5  1  7C DD 3C 02  
0022BB  1  CA                   dex
0022BC  1  10 E8                bpl trorc1
0022BE  1  AD 00 02 C9          next_test
0022C2  1  1D D0 FE A9  
0022C6  1  1E 8D 00 02  
0022CA  1               
0022CA  1               ; shifts - zeropage
0022CA  1  A2 03                ldx #3
0022CC  1               tasl2:
0022CC  1  A9 00 48 B5          set_z zp1,0
0022D0  1  13 85 0C 28  
0022D4  1  06 0C                asl zpt
0022D6  1  08 A5 0C DD          tst_z rASL,fASL,0
0022DA  1  20 02 D0 FE  
0022DE  1  68 49 30 DD  
0022E6  1  CA                   dex
0022E7  1  10 E3                bpl tasl2
0022E9  1  A2 03                ldx #3
0022EB  1               tasl3:
0022EB  1  A9 FF 48 B5          set_z zp1,$ff
0022EF  1  13 85 0C 28  
0022F3  1  06 0C                asl zpt
0022F5  1  08 A5 0C DD          tst_z rASL,fASL,$ff-fnzc
0022F9  1  20 02 D0 FE  
0022FD  1  68 49 7C DD  
002305  1  CA                   dex
002306  1  10 E3                bpl tasl3
002308  1               
002308  1  A2 03                ldx #3
00230A  1               tlsr2:
00230A  1  A9 00 48 B5          set_z zp1,0
00230E  1  13 85 0C 28  
002312  1  46 0C                lsr zpt
002314  1  08 A5 0C DD          tst_z rLSR,fLSR,0
002318  1  28 02 D0 FE  
00231C  1  68 49 30 DD  
002324  1  CA                   dex
002325  1  10 E3                bpl tlsr2
002327  1  A2 03                ldx #3
002329  1               tlsr3:
002329  1  A9 FF 48 B5          set_z zp1,$ff
00232D  1  13 85 0C 28  
002331  1  46 0C                lsr zpt
002333  1  08 A5 0C DD          tst_z rLSR,fLSR,$ff-fnzc
002337  1  28 02 D0 FE  
00233B  1  68 49 7C DD  
002343  1  CA                   dex
002344  1  10 E3                bpl tlsr3
002346  1               
002346  1  A2 03                ldx #3
002348  1               trol2:
002348  1  A9 00 48 B5          set_z zp1,0
00234C  1  13 85 0C 28  
002350  1  26 0C                rol zpt
002352  1  08 A5 0C DD          tst_z rROL,fROL,0
002356  1  20 02 D0 FE  
00235A  1  68 49 30 DD  
002362  1  CA                   dex
002363  1  10 E3                bpl trol2
002365  1  A2 03                ldx #3
002367  1               trol3:
002367  1  A9 FE 48 B5          set_z zp1,$ff-fc
00236B  1  13 85 0C 28  
00236F  1  26 0C                rol zpt
002371  1  08 A5 0C DD          tst_z rROL,fROL,$ff-fnzc
002375  1  20 02 D0 FE  
002379  1  68 49 7C DD  
002381  1  CA                   dex
002382  1  10 E3                bpl trol3
002384  1               
002384  1  A2 03                ldx #3
002386  1               trolc2:
002386  1  A9 01 48 B5          set_z zp1,fc
00238A  1  13 85 0C 28  
00238E  1  26 0C                rol zpt
002390  1  08 A5 0C DD          tst_z rROLc,fROLc,0
002394  1  24 02 D0 FE  
002398  1  68 49 30 DD  
0023A0  1  CA                   dex
0023A1  1  10 E3                bpl trolc2
0023A3  1  A2 03                ldx #3
0023A5  1               trolc3:
0023A5  1  A9 FF 48 B5          set_z zp1,$ff
0023A9  1  13 85 0C 28  
0023AD  1  26 0C                rol zpt
0023AF  1  08 A5 0C DD          tst_z rROLc,fROLc,$ff-fnzc
0023B3  1  24 02 D0 FE  
0023B7  1  68 49 7C DD  
0023BF  1  CA                   dex
0023C0  1  10 E3                bpl trolc3
0023C2  1               
0023C2  1  A2 03                ldx #3
0023C4  1               tror2:
0023C4  1  A9 00 48 B5          set_z zp1,0
0023C8  1  13 85 0C 28  
0023CC  1  66 0C                ror zpt
0023CE  1  08 A5 0C DD          tst_z rROR,fROR,0
0023D2  1  28 02 D0 FE  
0023D6  1  68 49 30 DD  
0023DE  1  CA                   dex
0023DF  1  10 E3                bpl tror2
0023E1  1  A2 03                ldx #3
0023E3  1               tror3:
0023E3  1  A9 FE 48 B5          set_z zp1,$ff-fc
0023E7  1  13 85 0C 28  
0023EB  1  66 0C                ror zpt
0023ED  1  08 A5 0C DD          tst_z rROR,fROR,$ff-fnzc
0023F1  1  28 02 D0 FE  
0023F5  1  68 49 7C DD  
0023FD  1  CA                   dex
0023FE  1  10 E3                bpl tror3
002400  1               
002400  1  A2 03                ldx #3
002402  1               trorc2:
002402  1  A9 01 48 B5          set_z zp1,fc
002406  1  13 85 0C 28  
00240A  1  66 0C                ror zpt
00240C  1  08 A5 0C DD          tst_z rRORc,fRORc,0
002410  1  2C 02 D0 FE  
002414  1  68 49 30 DD  
00241C  1  CA                   dex
00241D  1  10 E3                bpl trorc2
00241F  1  A2 03                ldx #3
002421  1               trorc3:
002421  1  A9 FF 48 B5          set_z zp1,$ff
002425  1  13 85 0C 28  
002429  1  66 0C                ror zpt
00242B  1  08 A5 0C DD          tst_z rRORc,fRORc,$ff-fnzc
00242F  1  2C 02 D0 FE  
002433  1  68 49 7C DD  
00243B  1  CA                   dex
00243C  1  10 E3                bpl trorc3
00243E  1  AD 00 02 C9          next_test
002442  1  1E D0 FE A9  
002446  1  1F 8D 00 02  
00244A  1               
00244A  1               ; shifts - absolute
00244A  1  A2 03                ldx #3
00244C  1               tasl4:
00244C  1  A9 00 48 B5          set_abs zp1,0
002450  1  13 8D 03 02  
002454  1  28           
002455  1  0E 03 02             asl abst
002458  1  08 AD 03 02          tst_abs rASL,fASL,0
00245C  1  DD 20 02 D0  
002460  1  FE 68 49 30  
002469  1  CA                   dex
00246A  1  10 E0                bpl tasl4
00246C  1  A2 03                ldx #3
00246E  1               tasl5:
00246E  1  A9 FF 48 B5          set_abs zp1,$ff
002472  1  13 8D 03 02  
002476  1  28           
002477  1  0E 03 02             asl abst
00247A  1  08 AD 03 02          tst_abs rASL,fASL,$ff-fnzc
00247E  1  DD 20 02 D0  
002482  1  FE 68 49 7C  
00248B  1  CA                   dex
00248C  1  10 E0                bpl tasl5
00248E  1               
00248E  1  A2 03                ldx #3
002490  1               tlsr4:
002490  1  A9 00 48 B5          set_abs zp1,0
002494  1  13 8D 03 02  
002498  1  28           
002499  1  4E 03 02             lsr abst
00249C  1  08 AD 03 02          tst_abs rLSR,fLSR,0
0024A0  1  DD 28 02 D0  
0024A4  1  FE 68 49 30  
0024AD  1  CA                   dex
0024AE  1  10 E0                bpl tlsr4
0024B0  1  A2 03                ldx #3
0024B2  1               tlsr5:
0024B2  1  A9 FF 48 B5          set_abs zp1,$ff
0024B6  1  13 8D 03 02  
0024BA  1  28           
0024BB  1  4E 03 02             lsr abst
0024BE  1  08 AD 03 02          tst_abs rLSR,fLSR,$ff-fnzc
0024C2  1  DD 28 02 D0  
0024C6  1  FE 68 49 7C  
0024CF  1  CA                   dex
0024D0  1  10 E0                bpl tlsr5
0024D2  1               
0024D2  1  A2 03                ldx #3
0024D4  1               trol4:
0024D4  1  A9 00 48 B5          set_abs zp1,0
0024D8  1  13 8D 03 02  
0024DC  1  28           
0024DD  1  2E 03 02             rol abst
0024E0  1  08 AD 03 02          tst_abs rROL,fROL,0
0024E4  1  DD 20 02 D0  
0024E8  1  FE 68 49 30  
0024F1  1  CA                   dex
0024F2  1  10 E0                bpl trol4
0024F4  1  A2 03                ldx #3
0024F6  1               trol5:
0024F6  1  A9 FE 48 B5          set_abs zp1,$ff-fc
0024FA  1  13 8D 03 02  
0024FE  1  28           
0024FF  1  2E 03 02             rol abst
002502  1  08 AD 03 02          tst_abs rROL,fROL,$ff-fnzc
002506  1  DD 20 02 D0  
00250A  1  FE 68 49 7C  
002513  1  CA                   dex
002514  1  10 E0                bpl trol5
002516  1               
002516  1  A2 03                ldx #3
002518  1               trolc4:
002518  1  A9 01 48 B5          set_abs zp1,fc
00251C  1  13 8D 03 02  
002520  1  28           
002521  1  2E 03 02             rol abst
002524  1  08 AD 03 02          tst_abs rROLc,fROLc,0
002528  1  DD 24 02 D0  
00252C  1  FE 68 49 30  
002535  1  CA                   dex
002536  1  10 E0                bpl trolc4
002538  1  A2 03                ldx #3
00253A  1               trolc5:
00253A  1  A9 FF 48 B5          set_abs zp1,$ff
00253E  1  13 8D 03 02  
002542  1  28           
002543  1  2E 03 02             rol abst
002546  1  08 AD 03 02          tst_abs rROLc,fROLc,$ff-fnzc
00254A  1  DD 24 02 D0  
00254E  1  FE 68 49 7C  
002557  1  CA                   dex
002558  1  10 E0                bpl trolc5
00255A  1               
00255A  1  A2 03                ldx #3
00255C  1               tror4:
00255C  1  A9 00 48 B5          set_abs zp1,0
002560  1  13 8D 03 02  
002564  1  28           
002565  1  6E 03 02             ror abst
002568  1  08 AD 03 02          tst_abs rROR,fROR,0
00256C  1  DD 28 02 D0  
002570  1  FE 68 49 30  
002579  1  CA                   dex
00257A  1  10 E0                bpl tror4
00257C  1  A2 03                ldx #3
00257E  1               tror5:
00257E  1  A9 FE 48 B5          set_abs zp1,$ff-fc
002582  1  13 8D 03 02  
002586  1  28           
002587  1  6E 03 02             ror abst
00258A  1  08 AD 03 02          tst_abs rROR,fROR,$ff-fnzc
00258E  1  DD 28 02 D0  
002592  1  FE 68 49 7C  
00259B  1  CA                   dex
00259C  1  10 E0                bpl tror5
00259E  1               
00259E  1  A2 03                ldx #3
0025A0  1               trorc4:
0025A0  1  A9 01 48 B5          set_abs zp1,fc
0025A4  1  13 8D 03 02  
0025A8  1  28           
0025A9  1  6E 03 02             ror abst
0025AC  1  08 AD 03 02          tst_abs rRORc,fRORc,0
0025B0  1  DD 2C 02 D0  
0025B4  1  FE 68 49 30  
0025BD  1  CA                   dex
0025BE  1  10 E0                bpl trorc4
0025C0  1  A2 03                ldx #3
0025C2  1               trorc5:
0025C2  1  A9 FF 48 B5          set_abs zp1,$ff
0025C6  1  13 8D 03 02  
0025CA  1  28           
0025CB  1  6E 03 02             ror abst
0025CE  1  08 AD 03 02          tst_abs rRORc,fRORc,$ff-fnzc
0025D2  1  DD 2C 02 D0  
0025D6  1  FE 68 49 7C  
0025DF  1  CA                   dex
0025E0  1  10 E0                bpl trorc5
0025E2  1  AD 00 02 C9          next_test
0025E6  1  1F D0 FE A9  
0025EA  1  20 8D 00 02  
0025EE  1               
0025EE  1               ; shifts - zp indexed
0025EE  1  A2 03                ldx #3
0025F0  1               tasl6:
0025F0  1  A9 00 48 B5          set_zx zp1,0
0025F4  1  13 95 0C 28  
0025F8  1  16 0C                asl zpt,x
0025FA  1  08 B5 0C DD          tst_zx rASL,fASL,0
0025FE  1  20 02 D0 FE  
002602  1  68 49 30 DD  
00260A  1  CA                   dex
00260B  1  10 E3                bpl tasl6
00260D  1  A2 03                ldx #3
00260F  1               tasl7:
00260F  1  A9 FF 48 B5          set_zx zp1,$ff
002613  1  13 95 0C 28  
002617  1  16 0C                asl zpt,x
002619  1  08 B5 0C DD          tst_zx rASL,fASL,$ff-fnzc
00261D  1  20 02 D0 FE  
002621  1  68 49 7C DD  
002629  1  CA                   dex
00262A  1  10 E3                bpl tasl7
00262C  1               
00262C  1  A2 03                ldx #3
00262E  1               tlsr6:
00262E  1  A9 00 48 B5          set_zx zp1,0
002632  1  13 95 0C 28  
002636  1  56 0C                lsr zpt,x
002638  1  08 B5 0C DD          tst_zx rLSR,fLSR,0
00263C  1  28 02 D0 FE  
002640  1  68 49 30 DD  
002648  1  CA                   dex
002649  1  10 E3                bpl tlsr6
00264B  1  A2 03                ldx #3
00264D  1               tlsr7:
00264D  1  A9 FF 48 B5          set_zx zp1,$ff
002651  1  13 95 0C 28  
002655  1  56 0C                lsr zpt,x
002657  1  08 B5 0C DD          tst_zx rLSR,fLSR,$ff-fnzc
00265B  1  28 02 D0 FE  
00265F  1  68 49 7C DD  
002667  1  CA                   dex
002668  1  10 E3                bpl tlsr7
00266A  1               
00266A  1  A2 03                ldx #3
00266C  1               trol6:
00266C  1  A9 00 48 B5          set_zx zp1,0
002670  1  13 95 0C 28  
002674  1  36 0C                rol zpt,x
002676  1  08 B5 0C DD          tst_zx rROL,fROL,0
00267A  1  20 02 D0 FE  
00267E  1  68 49 30 DD  
002686  1  CA                   dex
002687  1  10 E3                bpl trol6
002689  1  A2 03                ldx #3
00268B  1               trol7:
00268B  1  A9 FE 48 B5          set_zx zp1,$ff-fc
00268F  1  13 95 0C 28  
002693  1  36 0C                rol zpt,x
002695  1  08 B5 0C DD          tst_zx rROL,fROL,$ff-fnzc
002699  1  20 02 D0 FE  
00269D  1  68 49 7C DD  
0026A5  1  CA                   dex
0026A6  1  10 E3                bpl trol7
0026A8  1               
0026A8  1  A2 03                ldx #3
0026AA  1               trolc6:
0026AA  1  A9 01 48 B5          set_zx zp1,fc
0026AE  1  13 95 0C 28  
0026B2  1  36 0C                rol zpt,x
0026B4  1  08 B5 0C DD          tst_zx rROLc,fROLc,0
0026B8  1  24 02 D0 FE  
0026BC  1  68 49 30 DD  
0026C4  1  CA                   dex
0026C5  1  10 E3                bpl trolc6
0026C7  1  A2 03                ldx #3
0026C9  1               trolc7:
0026C9  1  A9 FF 48 B5          set_zx zp1,$ff
0026CD  1  13 95 0C 28  
0026D1  1  36 0C                rol zpt,x
0026D3  1  08 B5 0C DD          tst_zx rROLc,fROLc,$ff-fnzc
0026D7  1  24 02 D0 FE  
0026DB  1  68 49 7C DD  
0026E3  1  CA                   dex
0026E4  1  10 E3                bpl trolc7
0026E6  1               
0026E6  1  A2 03                ldx #3
0026E8  1               tror6:
0026E8  1  A9 00 48 B5          set_zx zp1,0
0026EC  1  13 95 0C 28  
0026F0  1  76 0C                ror zpt,x
0026F2  1  08 B5 0C DD          tst_zx rROR,fROR,0
0026F6  1  28 02 D0 FE  
0026FA  1  68 49 30 DD  
002702  1  CA                   dex
002703  1  10 E3                bpl tror6
002705  1  A2 03                ldx #3
002707  1               tror7:
002707  1  A9 FE 48 B5          set_zx zp1,$ff-fc
00270B  1  13 95 0C 28  
00270F  1  76 0C                ror zpt,x
002711  1  08 B5 0C DD          tst_zx rROR,fROR,$ff-fnzc
002715  1  28 02 D0 FE  
002719  1  68 49 7C DD  
002721  1  CA                   dex
002722  1  10 E3                bpl tror7
002724  1               
002724  1  A2 03                ldx #3
002726  1               trorc6:
002726  1  A9 01 48 B5          set_zx zp1,fc
00272A  1  13 95 0C 28  
00272E  1  76 0C                ror zpt,x
002730  1  08 B5 0C DD          tst_zx rRORc,fRORc,0
002734  1  2C 02 D0 FE  
002738  1  68 49 30 DD  
002740  1  CA                   dex
002741  1  10 E3                bpl trorc6
002743  1  A2 03                ldx #3
002745  1               trorc7:
002745  1  A9 FF 48 B5          set_zx zp1,$ff
002749  1  13 95 0C 28  
00274D  1  76 0C                ror zpt,x
00274F  1  08 B5 0C DD          tst_zx rRORc,fRORc,$ff-fnzc
002753  1  2C 02 D0 FE  
002757  1  68 49 7C DD  
00275F  1  CA                   dex
002760  1  10 E3                bpl trorc7
002762  1  AD 00 02 C9          next_test
002766  1  20 D0 FE A9  
00276A  1  21 8D 00 02  
00276E  1               
00276E  1               ; shifts - abs indexed
00276E  1  A2 03                ldx #3
002770  1               tasl8:
002770  1  A9 00 48 B5          set_absx zp1,0
002774  1  13 9D 03 02  
002778  1  28           
002779  1  1E 03 02             asl abst,x
00277C  1  08 BD 03 02          tst_absx rASL,fASL,0
002780  1  DD 20 02 D0  
002784  1  FE 68 49 30  
00278D  1  CA                   dex
00278E  1  10 E0                bpl tasl8
002790  1  A2 03                ldx #3
002792  1               tasl9:
002792  1  A9 FF 48 B5          set_absx zp1,$ff
002796  1  13 9D 03 02  
00279A  1  28           
00279B  1  1E 03 02             asl abst,x
00279E  1  08 BD 03 02          tst_absx rASL,fASL,$ff-fnzc
0027A2  1  DD 20 02 D0  
0027A6  1  FE 68 49 7C  
0027AF  1  CA                   dex
0027B0  1  10 E0                bpl tasl9
0027B2  1               
0027B2  1  A2 03                ldx #3
0027B4  1               tlsr8:
0027B4  1  A9 00 48 B5          set_absx zp1,0
0027B8  1  13 9D 03 02  
0027BC  1  28           
0027BD  1  5E 03 02             lsr abst,x
0027C0  1  08 BD 03 02          tst_absx rLSR,fLSR,0
0027C4  1  DD 28 02 D0  
0027C8  1  FE 68 49 30  
0027D1  1  CA                   dex
0027D2  1  10 E0                bpl tlsr8
0027D4  1  A2 03                ldx #3
0027D6  1               tlsr9:
0027D6  1  A9 FF 48 B5          set_absx zp1,$ff
0027DA  1  13 9D 03 02  
0027DE  1  28           
0027DF  1  5E 03 02             lsr abst,x
0027E2  1  08 BD 03 02          tst_absx rLSR,fLSR,$ff-fnzc
0027E6  1  DD 28 02 D0  
0027EA  1  FE 68 49 7C  
0027F3  1  CA                   dex
0027F4  1  10 E0                bpl tlsr9
0027F6  1               
0027F6  1  A2 03                ldx #3
0027F8  1               trol8:
0027F8  1  A9 00 48 B5          set_absx zp1,0
0027FC  1  13 9D 03 02  
002800  1  28           
002801  1  3E 03 02             rol abst,x
002804  1  08 BD 03 02          tst_absx rROL,fROL,0
002808  1  DD 20 02 D0  
00280C  1  FE 68 49 30  
002815  1  CA                   dex
002816  1  10 E0                bpl trol8
002818  1  A2 03                ldx #3
00281A  1               trol9:
00281A  1  A9 FE 48 B5          set_absx zp1,$ff-fc
00281E  1  13 9D 03 02  
002822  1  28           
002823  1  3E 03 02             rol abst,x
002826  1  08 BD 03 02          tst_absx rROL,fROL,$ff-fnzc
00282A  1  DD 20 02 D0  
00282E  1  FE 68 49 7C  
002837  1  CA                   dex
002838  1  10 E0                bpl trol9
00283A  1               
00283A  1  A2 03                ldx #3
00283C  1               trolc8:
00283C  1  A9 01 48 B5          set_absx zp1,fc
002840  1  13 9D 03 02  
002844  1  28           
002845  1  3E 03 02             rol abst,x
002848  1  08 BD 03 02          tst_absx rROLc,fROLc,0
00284C  1  DD 24 02 D0  
002850  1  FE 68 49 30  
002859  1  CA                   dex
00285A  1  10 E0                bpl trolc8
00285C  1  A2 03                ldx #3
00285E  1               trolc9:
00285E  1  A9 FF 48 B5          set_absx zp1,$ff
002862  1  13 9D 03 02  
002866  1  28           
002867  1  3E 03 02             rol abst,x
00286A  1  08 BD 03 02          tst_absx rROLc,fROLc,$ff-fnzc
00286E  1  DD 24 02 D0  
002872  1  FE 68 49 7C  
00287B  1  CA                   dex
00287C  1  10 E0                bpl trolc9
00287E  1               
00287E  1  A2 03                ldx #3
002880  1               tror8:
002880  1  A9 00 48 B5          set_absx zp1,0
002884  1  13 9D 03 02  
002888  1  28           
002889  1  7E 03 02             ror abst,x
00288C  1  08 BD 03 02          tst_absx rROR,fROR,0
002890  1  DD 28 02 D0  
002894  1  FE 68 49 30  
00289D  1  CA                   dex
00289E  1  10 E0                bpl tror8
0028A0  1  A2 03                ldx #3
0028A2  1               tror9:
0028A2  1  A9 FE 48 B5          set_absx zp1,$ff-fc
0028A6  1  13 9D 03 02  
0028AA  1  28           
0028AB  1  7E 03 02             ror abst,x
0028AE  1  08 BD 03 02          tst_absx rROR,fROR,$ff-fnzc
0028B2  1  DD 28 02 D0  
0028B6  1  FE 68 49 7C  
0028BF  1  CA                   dex
0028C0  1  10 E0                bpl tror9
0028C2  1               
0028C2  1  A2 03                ldx #3
0028C4  1               trorc8:
0028C4  1  A9 01 48 B5          set_absx zp1,fc
0028C8  1  13 9D 03 02  
0028CC  1  28           
0028CD  1  7E 03 02             ror abst,x
0028D0  1  08 BD 03 02          tst_absx rRORc,fRORc,0
0028D4  1  DD 2C 02 D0  
0028D8  1  FE 68 49 30  
0028E1  1  CA                   dex
0028E2  1  10 E0                bpl trorc8
0028E4  1  A2 03                ldx #3
0028E6  1               trorc9:
0028E6  1  A9 FF 48 B5          set_absx zp1,$ff
0028EA  1  13 9D 03 02  
0028EE  1  28           
0028EF  1  7E 03 02             ror abst,x
0028F2  1  08 BD 03 02          tst_absx rRORc,fRORc,$ff-fnzc
0028F6  1  DD 2C 02 D0  
0028FA  1  FE 68 49 7C  
002903  1  CA                   dex
002904  1  10 E0                bpl trorc9
002906  1  AD 00 02 C9          next_test
00290A  1  21 D0 FE A9  
00290E  1  22 8D 00 02  
002912  1               
002912  1               ; testing memory increment/decrement - INC DEC all addressing modes
002912  1               ; zeropage
002912  1  A2 00                ldx #0
002914  1  A9 7E                lda #$7e
002916  1  85 0C                sta zpt
002918  1               tinc:
002918  1  A9 00 48 28          set_stat 0
00291C  1  E6 0C                inc zpt
00291E  1  08 A5 0C DD          tst_z rINC,fINC,0
002922  1  40 02 D0 FE  
002926  1  68 49 30 DD  
00292E  1  E8                   inx
00292F  1  E0 02                cpx #2
002931  1  D0 04                bne tinc1
002933  1  A9 FE                lda #$fe
002935  1  85 0C                sta zpt
002937  1  E0 05        tinc1:  cpx #5
002939  1  D0 DD                bne tinc
00293B  1  CA                   dex
00293C  1  E6 0C                inc zpt
00293E  1               tdec:
00293E  1  A9 00 48 28          set_stat 0
002942  1  C6 0C                dec zpt
002944  1  08 A5 0C DD          tst_z rINC,fINC,0
002948  1  40 02 D0 FE  
00294C  1  68 49 30 DD  
002954  1  CA                   dex
002955  1  30 0A                bmi tdec1
002957  1  E0 01                cpx #1
002959  1  D0 E3                bne tdec
00295B  1  A9 81                lda #$81
00295D  1  85 0C                sta zpt
00295F  1  D0 DD                bne tdec
002961  1               tdec1:
002961  1  A2 00                ldx #0
002963  1  A9 7E                lda #$7e
002965  1  85 0C                sta zpt
002967  1               tinc10:
002967  1  A9 FF 48 28          set_stat $ff
00296B  1  E6 0C                inc zpt
00296D  1  08 A5 0C DD          tst_z rINC,fINC,$ff-fnz
002971  1  40 02 D0 FE  
002975  1  68 49 7D DD  
00297D  1  E8                   inx
00297E  1  E0 02                cpx #2
002980  1  D0 04                bne tinc11
002982  1  A9 FE                lda #$fe
002984  1  85 0C                sta zpt
002986  1  E0 05        tinc11: cpx #5
002988  1  D0 DD                bne tinc10
00298A  1  CA                   dex
00298B  1  E6 0C                inc zpt
00298D  1               tdec10:
00298D  1  A9 FF 48 28          set_stat $ff
002991  1  C6 0C                dec zpt
002993  1  08 A5 0C DD          tst_z rINC,fINC,$ff-fnz
002997  1  40 02 D0 FE  
00299B  1  68 49 7D DD  
0029A3  1  CA                   dex
0029A4  1  30 0A                bmi tdec11
0029A6  1  E0 01                cpx #1
0029A8  1  D0 E3                bne tdec10
0029AA  1  A9 81                lda #$81
0029AC  1  85 0C                sta zpt
0029AE  1  D0 DD                bne tdec10
0029B0  1               tdec11:
0029B0  1  AD 00 02 C9          next_test
0029B4  1  22 D0 FE A9  
0029B8  1  23 8D 00 02  
0029BC  1               
0029BC  1               ; absolute memory
0029BC  1  A2 00                ldx #0
0029BE  1  A9 7E                lda #$7e
0029C0  1  8D 03 02             sta abst
0029C3  1               tinc2:
0029C3  1  A9 00 48 28          set_stat 0
0029C7  1  EE 03 02             inc abst
0029CA  1  08 AD 03 02          tst_abs rINC,fINC,0
0029CE  1  DD 40 02 D0  
0029D2  1  FE 68 49 30  
0029DB  1  E8                   inx
0029DC  1  E0 02                cpx #2
0029DE  1  D0 05                bne tinc3
0029E0  1  A9 FE                lda #$fe
0029E2  1  8D 03 02             sta abst
0029E5  1  E0 05        tinc3:  cpx #5
0029E7  1  D0 DA                bne tinc2
0029E9  1  CA                   dex
0029EA  1  EE 03 02             inc abst
0029ED  1               tdec2:
0029ED  1  A9 00 48 28          set_stat 0
0029F1  1  CE 03 02             dec abst
0029F4  1  08 AD 03 02          tst_abs rINC,fINC,0
0029F8  1  DD 40 02 D0  
0029FC  1  FE 68 49 30  
002A05  1  CA                   dex
002A06  1  30 0B                bmi tdec3
002A08  1  E0 01                cpx #1
002A0A  1  D0 E1                bne tdec2
002A0C  1  A9 81                lda #$81
002A0E  1  8D 03 02             sta abst
002A11  1  D0 DA                bne tdec2
002A13  1               tdec3:
002A13  1  A2 00                ldx #0
002A15  1  A9 7E                lda #$7e
002A17  1  8D 03 02             sta abst
002A1A  1               tinc12:
002A1A  1  A9 FF 48 28          set_stat $ff
002A1E  1  EE 03 02             inc abst
002A21  1  08 AD 03 02          tst_abs rINC,fINC,$ff-fnz
002A25  1  DD 40 02 D0  
002A29  1  FE 68 49 7D  
002A32  1  E8                   inx
002A33  1  E0 02                cpx #2
002A35  1  D0 05                bne tinc13
002A37  1  A9 FE                lda #$fe
002A39  1  8D 03 02             sta abst
002A3C  1  E0 05        tinc13:  cpx #5
002A3E  1  D0 DA                bne tinc12
002A40  1  CA                   dex
002A41  1  EE 03 02             inc abst
002A44  1               tdec12:
002A44  1  A9 FF 48 28          set_stat $ff
002A48  1  CE 03 02             dec abst
002A4B  1  08 AD 03 02          tst_abs rINC,fINC,$ff-fnz
002A4F  1  DD 40 02 D0  
002A53  1  FE 68 49 7D  
002A5C  1  CA                   dex
002A5D  1  30 0B                bmi tdec13
002A5F  1  E0 01                cpx #1
002A61  1  D0 E1                bne tdec12
002A63  1  A9 81                lda #$81
002A65  1  8D 03 02             sta abst
002A68  1  D0 DA                bne tdec12
002A6A  1               tdec13:
002A6A  1  AD 00 02 C9          next_test
002A6E  1  23 D0 FE A9  
002A72  1  24 8D 00 02  
002A76  1               
002A76  1               ; zeropage indexed
002A76  1  A2 00                ldx #0
002A78  1  A9 7E                lda #$7e
002A7A  1  95 0C        tinc4:  sta zpt,x
002A7C  1  A9 00 48 28          set_stat 0
002A80  1  F6 0C                inc zpt,x
002A82  1  08 B5 0C DD          tst_zx rINC,fINC,0
002A86  1  40 02 D0 FE  
002A8A  1  68 49 30 DD  
002A92  1  B5 0C                lda zpt,x
002A94  1  E8                   inx
002A95  1  E0 02                cpx #2
002A97  1  D0 02                bne tinc5
002A99  1  A9 FE                lda #$fe
002A9B  1  E0 05        tinc5:  cpx #5
002A9D  1  D0 DB                bne tinc4
002A9F  1  CA                   dex
002AA0  1  A9 02                lda #2
002AA2  1  95 0C        tdec4:  sta zpt,x
002AA4  1  A9 00 48 28          set_stat 0
002AA8  1  D6 0C                dec zpt,x
002AAA  1  08 B5 0C DD          tst_zx rINC,fINC,0
002AAE  1  40 02 D0 FE  
002AB2  1  68 49 30 DD  
002ABA  1  B5 0C                lda zpt,x
002ABC  1  CA                   dex
002ABD  1  30 08                bmi tdec5
002ABF  1  E0 01                cpx #1
002AC1  1  D0 DF                bne tdec4
002AC3  1  A9 81                lda #$81
002AC5  1  D0 DB                bne tdec4
002AC7  1               tdec5:
002AC7  1  A2 00                ldx #0
002AC9  1  A9 7E                lda #$7e
002ACB  1  95 0C        tinc14: sta zpt,x
002ACD  1  A9 FF 48 28          set_stat $ff
002AD1  1  F6 0C                inc zpt,x
002AD3  1  08 B5 0C DD          tst_zx rINC,fINC,$ff-fnz
002AD7  1  40 02 D0 FE  
002ADB  1  68 49 7D DD  
002AE3  1  B5 0C                lda zpt,x
002AE5  1  E8                   inx
002AE6  1  E0 02                cpx #2
002AE8  1  D0 02                bne tinc15
002AEA  1  A9 FE                lda #$fe
002AEC  1  E0 05        tinc15: cpx #5
002AEE  1  D0 DB                bne tinc14
002AF0  1  CA                   dex
002AF1  1  A9 02                lda #2
002AF3  1  95 0C        tdec14: sta zpt,x
002AF5  1  A9 FF 48 28          set_stat $ff
002AF9  1  D6 0C                dec zpt,x
002AFB  1  08 B5 0C DD          tst_zx rINC,fINC,$ff-fnz
002AFF  1  40 02 D0 FE  
002B03  1  68 49 7D DD  
002B0B  1  B5 0C                lda zpt,x
002B0D  1  CA                   dex
002B0E  1  30 08                bmi tdec15
002B10  1  E0 01                cpx #1
002B12  1  D0 DF                bne tdec14
002B14  1  A9 81                lda #$81
002B16  1  D0 DB                bne tdec14
002B18  1               tdec15:
002B18  1  AD 00 02 C9          next_test
002B1C  1  24 D0 FE A9  
002B20  1  25 8D 00 02  
002B24  1               
002B24  1               ; memory indexed
002B24  1  A2 00                ldx #0
002B26  1  A9 7E                lda #$7e
002B28  1  9D 03 02     tinc6:  sta abst,x
002B2B  1  A9 00 48 28          set_stat 0
002B2F  1  FE 03 02             inc abst,x
002B32  1  08 BD 03 02          tst_absx rINC,fINC,0
002B36  1  DD 40 02 D0  
002B3A  1  FE 68 49 30  
002B43  1  BD 03 02             lda abst,x
002B46  1  E8                   inx
002B47  1  E0 02                cpx #2
002B49  1  D0 02                bne tinc7
002B4B  1  A9 FE                lda #$fe
002B4D  1  E0 05        tinc7:  cpx #5
002B4F  1  D0 D7                bne tinc6
002B51  1  CA                   dex
002B52  1  A9 02                lda #2
002B54  1  9D 03 02     tdec6:  sta abst,x
002B57  1  A9 00 48 28          set_stat 0
002B5B  1  DE 03 02             dec abst,x
002B5E  1  08 BD 03 02          tst_absx rINC,fINC,0
002B62  1  DD 40 02 D0  
002B66  1  FE 68 49 30  
002B6F  1  BD 03 02             lda abst,x
002B72  1  CA                   dex
002B73  1  30 08                bmi tdec7
002B75  1  E0 01                cpx #1
002B77  1  D0 DB                bne tdec6
002B79  1  A9 81                lda #$81
002B7B  1  D0 D7                bne tdec6
002B7D  1               tdec7:
002B7D  1  A2 00                ldx #0
002B7F  1  A9 7E                lda #$7e
002B81  1  9D 03 02     tinc16: sta abst,x
002B84  1  A9 FF 48 28          set_stat $ff
002B88  1  FE 03 02             inc abst,x
002B8B  1  08 BD 03 02          tst_absx rINC,fINC,$ff-fnz
002B8F  1  DD 40 02 D0  
002B93  1  FE 68 49 7D  
002B9C  1  BD 03 02             lda abst,x
002B9F  1  E8                   inx
002BA0  1  E0 02                cpx #2
002BA2  1  D0 02                bne tinc17
002BA4  1  A9 FE                lda #$fe
002BA6  1  E0 05        tinc17: cpx #5
002BA8  1  D0 D7                bne tinc16
002BAA  1  CA                   dex
002BAB  1  A9 02                lda #2
002BAD  1  9D 03 02     tdec16: sta abst,x
002BB0  1  A9 FF 48 28          set_stat $ff
002BB4  1  DE 03 02             dec abst,x
002BB7  1  08 BD 03 02          tst_absx rINC,fINC,$ff-fnz
002BBB  1  DD 40 02 D0  
002BBF  1  FE 68 49 7D  
002BC8  1  BD 03 02             lda abst,x
002BCB  1  CA                   dex
002BCC  1  30 08                bmi tdec17
002BCE  1  E0 01                cpx #1
002BD0  1  D0 DB                bne tdec16
002BD2  1  A9 81                lda #$81
002BD4  1  D0 D7                bne tdec16
002BD6  1               tdec17:
002BD6  1  AD 00 02 C9          next_test
002BDA  1  25 D0 FE A9  
002BDE  1  26 8D 00 02  
002BE2  1               
002BE2  1               ; testing logical instructions - AND EOR ORA all addressing modes
002BE2  1               ; AND
002BE2  1  A2 03                ldx #3          ;immediate
002BE4  1  B5 1C        tand:   lda zpAN,x
002BE6  1  8D 09 02             sta ex_andi+1   ;set AND # operand
002BE9  1  A9 00 48 BD          set_ax  absANa,0
002BED  1  5A 02 28     
002BF0  1  20 08 02             jsr ex_andi     ;execute AND # in RAM
002BF3  1  08 DD 62 02          tst_ax  absrlo,absflo,0
002BF7  1  D0 FE 68 49  
002BFB  1  30 DD 66 02  
002C01  1  CA                   dex
002C02  1  10 E0                bpl tand
002C04  1  A2 03                ldx #3
002C06  1  B5 1C        tand1:  lda zpAN,x
002C08  1  8D 09 02             sta ex_andi+1   ;set AND # operand
002C0B  1  A9 FF 48 BD          set_ax  absANa,$ff
002C0F  1  5A 02 28     
002C12  1  20 08 02             jsr ex_andi     ;execute AND # in RAM
002C15  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
002C19  1  D0 FE 68 49  
002C1D  1  7D DD 66 02  
002C23  1  CA                   dex
002C24  1  10 E0                bpl tand1
002C26  1               
002C26  1  A2 03                ldx #3      ;zp
002C28  1  B5 1C        tand2:  lda zpAN,x
002C2A  1  85 0C                sta zpt
002C2C  1  A9 00 48 BD          set_ax  absANa,0
002C30  1  5A 02 28     
002C33  1  25 0C                and zpt
002C35  1  08 DD 62 02          tst_ax  absrlo,absflo,0
002C39  1  D0 FE 68 49  
002C3D  1  30 DD 66 02  
002C43  1  CA                   dex
002C44  1  10 E2                bpl tand2
002C46  1  A2 03                ldx #3
002C48  1  B5 1C        tand3:  lda zpAN,x
002C4A  1  85 0C                sta zpt
002C4C  1  A9 FF 48 BD          set_ax  absANa,$ff
002C50  1  5A 02 28     
002C53  1  25 0C                and zpt
002C55  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
002C59  1  D0 FE 68 49  
002C5D  1  7D DD 66 02  
002C63  1  CA                   dex
002C64  1  10 E2                bpl tand3
002C66  1               
002C66  1  A2 03                ldx #3      ;abs
002C68  1  B5 1C        tand4:  lda zpAN,x
002C6A  1  8D 03 02             sta abst
002C6D  1  A9 00 48 BD          set_ax  absANa,0
002C71  1  5A 02 28     
002C74  1  2D 03 02             and abst
002C77  1  08 DD 62 02          tst_ax  absrlo,absflo,0
002C7B  1  D0 FE 68 49  
002C7F  1  30 DD 66 02  
002C85  1  CA                   dex
002C86  1  10 E0                bpl tand4
002C88  1  A2 03                ldx #3
002C8A  1  B5 1C        tand5:  lda zpAN,x
002C8C  1  8D 03 02             sta abst
002C8F  1  A9 FF 48 BD          set_ax  absANa,$ff
002C93  1  5A 02 28     
002C96  1  2D 03 02             and abst
002C99  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
002C9D  1  D0 FE 68 49  
002CA1  1  7D DD 66 02  
002CA7  1  CA                   dex
002CA8  1  10 02                bpl tand6
002CAA  1               
002CAA  1  A2 03                ldx #3      ;zp,x
002CAC  1               tand6:
002CAC  1  A9 00 48 BD          set_ax  absANa,0
002CB0  1  5A 02 28     
002CB3  1  35 1C                and zpAN,x
002CB5  1  08 DD 62 02          tst_ax  absrlo,absflo,0
002CB9  1  D0 FE 68 49  
002CBD  1  30 DD 66 02  
002CC3  1  CA                   dex
002CC4  1  10 E6                bpl tand6
002CC6  1  A2 03                ldx #3
002CC8  1               tand7:
002CC8  1  A9 FF 48 BD          set_ax  absANa,$ff
002CCC  1  5A 02 28     
002CCF  1  35 1C                and zpAN,x
002CD1  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
002CD5  1  D0 FE 68 49  
002CD9  1  7D DD 66 02  
002CDF  1  CA                   dex
002CE0  1  10 E6                bpl tand7
002CE2  1               
002CE2  1  A2 03                ldx #3      ;abs,x
002CE4  1               tand8:
002CE4  1  A9 00 48 BD          set_ax  absANa,0
002CE8  1  5A 02 28     
002CEB  1  3D 4E 02             and absAN,x
002CEE  1  08 DD 62 02          tst_ax  absrlo,absflo,0
002CF2  1  D0 FE 68 49  
002CF6  1  30 DD 66 02  
002CFC  1  CA                   dex
002CFD  1  10 E5                bpl tand8
002CFF  1  A2 03                ldx #3
002D01  1               tand9:
002D01  1  A9 FF 48 BD          set_ax  absANa,$ff
002D05  1  5A 02 28     
002D08  1  3D 4E 02             and absAN,x
002D0B  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
002D0F  1  D0 FE 68 49  
002D13  1  7D DD 66 02  
002D19  1  CA                   dex
002D1A  1  10 E5                bpl tand9
002D1C  1               
002D1C  1  A0 03                ldy #3      ;abs,y
002D1E  1               tand10:
002D1E  1  A9 00 48 B9          set_ay  absANa,0
002D22  1  5A 02 28     
002D25  1  39 4E 02             and absAN,y
002D28  1  08 D9 62 02          tst_ay  absrlo,absflo,0
002D2C  1  D0 FE 68 49  
002D30  1  30 D9 66 02  
002D36  1  88                   dey
002D37  1  10 E5                bpl tand10
002D39  1  A0 03                ldy #3
002D3B  1               tand11:
002D3B  1  A9 FF 48 B9          set_ay  absANa,$ff
002D3F  1  5A 02 28     
002D42  1  39 4E 02             and absAN,y
002D45  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
002D49  1  D0 FE 68 49  
002D4D  1  7D D9 66 02  
002D53  1  88                   dey
002D54  1  10 E5                bpl tand11
002D56  1               
002D56  1  A2 06                ldx #6      ;(zp,x)
002D58  1  A0 03                ldy #3
002D5A  1               tand12:
002D5A  1  A9 00 48 B9          set_ay  absANa,0
002D5E  1  5A 02 28     
002D61  1  21 3A                and (indAN,x)
002D63  1  08 D9 62 02          tst_ay  absrlo,absflo,0
002D67  1  D0 FE 68 49  
002D6B  1  30 D9 66 02  
002D71  1  CA                   dex
002D72  1  CA                   dex
002D73  1  88                   dey
002D74  1  10 E4                bpl tand12
002D76  1  A2 06                ldx #6
002D78  1  A0 03                ldy #3
002D7A  1               tand13:
002D7A  1  A9 FF 48 B9          set_ay  absANa,$ff
002D7E  1  5A 02 28     
002D81  1  21 3A                and (indAN,x)
002D83  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
002D87  1  D0 FE 68 49  
002D8B  1  7D D9 66 02  
002D91  1  CA                   dex
002D92  1  CA                   dex
002D93  1  88                   dey
002D94  1  10 E4                bpl tand13
002D96  1               
002D96  1  A0 03                ldy #3      ;(zp),y
002D98  1               tand14:
002D98  1  A9 00 48 B9          set_ay  absANa,0
002D9C  1  5A 02 28     
002D9F  1  31 3A                and (indAN),y
002DA1  1  08 D9 62 02          tst_ay  absrlo,absflo,0
002DA5  1  D0 FE 68 49  
002DA9  1  30 D9 66 02  
002DAF  1  88                   dey
002DB0  1  10 E6                bpl tand14
002DB2  1  A0 03                ldy #3
002DB4  1               tand15:
002DB4  1  A9 FF 48 B9          set_ay  absANa,$ff
002DB8  1  5A 02 28     
002DBB  1  31 3A                and (indAN),y
002DBD  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
002DC1  1  D0 FE 68 49  
002DC5  1  7D D9 66 02  
002DCB  1  88                   dey
002DCC  1  10 E6                bpl tand15
002DCE  1  AD 00 02 C9          next_test
002DD2  1  26 D0 FE A9  
002DD6  1  27 8D 00 02  
002DDA  1               
002DDA  1               ; EOR
002DDA  1  A2 03                ldx #3          ;immediate - self modifying code
002DDC  1  B5 20        teor:   lda zpEO,x
002DDE  1  8D 0C 02             sta ex_eori+1   ;set EOR # operand
002DE1  1  A9 00 48 BD          set_ax  absEOa,0
002DE5  1  5E 02 28     
002DE8  1  20 0B 02             jsr ex_eori     ;execute EOR # in RAM
002DEB  1  08 DD 62 02          tst_ax  absrlo,absflo,0
002DEF  1  D0 FE 68 49  
002DF3  1  30 DD 66 02  
002DF9  1  CA                   dex
002DFA  1  10 E0                bpl teor
002DFC  1  A2 03                ldx #3
002DFE  1  B5 20        teor1:  lda zpEO,x
002E00  1  8D 0C 02             sta ex_eori+1   ;set EOR # operand
002E03  1  A9 FF 48 BD          set_ax  absEOa,$ff
002E07  1  5E 02 28     
002E0A  1  20 0B 02             jsr ex_eori     ;execute EOR # in RAM
002E0D  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
002E11  1  D0 FE 68 49  
002E15  1  7D DD 66 02  
002E1B  1  CA                   dex
002E1C  1  10 E0                bpl teor1
002E1E  1               
002E1E  1  A2 03                ldx #3      ;zp
002E20  1  B5 20        teor2:   lda zpEO,x
002E22  1  85 0C                sta zpt
002E24  1  A9 00 48 BD          set_ax  absEOa,0
002E28  1  5E 02 28     
002E2B  1  45 0C                eor zpt
002E2D  1  08 DD 62 02          tst_ax  absrlo,absflo,0
002E31  1  D0 FE 68 49  
002E35  1  30 DD 66 02  
002E3B  1  CA                   dex
002E3C  1  10 E2                bpl teor2
002E3E  1  A2 03                ldx #3
002E40  1  B5 20        teor3:  lda zpEO,x
002E42  1  85 0C                sta zpt
002E44  1  A9 FF 48 BD          set_ax  absEOa,$ff
002E48  1  5E 02 28     
002E4B  1  45 0C                eor zpt
002E4D  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
002E51  1  D0 FE 68 49  
002E55  1  7D DD 66 02  
002E5B  1  CA                   dex
002E5C  1  10 E2                bpl teor3
002E5E  1               
002E5E  1  A2 03                ldx #3      ;abs
002E60  1  B5 20        teor4:  lda zpEO,x
002E62  1  8D 03 02             sta abst
002E65  1  A9 00 48 BD          set_ax  absEOa,0
002E69  1  5E 02 28     
002E6C  1  4D 03 02             eor abst
002E6F  1  08 DD 62 02          tst_ax  absrlo,absflo,0
002E73  1  D0 FE 68 49  
002E77  1  30 DD 66 02  
002E7D  1  CA                   dex
002E7E  1  10 E0                bpl teor4
002E80  1  A2 03                ldx #3
002E82  1  B5 20        teor5:  lda zpEO,x
002E84  1  8D 03 02             sta abst
002E87  1  A9 FF 48 BD          set_ax  absEOa,$ff
002E8B  1  5E 02 28     
002E8E  1  4D 03 02             eor abst
002E91  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
002E95  1  D0 FE 68 49  
002E99  1  7D DD 66 02  
002E9F  1  CA                   dex
002EA0  1  10 02                bpl teor6
002EA2  1               
002EA2  1  A2 03                ldx #3      ;zp,x
002EA4  1               teor6:
002EA4  1  A9 00 48 BD          set_ax  absEOa,0
002EA8  1  5E 02 28     
002EAB  1  55 20                eor zpEO,x
002EAD  1  08 DD 62 02          tst_ax  absrlo,absflo,0
002EB1  1  D0 FE 68 49  
002EB5  1  30 DD 66 02  
002EBB  1  CA                   dex
002EBC  1  10 E6                bpl teor6
002EBE  1  A2 03                ldx #3
002EC0  1               teor7:
002EC0  1  A9 FF 48 BD          set_ax  absEOa,$ff
002EC4  1  5E 02 28     
002EC7  1  55 20                eor zpEO,x
002EC9  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
002ECD  1  D0 FE 68 49  
002ED1  1  7D DD 66 02  
002ED7  1  CA                   dex
002ED8  1  10 E6                bpl teor7
002EDA  1               
002EDA  1  A2 03                ldx #3      ;abs,x
002EDC  1               teor8:
002EDC  1  A9 00 48 BD          set_ax  absEOa,0
002EE0  1  5E 02 28     
002EE3  1  5D 52 02             eor absEO,x
002EE6  1  08 DD 62 02          tst_ax  absrlo,absflo,0
002EEA  1  D0 FE 68 49  
002EEE  1  30 DD 66 02  
002EF4  1  CA                   dex
002EF5  1  10 E5                bpl teor8
002EF7  1  A2 03                ldx #3
002EF9  1               teor9:
002EF9  1  A9 FF 48 BD          set_ax  absEOa,$ff
002EFD  1  5E 02 28     
002F00  1  5D 52 02             eor absEO,x
002F03  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
002F07  1  D0 FE 68 49  
002F0B  1  7D DD 66 02  
002F11  1  CA                   dex
002F12  1  10 E5                bpl teor9
002F14  1               
002F14  1  A0 03                ldy #3      ;abs,y
002F16  1               teor10:
002F16  1  A9 00 48 B9          set_ay  absEOa,0
002F1A  1  5E 02 28     
002F1D  1  59 52 02             eor absEO,y
002F20  1  08 D9 62 02          tst_ay  absrlo,absflo,0
002F24  1  D0 FE 68 49  
002F28  1  30 D9 66 02  
002F2E  1  88                   dey
002F2F  1  10 E5                bpl teor10
002F31  1  A0 03                ldy #3
002F33  1               teor11:
002F33  1  A9 FF 48 B9          set_ay  absEOa,$ff
002F37  1  5E 02 28     
002F3A  1  59 52 02             eor absEO,y
002F3D  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
002F41  1  D0 FE 68 49  
002F45  1  7D D9 66 02  
002F4B  1  88                   dey
002F4C  1  10 E5                bpl teor11
002F4E  1               
002F4E  1  A2 06                ldx #6      ;(zp,x)
002F50  1  A0 03                ldy #3
002F52  1               teor12:
002F52  1  A9 00 48 B9          set_ay  absEOa,0
002F56  1  5E 02 28     
002F59  1  41 42                eor (indEO,x)
002F5B  1  08 D9 62 02          tst_ay  absrlo,absflo,0
002F5F  1  D0 FE 68 49  
002F63  1  30 D9 66 02  
002F69  1  CA                   dex
002F6A  1  CA                   dex
002F6B  1  88                   dey
002F6C  1  10 E4                bpl teor12
002F6E  1  A2 06                ldx #6
002F70  1  A0 03                ldy #3
002F72  1               teor13:
002F72  1  A9 FF 48 B9          set_ay  absEOa,$ff
002F76  1  5E 02 28     
002F79  1  41 42                eor (indEO,x)
002F7B  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
002F7F  1  D0 FE 68 49  
002F83  1  7D D9 66 02  
002F89  1  CA                   dex
002F8A  1  CA                   dex
002F8B  1  88                   dey
002F8C  1  10 E4                bpl teor13
002F8E  1               
002F8E  1  A0 03                ldy #3      ;(zp),y
002F90  1               teor14:
002F90  1  A9 00 48 B9          set_ay  absEOa,0
002F94  1  5E 02 28     
002F97  1  51 42                eor (indEO),y
002F99  1  08 D9 62 02          tst_ay  absrlo,absflo,0
002F9D  1  D0 FE 68 49  
002FA1  1  30 D9 66 02  
002FA7  1  88                   dey
002FA8  1  10 E6                bpl teor14
002FAA  1  A0 03                ldy #3
002FAC  1               teor15:
002FAC  1  A9 FF 48 B9          set_ay  absEOa,$ff
002FB0  1  5E 02 28     
002FB3  1  51 42                eor (indEO),y
002FB5  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
002FB9  1  D0 FE 68 49  
002FBD  1  7D D9 66 02  
002FC3  1  88                   dey
002FC4  1  10 E6                bpl teor15
002FC6  1  AD 00 02 C9          next_test
002FCA  1  27 D0 FE A9  
002FCE  1  28 8D 00 02  
002FD2  1               
002FD2  1               ; OR
002FD2  1  A2 03                ldx #3          ;immediate - self modifying code
002FD4  1  B5 18        tora:   lda zpOR,x
002FD6  1  8D 0F 02             sta ex_orai+1   ;set ORA # operand
002FD9  1  A9 00 48 BD          set_ax  absORa,0
002FDD  1  56 02 28     
002FE0  1  20 0E 02             jsr ex_orai     ;execute ORA # in RAM
002FE3  1  08 DD 62 02          tst_ax  absrlo,absflo,0
002FE7  1  D0 FE 68 49  
002FEB  1  30 DD 66 02  
002FF1  1  CA                   dex
002FF2  1  10 E0                bpl tora
002FF4  1  A2 03                ldx #3
002FF6  1  B5 18        tora1:  lda zpOR,x
002FF8  1  8D 0F 02             sta ex_orai+1   ;set ORA # operand
002FFB  1  A9 FF 48 BD          set_ax  absORa,$ff
002FFF  1  56 02 28     
003002  1  20 0E 02             jsr ex_orai     ;execute ORA # in RAM
003005  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
003009  1  D0 FE 68 49  
00300D  1  7D DD 66 02  
003013  1  CA                   dex
003014  1  10 E0                bpl tora1
003016  1               
003016  1  A2 03                ldx #3      ;zp
003018  1  B5 18        tora2:  lda zpOR,x
00301A  1  85 0C                sta zpt
00301C  1  A9 00 48 BD          set_ax  absORa,0
003020  1  56 02 28     
003023  1  05 0C                ora zpt
003025  1  08 DD 62 02          tst_ax  absrlo,absflo,0
003029  1  D0 FE 68 49  
00302D  1  30 DD 66 02  
003033  1  CA                   dex
003034  1  10 E2                bpl tora2
003036  1  A2 03                ldx #3
003038  1  B5 18        tora3:  lda zpOR,x
00303A  1  85 0C                sta zpt
00303C  1  A9 FF 48 BD          set_ax  absORa,$ff
003040  1  56 02 28     
003043  1  05 0C                ora zpt
003045  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
003049  1  D0 FE 68 49  
00304D  1  7D DD 66 02  
003053  1  CA                   dex
003054  1  10 E2                bpl tora3
003056  1               
003056  1  A2 03                ldx #3      ;abs
003058  1  B5 18        tora4:  lda zpOR,x
00305A  1  8D 03 02             sta abst
00305D  1  A9 00 48 BD          set_ax  absORa,0
003061  1  56 02 28     
003064  1  0D 03 02             ora abst
003067  1  08 DD 62 02          tst_ax  absrlo,absflo,0
00306B  1  D0 FE 68 49  
00306F  1  30 DD 66 02  
003075  1  CA                   dex
003076  1  10 E0                bpl tora4
003078  1  A2 03                ldx #3
00307A  1  B5 18        tora5:  lda zpOR,x
00307C  1  8D 03 02             sta abst
00307F  1  A9 FF 48 BD          set_ax  absORa,$ff
003083  1  56 02 28     
003086  1  0D 03 02             ora abst
003089  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
00308D  1  D0 FE 68 49  
003091  1  7D DD 66 02  
003097  1  CA                   dex
003098  1  10 02                bpl tora6
00309A  1               
00309A  1  A2 03                ldx #3      ;zp,x
00309C  1               tora6:
00309C  1  A9 00 48 BD          set_ax  absORa,0
0030A0  1  56 02 28     
0030A3  1  15 18                ora zpOR,x
0030A5  1  08 DD 62 02          tst_ax  absrlo,absflo,0
0030A9  1  D0 FE 68 49  
0030AD  1  30 DD 66 02  
0030B3  1  CA                   dex
0030B4  1  10 E6                bpl tora6
0030B6  1  A2 03                ldx #3
0030B8  1               tora7:
0030B8  1  A9 FF 48 BD          set_ax  absORa,$ff
0030BC  1  56 02 28     
0030BF  1  15 18                ora zpOR,x
0030C1  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
0030C5  1  D0 FE 68 49  
0030C9  1  7D DD 66 02  
0030CF  1  CA                   dex
0030D0  1  10 E6                bpl tora7
0030D2  1               
0030D2  1  A2 03                ldx #3      ;abs,x
0030D4  1               tora8:
0030D4  1  A9 00 48 BD          set_ax  absORa,0
0030D8  1  56 02 28     
0030DB  1  1D 4A 02             ora absOR,x
0030DE  1  08 DD 62 02          tst_ax  absrlo,absflo,0
0030E2  1  D0 FE 68 49  
0030E6  1  30 DD 66 02  
0030EC  1  CA                   dex
0030ED  1  10 E5                bpl tora8
0030EF  1  A2 03                ldx #3
0030F1  1               tora9:
0030F1  1  A9 FF 48 BD          set_ax  absORa,$ff
0030F5  1  56 02 28     
0030F8  1  1D 4A 02             ora absOR,x
0030FB  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
0030FF  1  D0 FE 68 49  
003103  1  7D DD 66 02  
003109  1  CA                   dex
00310A  1  10 E5                bpl tora9
00310C  1               
00310C  1  A0 03                ldy #3      ;abs,y
00310E  1               tora10:
00310E  1  A9 00 48 B9          set_ay  absORa,0
003112  1  56 02 28     
003115  1  19 4A 02             ora absOR,y
003118  1  08 D9 62 02          tst_ay  absrlo,absflo,0
00311C  1  D0 FE 68 49  
003120  1  30 D9 66 02  
003126  1  88                   dey
003127  1  10 E5                bpl tora10
003129  1  A0 03                ldy #3
00312B  1               tora11:
00312B  1  A9 FF 48 B9          set_ay  absORa,$ff
00312F  1  56 02 28     
003132  1  19 4A 02             ora absOR,y
003135  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
003139  1  D0 FE 68 49  
00313D  1  7D D9 66 02  
003143  1  88                   dey
003144  1  10 E5                bpl tora11
003146  1               
003146  1  A2 06                ldx #6      ;(zp,x)
003148  1  A0 03                ldy #3
00314A  1               tora12:
00314A  1  A9 00 48 B9          set_ay  absORa,0
00314E  1  56 02 28     
003151  1  01 4A                ora (indOR,x)
003153  1  08 D9 62 02          tst_ay  absrlo,absflo,0
003157  1  D0 FE 68 49  
00315B  1  30 D9 66 02  
003161  1  CA                   dex
003162  1  CA                   dex
003163  1  88                   dey
003164  1  10 E4                bpl tora12
003166  1  A2 06                ldx #6
003168  1  A0 03                ldy #3
00316A  1               tora13:
00316A  1  A9 FF 48 B9          set_ay  absORa,$ff
00316E  1  56 02 28     
003171  1  01 4A                ora (indOR,x)
003173  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
003177  1  D0 FE 68 49  
00317B  1  7D D9 66 02  
003181  1  CA                   dex
003182  1  CA                   dex
003183  1  88                   dey
003184  1  10 E4                bpl tora13
003186  1               
003186  1  A0 03                ldy #3      ;(zp),y
003188  1               tora14:
003188  1  A9 00 48 B9          set_ay  absORa,0
00318C  1  56 02 28     
00318F  1  11 4A                ora (indOR),y
003191  1  08 D9 62 02          tst_ay  absrlo,absflo,0
003195  1  D0 FE 68 49  
003199  1  30 D9 66 02  
00319F  1  88                   dey
0031A0  1  10 E6                bpl tora14
0031A2  1  A0 03                ldy #3
0031A4  1               tora15:
0031A4  1  A9 FF 48 B9          set_ay  absORa,$ff
0031A8  1  56 02 28     
0031AB  1  11 4A                ora (indOR),y
0031AD  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
0031B1  1  D0 FE 68 49  
0031B5  1  7D D9 66 02  
0031BB  1  88                   dey
0031BC  1  10 E6                bpl tora15
0031BE  1                   .if I_flag = 3
0031BE  1  58                   cli
0031BF  1                   .endif
0031BF  1  AD 00 02 C9          next_test
0031C3  1  28 D0 FE A9  
0031C7  1  29 8D 00 02  
0031CB  1               
0031CB  1               ; full binary add/subtract test
0031CB  1               ; iterates through all combinations of operands and carry input
0031CB  1               ; uses increments/decrements to predict result & result flags
0031CB  1  D8                   cld
0031CC  1  A2 0E                ldx #ad2        ;for indexed test
0031CE  1  A0 FF                ldy #$ff        ;max range
0031D0  1  A9 00                lda #0          ;start with adding zeroes & no carry
0031D2  1  85 0C                sta adfc        ;carry in - for diag
0031D4  1  85 0D                sta ad1         ;operand 1 - accumulator
0031D6  1  85 0E                sta ad2         ;operand 2 - memory or immediate
0031D8  1  8D 03 02             sta ada2        ;non zp
0031DB  1  85 0F                sta adrl        ;expected result bits 0-7
0031DD  1  85 10                sta adrh        ;expected result bit 8 (carry out)
0031DF  1  A9 FF                lda #$ff        ;complemented operand 2 for subtract
0031E1  1  85 12                sta sb2
0031E3  1  8D 04 02             sta sba2        ;non zp
0031E6  1  A9 02                lda #2          ;expected Z-flag
0031E8  1  85 11                sta adrf
0031EA  1  18           tadd:   clc             ;test with carry clear
0031EB  1  20 65 34             jsr chkadd
0031EE  1  E6 0C                inc adfc        ;now with carry
0031F0  1  E6 0F                inc adrl        ;result +1
0031F2  1  08                   php             ;save N & Z from low result
0031F3  1  08                   php
0031F4  1  68                   pla             ;accu holds expected flags
0031F5  1  29 82                and #$82        ;mask N & Z
0031F7  1  28                   plp
0031F8  1  D0 02                bne tadd1
0031FA  1  E6 10                inc adrh        ;result bit 8 - carry
0031FC  1  05 10        tadd1:  ora adrh        ;merge C to expected flags
0031FE  1  85 11                sta adrf        ;save expected flags except overflow
003200  1  38                   sec             ;test with carry set
003201  1  20 65 34             jsr chkadd
003204  1  C6 0C                dec adfc        ;same for operand +1 but no carry
003206  1  E6 0D                inc ad1
003208  1  D0 E0                bne tadd        ;iterate op1
00320A  1  A9 00                lda #0          ;preset result to op2 when op1 = 0
00320C  1  85 10                sta adrh
00320E  1  EE 03 02             inc ada2
003211  1  E6 0E                inc ad2
003213  1  08                   php             ;save NZ as operand 2 becomes the new result
003214  1  68                   pla
003215  1  29 82                and #$82        ;mask N00000Z0
003217  1  85 11                sta adrf        ;no need to check carry as we are adding to 0
003219  1  C6 12                dec sb2         ;complement subtract operand 2
00321B  1  CE 04 02             dec sba2
00321E  1  A5 0E                lda ad2
003220  1  85 0F                sta adrl
003222  1  D0 C6                bne tadd        ;iterate op2
003224  1                   .if disable_decimal < 1
003224  1  AD 00 02 C9          next_test
003228  1  29 D0 FE A9  
00322C  1  2A 8D 00 02  
003230  1               
003230  1               ; decimal add/subtract test
003230  1               ; *** WARNING - tests documented behavior only! ***
003230  1               ;   only valid BCD operands are tested, N V Z flags are ignored
003230  1               ; iterates through all valid combinations of operands and carry input
003230  1               ; uses increments/decrements to predict result & carry flag
003230  1  F8                   sed
003231  1  A2 0E                ldx #ad2        ;for indexed test
003233  1  A0 FF                ldy #$ff        ;max range
003235  1  A9 99                lda #$99        ;start with adding 99 to 99 with carry
003237  1  85 0D                sta ad1         ;operand 1 - accumulator
003239  1  85 0E                sta ad2         ;operand 2 - memory or immediate
00323B  1  8D 03 02             sta ada2        ;non zp
00323E  1  85 0F                sta adrl        ;expected result bits 0-7
003240  1  A9 01                lda #1          ;set carry in & out
003242  1  85 0C                sta adfc        ;carry in - for diag
003244  1  85 10                sta adrh        ;expected result bit 8 (carry out)
003246  1  A9 00                lda #0          ;complemented operand 2 for subtract
003248  1  85 12                sta sb2
00324A  1  8D 04 02             sta sba2        ;non zp
00324D  1  38           tdad:   sec             ;test with carry set
00324E  1  20 32 33             jsr chkdad
003251  1  C6 0C                dec adfc        ;now with carry clear
003253  1  A5 0F                lda adrl        ;decimal adjust result
003255  1  D0 08                bne tdad1       ;skip clear carry & preset result 99 (9A-1)
003257  1  C6 10                dec adrh
003259  1  A9 99                lda #$99
00325B  1  85 0F                sta adrl
00325D  1  D0 12                bne tdad3
00325F  1  29 0F        tdad1:  and #$f         ;lower nibble mask
003261  1  D0 0C                bne tdad2       ;no decimal adjust needed
003263  1  C6 0F                dec adrl        ;decimal adjust (?0-6)
003265  1  C6 0F                dec adrl
003267  1  C6 0F                dec adrl
003269  1  C6 0F                dec adrl
00326B  1  C6 0F                dec adrl
00326D  1  C6 0F                dec adrl
00326F  1  C6 0F        tdad2:  dec adrl        ;result -1
003271  1  18           tdad3:  clc             ;test with carry clear
003272  1  20 32 33             jsr chkdad
003275  1  E6 0C                inc adfc        ;same for operand -1 but with carry
003277  1  A5 0D                lda ad1         ;decimal adjust operand 1
003279  1  F0 15                beq tdad5       ;iterate operand 2
00327B  1  29 0F                and #$f         ;lower nibble mask
00327D  1  D0 0C                bne tdad4       ;skip decimal adjust
00327F  1  C6 0D                dec ad1         ;decimal adjust (?0-6)
003281  1  C6 0D                dec ad1
003283  1  C6 0D                dec ad1
003285  1  C6 0D                dec ad1
003287  1  C6 0D                dec ad1
003289  1  C6 0D                dec ad1
00328B  1  C6 0D        tdad4:  dec ad1         ;operand 1 -1
00328D  1  4C 4D 32             jmp tdad        ;iterate op1
003290  1               
003290  1  A9 99        tdad5:  lda #$99        ;precharge op1 max
003292  1  85 0D                sta ad1
003294  1  A5 0E                lda ad2         ;decimal adjust operand 2
003296  1  F0 30                beq tdad7       ;end of iteration
003298  1  29 0F                and #$f         ;lower nibble mask
00329A  1  D0 18                bne tdad6       ;skip decimal adjust
00329C  1  C6 0E                dec ad2         ;decimal adjust (?0-6)
00329E  1  C6 0E                dec ad2
0032A0  1  C6 0E                dec ad2
0032A2  1  C6 0E                dec ad2
0032A4  1  C6 0E                dec ad2
0032A6  1  C6 0E                dec ad2
0032A8  1  E6 12                inc sb2         ;complemented decimal adjust for subtract (?9+6)
0032AA  1  E6 12                inc sb2
0032AC  1  E6 12                inc sb2
0032AE  1  E6 12                inc sb2
0032B0  1  E6 12                inc sb2
0032B2  1  E6 12                inc sb2
0032B4  1  C6 0E        tdad6:  dec ad2         ;operand 2 -1
0032B6  1  E6 12                inc sb2         ;complemented operand for subtract
0032B8  1  A5 12                lda sb2
0032BA  1  8D 04 02             sta sba2        ;copy as non zp operand
0032BD  1  A5 0E                lda ad2
0032BF  1  8D 03 02             sta ada2        ;copy as non zp operand
0032C2  1  85 0F                sta adrl        ;new result since op1+carry=00+carry +op2=op2
0032C4  1  E6 10                inc adrh        ;result carry
0032C6  1  D0 85                bne tdad        ;iterate op2
0032C8  1               tdad7:
0032C8  1  AD 00 02 C9          next_test
0032CC  1  2A D0 FE A9  
0032D0  1  2B 8D 00 02  
0032D4  1               
0032D4  1               ; decimal/binary switch test
0032D4  1               ; tests CLD, SED, PLP, RTI to properly switch between decimal & binary opcode
0032D4  1               ;   tables
0032D4  1  18                   clc
0032D5  1  D8                   cld
0032D6  1  08                   php
0032D7  1  A9 55                lda #$55
0032D9  1  69 55                adc #$55
0032DB  1  C9 AA                cmp #$aa
0032DD  1  D0 FE                trap_ne         ;expected binary result after cld
0032DF  1  18                   clc
0032E0  1  F8                   sed
0032E1  1  08                   php
0032E2  1  A9 55                lda #$55
0032E4  1  69 55                adc #$55
0032E6  1  C9 10                cmp #$10
0032E8  1  D0 FE                trap_ne         ;expected decimal result after sed
0032EA  1  D8                   cld
0032EB  1  28                   plp
0032EC  1  A9 55                lda #$55
0032EE  1  69 55                adc #$55
0032F0  1  C9 10                cmp #$10
0032F2  1  D0 FE                trap_ne         ;expected decimal result after plp D=1
0032F4  1  28                   plp
0032F5  1  A9 55                lda #$55
0032F7  1  69 55                adc #$55
0032F9  1  C9 AA                cmp #$aa
0032FB  1  D0 FE                trap_ne         ;expected binary result after plp D=0
0032FD  1  18                   clc
0032FE  1  A9 33                lda #>bin_rti_ret ;emulated interrupt for rti
003300  1  48                   pha
003301  1  A9 18                lda #<bin_rti_ret
003303  1  48                   pha
003304  1  08                   php
003305  1  F8                   sed
003306  1  A9 33                lda #>dec_rti_ret ;emulated interrupt for rti
003308  1  48                   pha
003309  1  A9 0F                lda #<dec_rti_ret
00330B  1  48                   pha
00330C  1  08                   php
00330D  1  D8                   cld
00330E  1  40                   rti
00330F  1               dec_rti_ret:
00330F  1  A9 55                lda #$55
003311  1  69 55                adc #$55
003313  1  C9 10                cmp #$10
003315  1  D0 FE                trap_ne         ;expected decimal result after rti D=1
003317  1  40                   rti
003318  1               bin_rti_ret:
003318  1  A9 55                lda #$55
00331A  1  69 55                adc #$55
00331C  1  C9 AA                cmp #$aa
00331E  1  D0 FE                trap_ne         ;expected binary result after rti D=0
003320  1                   .endif
003320  1               
003320  1  AD 00 02             lda test_case
003323  1  C9 2B                cmp #test_num
003325  1  D0 FE                trap_ne         ;previous test is out of sequence
003327  1  A9 F0                lda #$f0        ;mark opcode testing complete
003329  1  8D 00 02             sta test_case
00332C  1               
00332C  1               ; final RAM integrity test
00332C  1               ;   verifies that none of the previous tests has altered RAM outside of the
00332C  1               ;   designated write areas.
00332C  1                       check_ram
00332C  1               ; *** DEBUG INFO ***
00332C  1               ; to debug checksum errors uncomment check_ram in the next_test macro to
00332C  1               ; narrow down the responsible opcode.
00332C  1               ; may give false errors when monitor, OS or other background activity is
00332C  1               ; allowed during previous tests.
00332C  1               
00332C  1               
00332C  1               ; S U C C E S S ************************************************
00332C  1               ; -------------
00332C  1  4C 2C 33             success         ;if you get here everything went well
00332F  1               ; -------------
00332F  1               ; S U C C E S S ************************************************
00332F  1  4C 00 04             jmp start       ;run again
003332  1               
003332  1                   .if disable_decimal < 1
003332  1               ; core subroutine of the decimal add/subtract test
003332  1               ; *** WARNING - tests documented behavior only! ***
003332  1               ;   only valid BCD operands are tested, N V Z flags are ignored
003332  1               ; iterates through all valid combinations of operands and carry input
003332  1               ; uses increments/decrements to predict result & carry flag
003332  1               chkdad:
003332  1               ; decimal ADC / SBC zp
003332  1  08                   php             ;save carry for subtract
003333  1  A5 0D                lda ad1
003335  1  65 0E                adc ad2         ;perform add
003337  1  08                   php
003338  1  C5 0F                cmp adrl        ;check result
00333A  1  D0 FE                trap_ne         ;bad result
00333C  1  68                   pla             ;check flags
00333D  1  29 01                and #1          ;mask carry
00333F  1  C5 10                cmp adrh
003341  1  D0 FE                trap_ne         ;bad carry
003343  1  28                   plp
003344  1  08                   php             ;save carry for next add
003345  1  A5 0D                lda ad1
003347  1  E5 12                sbc sb2         ;perform subtract
003349  1  08                   php
00334A  1  C5 0F                cmp adrl        ;check result
00334C  1  D0 FE                trap_ne         ;bad result
00334E  1  68                   pla             ;check flags
00334F  1  29 01                and #1          ;mask carry
003351  1  C5 10                cmp adrh
003353  1  D0 FE                trap_ne         ;bad flags
003355  1  28                   plp
003356  1               ; decimal ADC / SBC abs
003356  1  08                   php             ;save carry for subtract
003357  1  A5 0D                lda ad1
003359  1  6D 03 02             adc ada2        ;perform add
00335C  1  08                   php
00335D  1  C5 0F                cmp adrl        ;check result
00335F  1  D0 FE                trap_ne         ;bad result
003361  1  68                   pla             ;check flags
003362  1  29 01                and #1          ;mask carry
003364  1  C5 10                cmp adrh
003366  1  D0 FE                trap_ne         ;bad carry
003368  1  28                   plp
003369  1  08                   php             ;save carry for next add
00336A  1  A5 0D                lda ad1
00336C  1  ED 04 02             sbc sba2        ;perform subtract
00336F  1  08                   php
003370  1  C5 0F                cmp adrl        ;check result
003372  1  D0 FE                trap_ne         ;bad result
003374  1  68                   pla             ;check flags
003375  1  29 01                and #1          ;mask carry
003377  1  C5 10                cmp adrh
003379  1  D0 FE                trap_ne         ;bad carry
00337B  1  28                   plp
00337C  1               ; decimal ADC / SBC #
00337C  1  08                   php             ;save carry for subtract
00337D  1  A5 0E                lda ad2
00337F  1  8D 12 02             sta ex_adci+1   ;set ADC # operand
003382  1  A5 0D                lda ad1
003384  1  20 11 02             jsr ex_adci     ;execute ADC # in RAM
003387  1  08                   php
003388  1  C5 0F                cmp adrl        ;check result
00338A  1  D0 FE                trap_ne         ;bad result
00338C  1  68                   pla             ;check flags
00338D  1  29 01                and #1          ;mask carry
00338F  1  C5 10                cmp adrh
003391  1  D0 FE                trap_ne         ;bad carry
003393  1  28                   plp
003394  1  08                   php             ;save carry for next add
003395  1  A5 12                lda sb2
003397  1  8D 15 02             sta ex_sbci+1   ;set SBC # operand
00339A  1  A5 0D                lda ad1
00339C  1  20 14 02             jsr ex_sbci     ;execute SBC # in RAM
00339F  1  08                   php
0033A0  1  C5 0F                cmp adrl        ;check result
0033A2  1  D0 FE                trap_ne         ;bad result
0033A4  1  68                   pla             ;check flags
0033A5  1  29 01                and #1          ;mask carry
0033A7  1  C5 10                cmp adrh
0033A9  1  D0 FE                trap_ne         ;bad carry
0033AB  1  28                   plp
0033AC  1               ; decimal ADC / SBC zp,x
0033AC  1  08                   php             ;save carry for subtract
0033AD  1  A5 0D                lda ad1
0033AF  1  75 00                adc 0,x         ;perform add
0033B1  1  08                   php
0033B2  1  C5 0F                cmp adrl        ;check result
0033B4  1  D0 FE                trap_ne         ;bad result
0033B6  1  68                   pla             ;check flags
0033B7  1  29 01                and #1          ;mask carry
0033B9  1  C5 10                cmp adrh
0033BB  1  D0 FE                trap_ne         ;bad carry
0033BD  1  28                   plp
0033BE  1  08                   php             ;save carry for next add
0033BF  1  A5 0D                lda ad1
0033C1  1  F5 04                sbc sb2-ad2,x   ;perform subtract
0033C3  1  08                   php
0033C4  1  C5 0F                cmp adrl        ;check result
0033C6  1  D0 FE                trap_ne         ;bad result
0033C8  1  68                   pla             ;check flags
0033C9  1  29 01                and #1          ;mask carry
0033CB  1  C5 10                cmp adrh
0033CD  1  D0 FE                trap_ne         ;bad carry
0033CF  1  28                   plp
0033D0  1               ; decimal ADC / SBC abs,x
0033D0  1  08                   php             ;save carry for subtract
0033D1  1  A5 0D                lda ad1
0033D3  1  7D F5 01             adc ada2-ad2,x  ;perform add
0033D6  1  08                   php
0033D7  1  C5 0F                cmp adrl        ;check result
0033D9  1  D0 FE                trap_ne         ;bad result
0033DB  1  68                   pla             ;check flags
0033DC  1  29 01                and #1          ;mask carry
0033DE  1  C5 10                cmp adrh
0033E0  1  D0 FE                trap_ne         ;bad carry
0033E2  1  28                   plp
0033E3  1  08                   php             ;save carry for next add
0033E4  1  A5 0D                lda ad1
0033E6  1  FD F6 01             sbc sba2-ad2,x  ;perform subtract
0033E9  1  08                   php
0033EA  1  C5 0F                cmp adrl        ;check result
0033EC  1  D0 FE                trap_ne         ;bad result
0033EE  1  68                   pla             ;check flags
0033EF  1  29 01                and #1          ;mask carry
0033F1  1  C5 10                cmp adrh
0033F3  1  D0 FE                trap_ne         ;bad carry
0033F5  1  28                   plp
0033F6  1               ; decimal ADC / SBC abs,y
0033F6  1  08                   php             ;save carry for subtract
0033F7  1  A5 0D                lda ad1
0033F9  1  79 04 01             adc ada2-$ff,y  ;perform add
0033FC  1  08                   php
0033FD  1  C5 0F                cmp adrl        ;check result
0033FF  1  D0 FE                trap_ne         ;bad result
003401  1  68                   pla             ;check flags
003402  1  29 01                and #1          ;mask carry
003404  1  C5 10                cmp adrh
003406  1  D0 FE                trap_ne         ;bad carry
003408  1  28                   plp
003409  1  08                   php             ;save carry for next add
00340A  1  A5 0D                lda ad1
00340C  1  F9 05 01             sbc sba2-$ff,y  ;perform subtract
00340F  1  08                   php
003410  1  C5 0F                cmp adrl        ;check result
003412  1  D0 FE                trap_ne         ;bad result
003414  1  68                   pla             ;check flags
003415  1  29 01                and #1          ;mask carry
003417  1  C5 10                cmp adrh
003419  1  D0 FE                trap_ne         ;bad carry
00341B  1  28                   plp
00341C  1               ; decimal ADC / SBC (zp,x)
00341C  1  08                   php             ;save carry for subtract
00341D  1  A5 0D                lda ad1
00341F  1  61 44                adc (<adi2-ad2,x) ;perform add
003421  1  08                   php
003422  1  C5 0F                cmp adrl        ;check result
003424  1  D0 FE                trap_ne         ;bad result
003426  1  68                   pla             ;check flags
003427  1  29 01                and #1          ;mask carry
003429  1  C5 10                cmp adrh
00342B  1  D0 FE                trap_ne         ;bad carry
00342D  1  28                   plp
00342E  1  08                   php             ;save carry for next add
00342F  1  A5 0D                lda ad1
003431  1  E1 46                sbc (<sbi2-ad2,x) ;perform subtract
003433  1  08                   php
003434  1  C5 0F                cmp adrl        ;check result
003436  1  D0 FE                trap_ne         ;bad result
003438  1  68                   pla             ;check flags
003439  1  29 01                and #1          ;mask carry
00343B  1  C5 10                cmp adrh
00343D  1  D0 FE                trap_ne         ;bad carry
00343F  1  28                   plp
003440  1               ; decimal ADC / SBC (abs),y
003440  1  08                   php             ;save carry for subtract
003441  1  A5 0D                lda ad1
003443  1  71 56                adc (adiy2),y   ;perform add
003445  1  08                   php
003446  1  C5 0F                cmp adrl        ;check result
003448  1  D0 FE                trap_ne         ;bad result
00344A  1  68                   pla             ;check flags
00344B  1  29 01                and #1          ;mask carry
00344D  1  C5 10                cmp adrh
00344F  1  D0 FE                trap_ne         ;bad carry
003451  1  28                   plp
003452  1  08                   php             ;save carry for next add
003453  1  A5 0D                lda ad1
003455  1  F1 58                sbc (sbiy2),y   ;perform subtract
003457  1  08                   php
003458  1  C5 0F                cmp adrl        ;check result
00345A  1  D0 FE                trap_ne         ;bad result
00345C  1  68                   pla             ;check flags
00345D  1  29 01                and #1          ;mask carry
00345F  1  C5 10                cmp adrh
003461  1  D0 FE                trap_ne         ;bad carry
003463  1  28                   plp
003464  1  60                   rts
003465  1                   .endif
003465  1               
003465  1               ; core subroutine of the full binary add/subtract test
003465  1               ; iterates through all combinations of operands and carry input
003465  1               ; uses increments/decrements to predict result & result flags
003465  1  A5 11        chkadd: lda adrf        ;add V-flag if overflow
003467  1  29 83                and #$83        ;keep N-----ZC / clear V
003469  1  48                   pha
00346A  1  A5 0D                lda ad1         ;test sign unequal between operands
00346C  1  45 0E                eor ad2
00346E  1  30 0A                bmi ckad1       ;no overflow possible - operands have different sign
003470  1  A5 0D                lda ad1         ;test sign equal between operands and result
003472  1  45 0F                eor adrl
003474  1  10 04                bpl ckad1       ;no overflow occured - operand and result have same sign
003476  1  68                   pla
003477  1  09 40                ora #$40        ;set V
003479  1  48                   pha
00347A  1  68           ckad1:  pla
00347B  1  85 11                sta adrf        ;save expected flags
00347D  1               ; binary ADC / SBC zp
00347D  1  08                   php             ;save carry for subtract
00347E  1  A5 0D                lda ad1
003480  1  65 0E                adc ad2         ;perform add
003482  1  08                   php
003483  1  C5 0F                cmp adrl        ;check result
003485  1  D0 FE                trap_ne         ;bad result
003487  1  68                   pla             ;check flags
003488  1  29 C3                and #$c3        ;mask NV----ZC
00348A  1  C5 11                cmp adrf
00348C  1  D0 FE                trap_ne         ;bad flags
00348E  1  28                   plp
00348F  1  08                   php             ;save carry for next add
003490  1  A5 0D                lda ad1
003492  1  E5 12                sbc sb2         ;perform subtract
003494  1  08                   php
003495  1  C5 0F                cmp adrl        ;check result
003497  1  D0 FE                trap_ne         ;bad result
003499  1  68                   pla             ;check flags
00349A  1  29 C3                and #$c3        ;mask NV----ZC
00349C  1  C5 11                cmp adrf
00349E  1  D0 FE                trap_ne         ;bad flags
0034A0  1  28                   plp
0034A1  1               ; binary ADC / SBC abs
0034A1  1  08                   php             ;save carry for subtract
0034A2  1  A5 0D                lda ad1
0034A4  1  6D 03 02             adc ada2        ;perform add
0034A7  1  08                   php
0034A8  1  C5 0F                cmp adrl        ;check result
0034AA  1  D0 FE                trap_ne         ;bad result
0034AC  1  68                   pla             ;check flags
0034AD  1  29 C3                and #$c3        ;mask NV----ZC
0034AF  1  C5 11                cmp adrf
0034B1  1  D0 FE                trap_ne         ;bad flags
0034B3  1  28                   plp
0034B4  1  08                   php             ;save carry for next add
0034B5  1  A5 0D                lda ad1
0034B7  1  ED 04 02             sbc sba2        ;perform subtract
0034BA  1  08                   php
0034BB  1  C5 0F                cmp adrl        ;check result
0034BD  1  D0 FE                trap_ne         ;bad result
0034BF  1  68                   pla             ;check flags
0034C0  1  29 C3                and #$c3        ;mask NV----ZC
0034C2  1  C5 11                cmp adrf
0034C4  1  D0 FE                trap_ne         ;bad flags
0034C6  1  28                   plp
0034C7  1               ; binary ADC / SBC #
0034C7  1  08                   php             ;save carry for subtract
0034C8  1  A5 0E                lda ad2
0034CA  1  8D 12 02             sta ex_adci+1   ;set ADC # operand
0034CD  1  A5 0D                lda ad1
0034CF  1  20 11 02             jsr ex_adci     ;execute ADC # in RAM
0034D2  1  08                   php
0034D3  1  C5 0F                cmp adrl        ;check result
0034D5  1  D0 FE                trap_ne         ;bad result
0034D7  1  68                   pla             ;check flags
0034D8  1  29 C3                and #$c3        ;mask NV----ZC
0034DA  1  C5 11                cmp adrf
0034DC  1  D0 FE                trap_ne         ;bad flags
0034DE  1  28                   plp
0034DF  1  08                   php             ;save carry for next add
0034E0  1  A5 12                lda sb2
0034E2  1  8D 15 02             sta ex_sbci+1   ;set SBC # operand
0034E5  1  A5 0D                lda ad1
0034E7  1  20 14 02             jsr ex_sbci     ;execute SBC # in RAM
0034EA  1  08                   php
0034EB  1  C5 0F                cmp adrl        ;check result
0034ED  1  D0 FE                trap_ne         ;bad result
0034EF  1  68                   pla             ;check flags
0034F0  1  29 C3                and #$c3        ;mask NV----ZC
0034F2  1  C5 11                cmp adrf
0034F4  1  D0 FE                trap_ne         ;bad flags
0034F6  1  28                   plp
0034F7  1               ; binary ADC / SBC zp,x
0034F7  1  08                   php             ;save carry for subtract
0034F8  1  A5 0D                lda ad1
0034FA  1  75 00                adc 0,x         ;perform add
0034FC  1  08                   php
0034FD  1  C5 0F                cmp adrl        ;check result
0034FF  1  D0 FE                trap_ne         ;bad result
003501  1  68                   pla             ;check flags
003502  1  29 C3                and #$c3        ;mask NV----ZC
003504  1  C5 11                cmp adrf
003506  1  D0 FE                trap_ne         ;bad flags
003508  1  28                   plp
003509  1  08                   php             ;save carry for next add
00350A  1  A5 0D                lda ad1
00350C  1  F5 04                sbc sb2-ad2,x   ;perform subtract
00350E  1  08                   php
00350F  1  C5 0F                cmp adrl        ;check result
003511  1  D0 FE                trap_ne         ;bad result
003513  1  68                   pla             ;check flags
003514  1  29 C3                and #$c3        ;mask NV----ZC
003516  1  C5 11                cmp adrf
003518  1  D0 FE                trap_ne         ;bad flags
00351A  1  28                   plp
00351B  1               ; binary ADC / SBC abs,x
00351B  1  08                   php             ;save carry for subtract
00351C  1  A5 0D                lda ad1
00351E  1  7D F5 01             adc ada2-ad2,x  ;perform add
003521  1  08                   php
003522  1  C5 0F                cmp adrl        ;check result
003524  1  D0 FE                trap_ne         ;bad result
003526  1  68                   pla             ;check flags
003527  1  29 C3                and #$c3        ;mask NV----ZC
003529  1  C5 11                cmp adrf
00352B  1  D0 FE                trap_ne         ;bad flags
00352D  1  28                   plp
00352E  1  08                   php             ;save carry for next add
00352F  1  A5 0D                lda ad1
003531  1  FD F6 01             sbc sba2-ad2,x  ;perform subtract
003534  1  08                   php
003535  1  C5 0F                cmp adrl        ;check result
003537  1  D0 FE                trap_ne         ;bad result
003539  1  68                   pla             ;check flags
00353A  1  29 C3                and #$c3        ;mask NV----ZC
00353C  1  C5 11                cmp adrf
00353E  1  D0 FE                trap_ne         ;bad flags
003540  1  28                   plp
003541  1               ; binary ADC / SBC abs,y
003541  1  08                   php             ;save carry for subtract
003542  1  A5 0D                lda ad1
003544  1  79 04 01             adc ada2-$ff,y  ;perform add
003547  1  08                   php
003548  1  C5 0F                cmp adrl        ;check result
00354A  1  D0 FE                trap_ne         ;bad result
00354C  1  68                   pla             ;check flags
00354D  1  29 C3                and #$c3        ;mask NV----ZC
00354F  1  C5 11                cmp adrf
003551  1  D0 FE                trap_ne         ;bad flags
003553  1  28                   plp
003554  1  08                   php             ;save carry for next add
003555  1  A5 0D                lda ad1
003557  1  F9 05 01             sbc sba2-$ff,y  ;perform subtract
00355A  1  08                   php
00355B  1  C5 0F                cmp adrl        ;check result
00355D  1  D0 FE                trap_ne         ;bad result
00355F  1  68                   pla             ;check flags
003560  1  29 C3                and #$c3        ;mask NV----ZC
003562  1  C5 11                cmp adrf
003564  1  D0 FE                trap_ne         ;bad flags
003566  1  28                   plp
003567  1               ; binary ADC / SBC (zp,x)
003567  1  08                   php             ;save carry for subtract
003568  1  A5 0D                lda ad1
00356A  1  61 44                adc (<adi2-ad2,x) ;perform add
00356C  1  08                   php
00356D  1  C5 0F                cmp adrl        ;check result
00356F  1  D0 FE                trap_ne         ;bad result
003571  1  68                   pla             ;check flags
003572  1  29 C3                and #$c3        ;mask NV----ZC
003574  1  C5 11                cmp adrf
003576  1  D0 FE                trap_ne         ;bad flags
003578  1  28                   plp
003579  1  08                   php             ;save carry for next add
00357A  1  A5 0D                lda ad1
00357C  1  E1 46                sbc (<sbi2-ad2,x) ;perform subtract
00357E  1  08                   php
00357F  1  C5 0F                cmp adrl        ;check result
003581  1  D0 FE                trap_ne         ;bad result
003583  1  68                   pla             ;check flags
003584  1  29 C3                and #$c3        ;mask NV----ZC
003586  1  C5 11                cmp adrf
003588  1  D0 FE                trap_ne         ;bad flags
00358A  1  28                   plp
00358B  1               ; binary ADC / SBC (abs),y
00358B  1  08                   php             ;save carry for subtract
00358C  1  A5 0D                lda ad1
00358E  1  71 56                adc (adiy2),y   ;perform add
003590  1  08                   php
003591  1  C5 0F                cmp adrl        ;check result
003593  1  D0 FE                trap_ne         ;bad result
003595  1  68                   pla             ;check flags
003596  1  29 C3                and #$c3        ;mask NV----ZC
003598  1  C5 11                cmp adrf
00359A  1  D0 FE                trap_ne         ;bad flags
00359C  1  28                   plp
00359D  1  08                   php             ;save carry for next add
00359E  1  A5 0D                lda ad1
0035A0  1  F1 58                sbc (sbiy2),y   ;perform subtract
0035A2  1  08                   php
0035A3  1  C5 0F                cmp adrl        ;check result
0035A5  1  D0 FE                trap_ne         ;bad result
0035A7  1  68                   pla             ;check flags
0035A8  1  29 C3                and #$c3        ;mask NV----ZC
0035AA  1  C5 11                cmp adrf
0035AC  1  D0 FE                trap_ne         ;bad flags
0035AE  1  28                   plp
0035AF  1  60                   rts
0035B0  1               
0035B0  1               ; target for the jump absolute test
0035B0  1  88                   dey
0035B1  1  88                   dey
0035B2  1               test_far:
0035B2  1  08                   php             ;either SP or Y count will fail, if we do not hit
0035B3  1  88                   dey
0035B4  1  88                   dey
0035B5  1  88                   dey
0035B6  1  28                   plp
0035B7  1  B0 FE                trap_cs         ;flags loaded?
0035B9  1  70 FE                trap_vs
0035BB  1  30 FE                trap_mi
0035BD  1  F0 FE                trap_eq
0035BF  1  C9 46                cmp #'F'        ;registers loaded?
0035C1  1  D0 FE                trap_ne
0035C3  1  E0 41                cpx #'A'
0035C5  1  D0 FE                trap_ne
0035C7  1  C0 4F                cpy #('R'-3)
0035C9  1  D0 FE                trap_ne
0035CB  1  48                   pha             ;save a,x
0035CC  1  8A                   txa
0035CD  1  48                   pha
0035CE  1  BA                   tsx
0035CF  1  E0 FD                cpx #$fd        ;check SP
0035D1  1  D0 FE                trap_ne
0035D3  1  68                   pla             ;restore x
0035D4  1  AA                   tax
0035D5  1  A9 FF 48 28          set_stat $ff
0035D9  1  68                   pla             ;restore a
0035DA  1  E8                   inx             ;return registers with modifications
0035DB  1  49 AA                eor #$aa        ;N=1, V=1, Z=0, C=1
0035DD  1  4C D2 07             jmp far_ret
0035E0  1               
0035E0  1               ; target for the jump indirect test
0035E0  1               ;       .align 2
0035E0  1                       .if * & 1       ; workaround for problems with .align 2
0035E0  1                           .byte 0     ;
0035E0  1                       .endif          ;
0035E0  1               ptr_tst_ind:
0035E0  1  E9 35                .word   test_ind
0035E2  1               ptr_ind_ret:
0035E2  1  27 08                .word   ind_ret
0035E4  1  4C E4 35             trap            ;runover protection
0035E7  1  88                   dey
0035E8  1  88                   dey
0035E9  1               test_ind:
0035E9  1  08                   php             ;either SP or Y count will fail, if we do not hit
0035EA  1  88                   dey
0035EB  1  88                   dey
0035EC  1  88                   dey
0035ED  1  28                   plp
0035EE  1  B0 FE                trap_cs         ;flags loaded?
0035F0  1  70 FE                trap_vs
0035F2  1  30 FE                trap_mi
0035F4  1  F0 FE                trap_eq
0035F6  1  C9 49                cmp #'I'        ;registers loaded?
0035F8  1  D0 FE                trap_ne
0035FA  1  E0 4E                cpx #'N'
0035FC  1  D0 FE                trap_ne
0035FE  1  C0 41                cpy #('D'-3)
003600  1  D0 FE                trap_ne
003602  1  48                   pha             ;save a,x
003603  1  8A                   txa
003604  1  48                   pha
003605  1  BA                   tsx
003606  1  E0 FD                cpx #$fd        ;check SP
003608  1  D0 FE                trap_ne
00360A  1  68                   pla             ;restore x
00360B  1  AA                   tax
00360C  1  A9 FF 48 28          set_stat $ff
003610  1  68                   pla             ;restore a
003611  1  E8                   inx             ;return registers with modifications
003612  1  49 AA                eor #$aa        ;N=1, V=1, Z=0, C=1
003614  1  6C E2 35             jmp (ptr_ind_ret)
003617  1  4C 17 36             trap            ;runover protection
00361A  1  4C 00 04             jmp start       ;catastrophic error - cannot continue
00361D  1               
00361D  1               ; target for the jump subroutine test
00361D  1  88                   dey
00361E  1  88                   dey
00361F  1               test_jsr:
00361F  1  08                   php             ;either SP or Y count will fail, if we do not hit
003620  1  88                   dey
003621  1  88                   dey
003622  1  88                   dey
003623  1  28                   plp
003624  1  B0 FE                trap_cs         ;flags loaded?
003626  1  70 FE                trap_vs
003628  1  30 FE                trap_mi
00362A  1  F0 FE                trap_eq
00362C  1  C9 4A                cmp #'J'        ;registers loaded?
00362E  1  D0 FE                trap_ne
003630  1  E0 53                cpx #'S'
003632  1  D0 FE                trap_ne
003634  1  C0 4F                cpy #('R'-3)
003636  1  D0 FE                trap_ne
003638  1  48                   pha             ;save a,x
003639  1  8A                   txa
00363A  1  48                   pha
00363B  1  BA                   tsx             ;sp -4? (return addr,a,x)
00363C  1  E0 FB                cpx #$fb
00363E  1  D0 FE                trap_ne
003640  1  AD FF 01             lda $1ff        ;propper return on stack
003643  1  C9 08                cmp #>jsr_ret
003645  1  D0 FE                trap_ne
003647  1  AD FE 01             lda $1fe
00364A  1  C9 5D                cmp #<jsr_ret
00364C  1  D0 FE                trap_ne
00364E  1  A9 FF 48 28          set_stat $ff
003652  1  68                   pla             ;pull x,a
003653  1  AA                   tax
003654  1  68                   pla
003655  1  E8                   inx             ;return registers with modifications
003656  1  49 AA                eor #$aa        ;N=1, V=1, Z=0, C=1
003658  1  60                   rts
003659  1  4C 59 36             trap            ;runover protection
00365C  1  4C 00 04             jmp start       ;catastrophic error - cannot continue
00365F  1               
00365F  1               ;trap in case of unexpected IRQ, NMI, BRK, RESET - BRK test target
00365F  1               nmi_trap:
00365F  1  4C 5F 36             trap            ;check stack for conditions at NMI
003662  1  4C 00 04             jmp start       ;catastrophic error - cannot continue
003665  1               res_trap:
003665  1  4C 65 36             trap            ;unexpected RESET
003668  1  4C 00 04             jmp start       ;catastrophic error - cannot continue
00366B  1               
00366B  1  88                   dey
00366C  1  88                   dey
00366D  1               irq_trap:               ;BRK test or unextpected BRK or IRQ
00366D  1  08                   php             ;either SP or Y count will fail, if we do not hit
00366E  1  88                   dey
00366F  1  88                   dey
003670  1  88                   dey
003671  1                       ;next traps could be caused by unexpected BRK or IRQ
003671  1                       ;check stack for BREAK and originating location
003671  1                       ;possible jump/branch into weeds (uninitialized space)
003671  1  C9 BD                cmp #$ff-'B'    ;BRK pass 2 registers loaded?
003673  1  F0 42                beq break2
003675  1  C9 42                cmp #'B'        ;BRK pass 1 registers loaded?
003677  1  D0 FE                trap_ne
003679  1  E0 52                cpx #'R'
00367B  1  D0 FE                trap_ne
00367D  1  C0 48                cpy #'K'-3
00367F  1  D0 FE                trap_ne
003681  1  85 0A                sta irq_a       ;save registers during break test
003683  1  86 0B                stx irq_x
003685  1  BA                   tsx             ;test break on stack
003686  1  BD 02 01             lda $102,x
003689  1  C9 30                cmp_flag 0      ;break test should have B=1 & unused=1 on stack
00368B  1  D0 FE                trap_ne         ; - no break flag on stack
00368D  1  68                   pla
00368E  1  C9 34                cmp_flag intdis ;should have added interrupt disable
003690  1  D0 FE                trap_ne
003692  1  BA                   tsx
003693  1  E0 FC                cpx #$fc        ;sp -3? (return addr, flags)
003695  1  D0 FE                trap_ne
003697  1  AD FF 01             lda $1ff        ;propper return on stack
00369A  1  C9 08                cmp #>brk_ret0
00369C  1  D0 FE                trap_ne
00369E  1  AD FE 01             lda $1fe
0036A1  1  C9 94                cmp #<brk_ret0
0036A3  1  D0 FE                trap_ne
0036A5  1  A9 FF                load_flag $ff
0036A7  1  48                   pha
0036A8  1  A6 0B                ldx irq_x
0036AA  1  E8                   inx             ;return registers with modifications
0036AB  1  A5 0A                lda irq_a
0036AD  1  49 AA                eor #$aa
0036AF  1  28                   plp             ;N=1, V=1, Z=1, C=1 but original flags should be restored
0036B0  1  40                   rti
0036B1  1  4C B1 36             trap            ;runover protection
0036B4  1  4C 00 04             jmp start       ;catastrophic error - cannot continue
0036B7  1               
0036B7  1               break2:                 ;BRK pass 2
0036B7  1  E0 AD                cpx #$ff-'R'
0036B9  1  D0 FE                trap_ne
0036BB  1  C0 B1                cpy #$ff-'K'-3
0036BD  1  D0 FE                trap_ne
0036BF  1  85 0A                sta irq_a       ;save registers during break test
0036C1  1  86 0B                stx irq_x
0036C3  1  BA                   tsx             ;test break on stack
0036C4  1  BD 02 01             lda $102,x
0036C7  1  C9 FF                cmp_flag $ff    ;break test should have B=1
0036C9  1  D0 FE                trap_ne         ; - no break flag on stack
0036CB  1  68                   pla
0036CC  1  09 08                ora #decmode    ;ignore decmode cleared if 65c02
0036CE  1  C9 FF                cmp_flag $ff    ;actual passed flags
0036D0  1  D0 FE                trap_ne
0036D2  1  BA                   tsx
0036D3  1  E0 FC                cpx #$fc        ;sp -3? (return addr, flags)
0036D5  1  D0 FE                trap_ne
0036D7  1  AD FF 01             lda $1ff        ;propper return on stack
0036DA  1  C9 08                cmp #>brk_ret1
0036DC  1  D0 FE                trap_ne
0036DE  1  AD FE 01             lda $1fe
0036E1  1  C9 BA                cmp #<brk_ret1
0036E3  1  D0 FE                trap_ne
0036E5  1  A9 04                load_flag intdis
0036E7  1  48                   pha
0036E8  1  A6 0B                ldx irq_x
0036EA  1  E8                   inx             ;return registers with modifications
0036EB  1  A5 0A                lda irq_a
0036ED  1  49 AA                eor #$aa
0036EF  1  28                   plp             ;N=0, V=0, Z=0, C=0 but original flags should be restored
0036F0  1  40                   rti
0036F1  1  4C F1 36             trap            ;runover protection
0036F4  1  4C 00 04             jmp start       ;catastrophic error - cannot continue
0036F7  1               
0036F7  1                   .if report = 1
0036F7  1                       include "report.i65"
0036F7  1                   .endif
0036F7  1               
0036F7  1               ;copy of data to initialize BSS segment
0036F7  1                   .if load_data_direct <> 1
0036F7  1               zp_init:
0036F7  1               zp1_:   .byte   $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
0036F7  1               zp7f_:  .byte   $7f             ;test pattern for compare
0036F7  1               ;logical zeropage operands
0036F7  1               zpOR_:  .byte   0,$1f,$71,$80   ;test pattern for OR
0036F7  1               zpAN_:  .byte   $0f,$ff,$7f,$80 ;test pattern for AND
0036F7  1               zpEO_:  .byte   $ff,$0f,$8f,$8f ;test pattern for EOR
0036F7  1               ;indirect addressing pointers
0036F7  1               ind1_:  .word   abs1            ;indirect pointer to pattern in absolute memory
0036F7  1                       .word   abs1+1
0036F7  1                       .word   abs1+2
0036F7  1                       .word   abs1+3
0036F7  1                       .word   abs7f
0036F7  1               inw1_:  .word   abs1-$f8        ;indirect pointer for wrap-test pattern
0036F7  1               indt_:  .word   abst            ;indirect pointer to store area in absolute memory
0036F7  1                       .word   abst+1
0036F7  1                       .word   abst+2
0036F7  1                       .word   abst+3
0036F7  1               inwt_:  .word   abst-$f8        ;indirect pointer for wrap-test store
0036F7  1               indAN_: .word   absAN           ;indirect pointer to AND pattern in absolute memory
0036F7  1                       .word   absAN+1
0036F7  1                       .word   absAN+2
0036F7  1                       .word   absAN+3
0036F7  1               indEO_: .word   absEO           ;indirect pointer to EOR pattern in absolute memory
0036F7  1                       .word   absEO+1
0036F7  1                       .word   absEO+2
0036F7  1                       .word   absEO+3
0036F7  1               indOR_: .word   absOR           ;indirect pointer to OR pattern in absolute memory
0036F7  1                       .word   absOR+1
0036F7  1                       .word   absOR+2
0036F7  1                       .word   absOR+3
0036F7  1               ;add/subtract indirect pointers
0036F7  1               adi2_:  .word   ada2            ;indirect pointer to operand 2 in absolute memory
0036F7  1               sbi2_:  .word   sba2            ;indirect pointer to complemented operand 2 (SBC)
0036F7  1               adiy2_: .word   ada2-$ff        ;with offset for indirect indexed
0036F7  1               sbiy2_: .word   sba2-$ff
0036F7  1               zp_end:
0036F7  1                   .if (zp_end - zp_init) <> (zp_bss_end - zp_bss)
0036F7  1                       ;force assembler error if size is different
0036F7  1                       .error "mismatch between bss and zeropage data"
0036F7  1                   .endif
0036F7  1               data_init:
0036F7  1               ex_and_:and #0              ;execute immediate opcodes
0036F7  1                       rts
0036F7  1               ex_eor_:eor #0              ;execute immediate opcodes
0036F7  1                       rts
0036F7  1               ex_ora_:ora #0              ;execute immediate opcodes
0036F7  1                       rts
0036F7  1               ex_adc_:adc #0              ;execute immediate opcodes
0036F7  1                       rts
0036F7  1               ex_sbc_:sbc #0              ;execute immediate opcodes
0036F7  1                       rts
0036F7  1               abs1_:  .byte   $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
0036F7  1               abs7f_: .byte   $7f             ;test pattern for compare
0036F7  1               ;loads
0036F7  1               fLDx_:  .byte   fn,fn,0,fz      ;expected flags for load
0036F7  1               ;shifts
0036F7  1               rASL_:                      ;expected result ASL & ROL -carry
0036F7  1               rROL_:  .byte   $86,$04,$82,0   ; "
0036F7  1               rROLc_: .byte   $87,$05,$83,1   ;expected result ROL +carry
0036F7  1               rLSR_:                      ;expected result LSR & ROR -carry
0036F7  1               rROR_:  .byte   $61,$41,$20,0   ; "
0036F7  1               rRORc_: .byte   $e1,$c1,$a0,$80 ;expected result ROR +carry
0036F7  1               fASL_:                      ;expected flags for shifts
0036F7  1               fROL_:  .byte   fnc,fc,fn,fz    ;no carry in
0036F7  1               fROLc_: .byte   fnc,fc,fn,0     ;carry in
0036F7  1               fLSR_:
0036F7  1               fROR_:  .byte   fc,0,fc,fz      ;no carry in
0036F7  1               fRORc_: .byte   fnc,fn,fnc,fn   ;carry in
0036F7  1               ;increments (decrements)
0036F7  1               rINC_:  .byte   $7f,$80,$ff,0,1 ;expected result for INC/DEC
0036F7  1               fINC_:  .byte   0,fn,fn,fz,0    ;expected flags for INC/DEC
0036F7  1               ;logical memory operand
0036F7  1               absOR_: .byte   0,$1f,$71,$80   ;test pattern for OR
0036F7  1               absAN_: .byte   $0f,$ff,$7f,$80 ;test pattern for AND
0036F7  1               absEO_: .byte   $ff,$0f,$8f,$8f ;test pattern for EOR
0036F7  1               ;logical accu operand
0036F7  1               absORa_:.byte   0,$f1,$1f,0     ;test pattern for OR
0036F7  1               absANa_:.byte   $f0,$ff,$ff,$ff ;test pattern for AND
0036F7  1               absEOa_:.byte   $ff,$f0,$f0,$0f ;test pattern for EOR
0036F7  1               ;logical results
0036F7  1               absrlo_:.byte   0,$ff,$7f,$80
0036F7  1               absflo_:.byte   fz,fn,0,fn
0036F7  1               data_end
0036F7  1                   .if (data_end - data_init) <> (data_bss_end - data_bss)
0036F7  1                       ;force assembler error if size is different
0036F7  1                       .error "mismatch between bss and data"
0036F7  1                   .endif
0036F7  1               
0036F7  1               vec_init
0036F7  1                       .word   nmi_trap
0036F7  1                       .word   res_trap
0036F7  1                       .word   irq_trap
0036F7  1               vec_bss equ $fffa
0036F7  1                   .endif                   ;end of RAM init data
0036F7  1               
0036F7  1                   .if (load_data_direct = 1) & (ROM_vectors = 1)
0036F7  1                       .segment "VECTORS"
0036F7  1                       .org $fffa       ;vectors
00FFFA  1  5F 36                .word   nmi_trap
00FFFC  1  65 36                .word   res_trap
00FFFE  1  6D 36                .word   irq_trap
010000  1                   .endif
010000  1               
